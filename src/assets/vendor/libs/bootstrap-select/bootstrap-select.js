/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/bootstrap-select/bootstrap-select.js":
/*!***************************************************!*\
  !*** ./libs/bootstrap-select/bootstrap-select.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bootstrapSelect: function() { return /* reexport default from dynamic */ bootstrap_select_js_bootstrap_select__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var bootstrap_select_js_bootstrap_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap-select/js/bootstrap-select */ \"./node_modules/bootstrap-select/js/bootstrap-select.js\");\n/* harmony import */ var bootstrap_select_js_bootstrap_select__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bootstrap_select_js_bootstrap_select__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL2Jvb3RzdHJhcC1zZWxlY3QvYm9vdHN0cmFwLXNlbGVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NYXRlcmlvLy4vbGlicy9ib290c3RyYXAtc2VsZWN0L2Jvb3RzdHJhcC1zZWxlY3QuanM/ZTA4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYm9vdHN0cmFwU2VsZWN0IGZyb20gJ2Jvb3RzdHJhcC1zZWxlY3QvanMvYm9vdHN0cmFwLXNlbGVjdCc7XG5cbmV4cG9ydCB7IGJvb3RzdHJhcFNlbGVjdCB9O1xuIl0sIm5hbWVzIjpbImJvb3RzdHJhcFNlbGVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/bootstrap-select/bootstrap-select.js\n");

/***/ }),

/***/ "./node_modules/bootstrap-select/js/bootstrap-select.js":
/*!**************************************************************!*\
  !*** ./node_modules/bootstrap-select/js/bootstrap-select.js ***!
  \**************************************************************/
/***/ (function() {

eval("(function ($) {\n  'use strict';\n\n  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\n\n  var uriAttrs = [\n    'background',\n    'cite',\n    'href',\n    'itemtype',\n    'longdesc',\n    'poster',\n    'src',\n    'xlink:href'\n  ];\n\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n\n  var DefaultWhitelist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;\n\n  var ParseableAttributes = ['title', 'placeholder']; // attributes to use as settings, can add others in the future\n\n  function allowedAttribute (attr, allowedAttributeList) {\n    var attrName = attr.nodeName.toLowerCase();\n\n    if ($.inArray(attrName, allowedAttributeList) !== -1) {\n      if ($.inArray(attrName, uriAttrs) !== -1) {\n        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));\n      }\n\n      return true;\n    }\n\n    var regExp = $(allowedAttributeList).filter(function (index, value) {\n      return value instanceof RegExp;\n    });\n\n    // Check if a regular expression validates the attribute.\n    for (var i = 0, l = regExp.length; i < l; i++) {\n      if (attrName.match(regExp[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function sanitizeHtml (unsafeElements, whiteList, sanitizeFn) {\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\n      return sanitizeFn(unsafeElements);\n    }\n\n    var whitelistKeys = Object.keys(whiteList);\n\n    for (var i = 0, len = unsafeElements.length; i < len; i++) {\n      var elements = unsafeElements[i].querySelectorAll('*');\n\n      for (var j = 0, len2 = elements.length; j < len2; j++) {\n        var el = elements[j];\n        var elName = el.nodeName.toLowerCase();\n\n        if (whitelistKeys.indexOf(elName) === -1) {\n          el.parentNode.removeChild(el);\n\n          continue;\n        }\n\n        var attributeList = [].slice.call(el.attributes);\n        var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\n\n        for (var k = 0, len3 = attributeList.length; k < len3; k++) {\n          var attr = attributeList[k];\n\n          if (!allowedAttribute(attr, whitelistedAttributes)) {\n            el.removeAttribute(attr.nodeName);\n          }\n        }\n      }\n    }\n  }\n\n  function getAttributesObject ($select) {\n    var attributesObject = {},\n        attrVal;\n\n    ParseableAttributes.forEach(function (item) {\n      attrVal = $select.attr(item);\n      if (attrVal) attributesObject[item] = attrVal;\n    });\n\n    // for backwards compatibility\n    // (using title as placeholder is deprecated - remove in v2.0.0)\n    if (!attributesObject.placeholder && attributesObject.title) {\n      attributesObject.placeholder = attributesObject.title;\n    }\n\n    return attributesObject;\n  }\n\n  // Polyfill for browsers with no classList support\n  // Remove in v2\n  if (!('classList' in document.createElement('_'))) {\n    (function (view) {\n      if (!('Element' in view)) return;\n\n      var classListProp = 'classList',\n          protoProp = 'prototype',\n          elemCtrProto = view.Element[protoProp],\n          objCtr = Object,\n          classListGetter = function () {\n            var $elem = $(this);\n\n            return {\n              add: function (classes) {\n                classes = Array.prototype.slice.call(arguments).join(' ');\n                return $elem.addClass(classes);\n              },\n              remove: function (classes) {\n                classes = Array.prototype.slice.call(arguments).join(' ');\n                return $elem.removeClass(classes);\n              },\n              toggle: function (classes, force) {\n                return $elem.toggleClass(classes, force);\n              },\n              contains: function (classes) {\n                return $elem.hasClass(classes);\n              }\n            };\n          };\n\n      if (objCtr.defineProperty) {\n        var classListPropDesc = {\n          get: classListGetter,\n          enumerable: true,\n          configurable: true\n        };\n        try {\n          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n        } catch (ex) { // IE 8 doesn't support enumerable:true\n          // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\n          // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\n          if (ex.number === undefined || ex.number === -0x7FF5EC54) {\n            classListPropDesc.enumerable = false;\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n          }\n        }\n      } else if (objCtr[protoProp].__defineGetter__) {\n        elemCtrProto.__defineGetter__(classListProp, classListGetter);\n      }\n    }(window));\n  }\n\n  var testElement = document.createElement('_');\n\n  testElement.classList.add('c1', 'c2');\n\n  if (!testElement.classList.contains('c2')) {\n    var _add = DOMTokenList.prototype.add,\n        _remove = DOMTokenList.prototype.remove;\n\n    DOMTokenList.prototype.add = function () {\n      Array.prototype.forEach.call(arguments, _add.bind(this));\n    };\n\n    DOMTokenList.prototype.remove = function () {\n      Array.prototype.forEach.call(arguments, _remove.bind(this));\n    };\n  }\n\n  testElement.classList.toggle('c3', false);\n\n  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n  // support the second argument.\n  if (testElement.classList.contains('c3')) {\n    var _toggle = DOMTokenList.prototype.toggle;\n\n    DOMTokenList.prototype.toggle = function (token, force) {\n      if (1 in arguments && !this.contains(token) === !force) {\n        return force;\n      } else {\n        return _toggle.call(this, token);\n      }\n    };\n  }\n\n  testElement = null;\n\n  // Polyfill for IE (remove in v2)\n  Object.values = typeof Object.values === 'function' ? Object.values : function (obj) {\n    return Object.keys(obj).map(function (key) {\n      return obj[key];\n    });\n  };\n\n  // shallow array comparison\n  function isEqual (array1, array2) {\n    return array1.length === array2.length && array1.every(function (element, index) {\n      return element === array2[index];\n    });\n  };\n\n  // <editor-fold desc=\"Shims\">\n  if (!String.prototype.startsWith) {\n    (function () {\n      'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n      var toString = {}.toString;\n      var startsWith = function (search) {\n        if (this == null) {\n          throw new TypeError();\n        }\n        var string = String(this);\n        if (search && toString.call(search) == '[object RegExp]') {\n          throw new TypeError();\n        }\n        var stringLength = string.length;\n        var searchString = String(search);\n        var searchLength = searchString.length;\n        var position = arguments.length > 1 ? arguments[1] : undefined;\n        // `ToInteger`\n        var pos = position ? Number(position) : 0;\n        if (pos != pos) { // better `isNaN`\n          pos = 0;\n        }\n        var start = Math.min(Math.max(pos, 0), stringLength);\n        // Avoid the `indexOf` call if no match is possible\n        if (searchLength + start > stringLength) {\n          return false;\n        }\n        var index = -1;\n        while (++index < searchLength) {\n          if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {\n            return false;\n          }\n        }\n        return true;\n      };\n      if (Object.defineProperty) {\n        Object.defineProperty(String.prototype, 'startsWith', {\n          'value': startsWith,\n          'configurable': true,\n          'writable': true\n        });\n      } else {\n        String.prototype.startsWith = startsWith;\n      }\n    }());\n  }\n\n  function toKebabCase (str) {\n    return str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, function ($, ofs) {\n      return (ofs ? '-' : '') + $.toLowerCase();\n    });\n  }\n\n  function getSelectedOptions () {\n    var options = this.selectpicker.main.data;\n\n    if (this.options.source.data || this.options.source.search) {\n      options = Object.values(this.selectpicker.optionValuesDataMap);\n    }\n\n    var selectedOptions = options.filter(function (item) {\n      if (item.selected) {\n        if (this.options.hideDisabled && item.disabled) return false;\n        return true;\n      }\n\n      return false;\n    }, this);\n\n    // ensure only 1 option is selected if multiple are set in the data source\n    if (this.options.source.data && !this.multiple && selectedOptions.length > 1) {\n      for (var i = 0; i < selectedOptions.length - 1; i++) {\n        selectedOptions[i].selected = false;\n      }\n\n      selectedOptions = [ selectedOptions[selectedOptions.length - 1] ];\n    }\n\n    return selectedOptions;\n  }\n\n  // much faster than $.val()\n  function getSelectValues (selectedOptions) {\n    var value = [],\n        options = selectedOptions || getSelectedOptions.call(this),\n        opt;\n\n    for (var i = 0, len = options.length; i < len; i++) {\n      opt = options[i];\n\n      if (!opt.disabled) {\n        value.push(opt.value === undefined ? opt.text : opt.value);\n      }\n    }\n\n    if (!this.multiple) {\n      return !value.length ? null : value[0];\n    }\n\n    return value;\n  }\n\n  // set data-selected on select element if the value has been programmatically selected\n  // prior to initialization of bootstrap-select\n  // * consider removing or replacing an alternative method *\n  var valHooks = {\n    useDefault: false,\n    _set: $.valHooks.select.set\n  };\n\n  $.valHooks.select.set = function (elem, value) {\n    if (value && !valHooks.useDefault) $(elem).data('selected', true);\n\n    return valHooks._set.apply(this, arguments);\n  };\n\n  var changedArguments = null;\n\n  var EventIsSupported = (function () {\n    try {\n      new Event('change');\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  $.fn.triggerNative = function (eventName) {\n    var el = this[0],\n        event;\n\n    if (el.dispatchEvent) { // for modern browsers & IE9+\n      if (EventIsSupported) {\n        // For modern browsers\n        event = new Event(eventName, {\n          bubbles: true\n        });\n      } else {\n        // For IE since it doesn't support Event constructor\n        event = document.createEvent('Event');\n        event.initEvent(eventName, true, false);\n      }\n\n      el.dispatchEvent(event);\n    }\n  };\n  // </editor-fold>\n\n  function stringSearch (li, searchString, method, normalize) {\n    var stringTypes = [\n          'display',\n          'subtext',\n          'tokens'\n        ],\n        searchSuccess = false;\n\n    for (var i = 0; i < stringTypes.length; i++) {\n      var stringType = stringTypes[i],\n          string = li[stringType];\n\n      if (string) {\n        string = string.toString();\n\n        // Strip HTML tags. This isn't perfect, but it's much faster than any other method\n        if (stringType === 'display') {\n          string = string.replace(/<[^>]+>/g, '');\n        }\n\n        if (normalize) string = normalizeToBase(string);\n        string = string.toUpperCase();\n\n        if (typeof method === 'function') {\n          searchSuccess = method(string, searchString);\n        } else if (method === 'contains') {\n          searchSuccess = string.indexOf(searchString) >= 0;\n        } else {\n          searchSuccess = string.startsWith(searchString);\n        }\n\n        if (searchSuccess) break;\n      }\n    }\n\n    return searchSuccess;\n  }\n\n  function toInteger (value) {\n    return parseInt(value, 10) || 0;\n  }\n\n  // Borrowed from Lodash (_.deburr)\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff',\n      rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsCombo = '[' + rsComboRange + ']';\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  function deburrLetter (key) {\n    return deburredLetters[key];\n  };\n\n  function normalizeToBase (string) {\n    string = string.toString();\n    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n  }\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function (map) {\n    var escaper = function (match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + Object.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function (string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n\n  var htmlEscape = createEscaper(escapeMap);\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var keyCodeMap = {\n    32: ' ',\n    48: '0',\n    49: '1',\n    50: '2',\n    51: '3',\n    52: '4',\n    53: '5',\n    54: '6',\n    55: '7',\n    56: '8',\n    57: '9',\n    59: ';',\n    65: 'A',\n    66: 'B',\n    67: 'C',\n    68: 'D',\n    69: 'E',\n    70: 'F',\n    71: 'G',\n    72: 'H',\n    73: 'I',\n    74: 'J',\n    75: 'K',\n    76: 'L',\n    77: 'M',\n    78: 'N',\n    79: 'O',\n    80: 'P',\n    81: 'Q',\n    82: 'R',\n    83: 'S',\n    84: 'T',\n    85: 'U',\n    86: 'V',\n    87: 'W',\n    88: 'X',\n    89: 'Y',\n    90: 'Z',\n    96: '0',\n    97: '1',\n    98: '2',\n    99: '3',\n    100: '4',\n    101: '5',\n    102: '6',\n    103: '7',\n    104: '8',\n    105: '9'\n  };\n\n  var keyCodes = {\n    ESCAPE: 27, // KeyboardEvent.which value for Escape (Esc) key\n    ENTER: 13, // KeyboardEvent.which value for Enter key\n    SPACE: 32, // KeyboardEvent.which value for space key\n    TAB: 9, // KeyboardEvent.which value for tab key\n    ARROW_UP: 38, // KeyboardEvent.which value for up arrow key\n    ARROW_DOWN: 40 // KeyboardEvent.which value for down arrow key\n  };\n\n  // eslint-disable-next-line no-undef\n  var Dropdown = window.Dropdown || bootstrap.Dropdown;\n\n  function getVersion () {\n    var version;\n\n    try {\n      version = $.fn.dropdown.Constructor.VERSION;\n    } catch (err) {\n      version = Dropdown.VERSION;\n    }\n\n    return version;\n  }\n\n  var version = {\n    success: false,\n    major: '3'\n  };\n\n  try {\n    version.full = (getVersion() || '').split(' ')[0].split('.');\n    version.major = version.full[0];\n    version.success = true;\n  } catch (err) {\n    // do nothing\n  }\n\n  var selectId = 0;\n\n  var EVENT_KEY = '.bs.select';\n\n  var classNames = {\n    DISABLED: 'disabled',\n    DIVIDER: 'divider',\n    SHOW: 'open',\n    DROPUP: 'dropup',\n    MENU: 'dropdown-menu',\n    MENURIGHT: 'dropdown-menu-right',\n    MENULEFT: 'dropdown-menu-left',\n    // to-do: replace with more advanced template/customization options\n    BUTTONCLASS: 'btn-default',\n    POPOVERHEADER: 'popover-title',\n    ICONBASE: 'glyphicon',\n    TICKICON: 'glyphicon-ok'\n  };\n\n  var Selector = {\n    MENU: '.' + classNames.MENU,\n    DATA_TOGGLE: 'data-toggle=\"dropdown\"'\n  };\n\n  var elementTemplates = {\n    div: document.createElement('div'),\n    span: document.createElement('span'),\n    i: document.createElement('i'),\n    subtext: document.createElement('small'),\n    a: document.createElement('a'),\n    li: document.createElement('li'),\n    whitespace: document.createTextNode('\\u00A0'),\n    fragment: document.createDocumentFragment(),\n    option: document.createElement('option')\n  };\n\n  elementTemplates.selectedOption = elementTemplates.option.cloneNode(false);\n  elementTemplates.selectedOption.setAttribute('selected', true);\n\n  elementTemplates.noResults = elementTemplates.li.cloneNode(false);\n  elementTemplates.noResults.className = 'no-results';\n\n  elementTemplates.a.setAttribute('role', 'option');\n  elementTemplates.a.className = 'dropdown-item';\n\n  elementTemplates.subtext.className = 'text-muted';\n\n  elementTemplates.text = elementTemplates.span.cloneNode(false);\n  elementTemplates.text.className = 'text';\n\n  elementTemplates.checkMark = elementTemplates.span.cloneNode(false);\n\n  var REGEXP_ARROW = new RegExp(keyCodes.ARROW_UP + '|' + keyCodes.ARROW_DOWN);\n  var REGEXP_TAB_OR_ESCAPE = new RegExp('^' + keyCodes.TAB + '$|' + keyCodes.ESCAPE);\n\n  var generateOption = {\n    li: function (content, classes, optgroup) {\n      var li = elementTemplates.li.cloneNode(false);\n\n      if (content) {\n        if (content.nodeType === 1 || content.nodeType === 11) {\n          li.appendChild(content);\n        } else {\n          li.innerHTML = content;\n        }\n      }\n\n      if (typeof classes !== 'undefined' && classes !== '') li.className = classes;\n      if (typeof optgroup !== 'undefined' && optgroup !== null) li.classList.add('optgroup-' + optgroup);\n\n      return li;\n    },\n\n    a: function (text, classes, inline) {\n      var a = elementTemplates.a.cloneNode(true);\n\n      if (text) {\n        if (text.nodeType === 11) {\n          a.appendChild(text);\n        } else {\n          a.insertAdjacentHTML('beforeend', text);\n        }\n      }\n\n      if (typeof classes !== 'undefined' && classes !== '') a.classList.add.apply(a.classList, classes.split(/\\s+/));\n      if (inline) a.setAttribute('style', inline);\n\n      return a;\n    },\n\n    text: function (options, useFragment) {\n      var textElement = elementTemplates.text.cloneNode(false),\n          subtextElement,\n          iconElement;\n\n      if (options.content) {\n        textElement.innerHTML = options.content;\n      } else {\n        textElement.textContent = options.text;\n\n        if (options.icon) {\n          var whitespace = elementTemplates.whitespace.cloneNode(false);\n\n          // need to use <i> for icons in the button to prevent a breaking change\n          // note: switch to span in next major release\n          iconElement = (useFragment === true ? elementTemplates.i : elementTemplates.span).cloneNode(false);\n          iconElement.className = this.options.iconBase + ' ' + options.icon;\n\n          elementTemplates.fragment.appendChild(iconElement);\n          elementTemplates.fragment.appendChild(whitespace);\n        }\n\n        if (options.subtext) {\n          subtextElement = elementTemplates.subtext.cloneNode(false);\n          subtextElement.textContent = options.subtext;\n          textElement.appendChild(subtextElement);\n        }\n      }\n\n      if (useFragment === true) {\n        while (textElement.childNodes.length > 0) {\n          elementTemplates.fragment.appendChild(textElement.childNodes[0]);\n        }\n      } else {\n        elementTemplates.fragment.appendChild(textElement);\n      }\n\n      return elementTemplates.fragment;\n    },\n\n    label: function (options) {\n      var textElement = elementTemplates.text.cloneNode(false),\n          subtextElement,\n          iconElement;\n\n      textElement.innerHTML = options.display;\n\n      if (options.icon) {\n        var whitespace = elementTemplates.whitespace.cloneNode(false);\n\n        iconElement = elementTemplates.span.cloneNode(false);\n        iconElement.className = this.options.iconBase + ' ' + options.icon;\n\n        elementTemplates.fragment.appendChild(iconElement);\n        elementTemplates.fragment.appendChild(whitespace);\n      }\n\n      if (options.subtext) {\n        subtextElement = elementTemplates.subtext.cloneNode(false);\n        subtextElement.textContent = options.subtext;\n        textElement.appendChild(subtextElement);\n      }\n\n      elementTemplates.fragment.appendChild(textElement);\n\n      return elementTemplates.fragment;\n    }\n  };\n\n  var getOptionData = {\n    fromOption: function (option, type) {\n      var value;\n\n      switch (type) {\n        case 'divider':\n          value = option.getAttribute('data-divider') === 'true';\n          break;\n\n        case 'text':\n          value = option.textContent;\n          break;\n\n        case 'label':\n          value = option.label;\n          break;\n\n        case 'style':\n          value = option.style.cssText;\n          break;\n\n        case 'title':\n          value = option.title;\n          break;\n\n        default:\n          value = option.getAttribute('data-' + toKebabCase(type));\n          break;\n      }\n\n      return value;\n    },\n    fromDataSource: function (option, type) {\n      var value;\n\n      switch (type) {\n        case 'text':\n        case 'label':\n          value = option.text || option.value || '';\n          break;\n\n        default:\n          value = option[type];\n          break;\n      }\n\n      return value;\n    }\n  };\n\n  function showNoResults (searchMatch, searchValue) {\n    if (!searchMatch.length) {\n      elementTemplates.noResults.innerHTML = this.options.noneResultsText.replace('{0}', '\"' + htmlEscape(searchValue) + '\"');\n      this.$menuInner[0].firstChild.appendChild(elementTemplates.noResults);\n    }\n  }\n\n  function filterHidden (item) {\n    return !(item.hidden || this.options.hideDisabled && item.disabled);\n  }\n\n  var Selectpicker = function (element, options) {\n    var that = this;\n\n    // bootstrap-select has been initialized - revert valHooks.select.set back to its original function\n    if (!valHooks.useDefault) {\n      $.valHooks.select.set = valHooks._set;\n      valHooks.useDefault = true;\n    }\n\n    this.$element = $(element);\n    this.$newElement = null;\n    this.$button = null;\n    this.$menu = null;\n    this.options = options;\n    this.selectpicker = {\n      main: {\n        data: [],\n        optionQueue: elementTemplates.fragment.cloneNode(false),\n        hasMore: false\n      },\n      search: {\n        data: [],\n        hasMore: false\n      },\n      current: {}, // current is either equal to main or search depending on if a search is in progress\n      view: {},\n      // map of option values and their respective data (only used in conjunction with options.source)\n      optionValuesDataMap: {},\n      isSearching: false,\n      keydown: {\n        keyHistory: '',\n        resetKeyHistory: {\n          start: function () {\n            return setTimeout(function () {\n              that.selectpicker.keydown.keyHistory = '';\n            }, 800);\n          }\n        }\n      }\n    };\n\n    this.sizeInfo = {};\n\n    // Format window padding\n    var winPad = this.options.windowPadding;\n    if (typeof winPad === 'number') {\n      this.options.windowPadding = [winPad, winPad, winPad, winPad];\n    }\n\n    // Expose public methods\n    this.val = Selectpicker.prototype.val;\n    this.render = Selectpicker.prototype.render;\n    this.refresh = Selectpicker.prototype.refresh;\n    this.setStyle = Selectpicker.prototype.setStyle;\n    this.selectAll = Selectpicker.prototype.selectAll;\n    this.deselectAll = Selectpicker.prototype.deselectAll;\n    this.destroy = Selectpicker.prototype.destroy;\n    this.remove = Selectpicker.prototype.remove;\n    this.show = Selectpicker.prototype.show;\n    this.hide = Selectpicker.prototype.hide;\n\n    this.init();\n  };\n\n  Selectpicker.VERSION = '1.14.0-beta3';\n\n  // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.\n  Selectpicker.DEFAULTS = {\n    noneSelectedText: 'Nothing selected',\n    noneResultsText: 'No results matched {0}',\n    countSelectedText: function (numSelected, numTotal) {\n      return (numSelected == 1) ? '{0} item selected' : '{0} items selected';\n    },\n    maxOptionsText: function (numAll, numGroup) {\n      return [\n        (numAll == 1) ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)',\n        (numGroup == 1) ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'\n      ];\n    },\n    selectAllText: 'Select All',\n    deselectAllText: 'Deselect All',\n    source: {\n      pageSize: 40\n    },\n    chunkSize: 40,\n    doneButton: false,\n    doneButtonText: 'Close',\n    multipleSeparator: ', ',\n    styleBase: 'btn',\n    style: classNames.BUTTONCLASS,\n    size: 'auto',\n    title: null,\n    placeholder: null,\n    allowClear: false,\n    selectedTextFormat: 'values',\n    width: false,\n    container: false,\n    hideDisabled: false,\n    showSubtext: false,\n    showIcon: true,\n    showContent: true,\n    dropupAuto: true,\n    header: false,\n    liveSearch: false,\n    liveSearchPlaceholder: null,\n    liveSearchNormalize: false,\n    liveSearchStyle: 'contains',\n    actionsBox: false,\n    iconBase: classNames.ICONBASE,\n    tickIcon: classNames.TICKICON,\n    showTick: false,\n    template: {\n      caret: '<span class=\"caret\"></span>'\n    },\n    maxOptions: false,\n    mobile: false,\n    selectOnTab: true,\n    dropdownAlignRight: false,\n    windowPadding: 0,\n    virtualScroll: 600,\n    display: false,\n    sanitize: true,\n    sanitizeFn: null,\n    whiteList: DefaultWhitelist\n  };\n\n  Selectpicker.prototype = {\n\n    constructor: Selectpicker,\n\n    init: function () {\n      var that = this,\n          id = this.$element.attr('id'),\n          element = this.$element[0],\n          form = element.form;\n\n      selectId++;\n      this.selectId = 'bs-select-' + selectId;\n\n      element.classList.add('bs-select-hidden');\n\n      this.multiple = this.$element.prop('multiple');\n      this.autofocus = this.$element.prop('autofocus');\n\n      if (element.classList.contains('show-tick')) {\n        this.options.showTick = true;\n      }\n\n      this.$newElement = this.createDropdown();\n\n      this.$element\n        .after(this.$newElement)\n        .prependTo(this.$newElement);\n\n      // ensure select is associated with form element if it got unlinked after moving it inside newElement\n      if (form && element.form === null) {\n        if (!form.id) form.id = 'form-' + this.selectId;\n        element.setAttribute('form', form.id);\n      }\n\n      this.$button = this.$newElement.children('button');\n      if (this.options.allowClear) this.$clearButton = this.$button.children('.bs-select-clear-selected');\n      this.$menu = this.$newElement.children(Selector.MENU);\n      this.$menuInner = this.$menu.children('.inner');\n      this.$searchbox = this.$menu.find('input');\n\n      element.classList.remove('bs-select-hidden');\n\n      this.fetchData(function () {\n        that.render(true);\n        that.buildList();\n\n        requestAnimationFrame(function () {\n          that.$element.trigger('loaded' + EVENT_KEY);\n        });\n      });\n\n      if (this.options.dropdownAlignRight === true) this.$menu[0].classList.add(classNames.MENURIGHT);\n\n      if (typeof id !== 'undefined') {\n        this.$button.attr('data-id', id);\n      }\n\n      this.checkDisabled();\n      this.clickListener();\n\n      if (version.major > 4) this.dropdown = new Dropdown(this.$button[0]);\n\n      if (this.options.liveSearch) {\n        this.liveSearchListener();\n        this.focusedParent = this.$searchbox[0];\n      } else {\n        this.focusedParent = this.$menuInner[0];\n      }\n\n      this.setStyle();\n      this.setWidth();\n      if (this.options.container) {\n        this.selectPosition();\n      } else {\n        this.$element.on('hide' + EVENT_KEY, function () {\n          if (that.isVirtual()) {\n            // empty menu on close\n            var menuInner = that.$menuInner[0],\n                emptyMenu = menuInner.firstChild.cloneNode(false);\n\n            // replace the existing UL with an empty one - this is faster than $.empty() or innerHTML = ''\n            menuInner.replaceChild(emptyMenu, menuInner.firstChild);\n            menuInner.scrollTop = 0;\n          }\n        });\n      }\n      this.$menu.data('this', this);\n      this.$newElement.data('this', this);\n      if (this.options.mobile) this.mobile();\n\n      this.$newElement.on({\n        'hide.bs.dropdown': function (e) {\n          that.$element.trigger('hide' + EVENT_KEY, e);\n        },\n        'hidden.bs.dropdown': function (e) {\n          that.$element.trigger('hidden' + EVENT_KEY, e);\n        },\n        'show.bs.dropdown': function (e) {\n          that.$element.trigger('show' + EVENT_KEY, e);\n        },\n        'shown.bs.dropdown': function (e) {\n          that.$element.trigger('shown' + EVENT_KEY, e);\n        }\n      });\n\n      if (element.hasAttribute('required')) {\n        this.$element.on('invalid' + EVENT_KEY, function () {\n          that.$button[0].classList.add('bs-invalid');\n\n          that.$element\n            .on('shown' + EVENT_KEY + '.invalid', function () {\n              that.$element\n                .val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened\n                .off('shown' + EVENT_KEY + '.invalid');\n            })\n            .on('rendered' + EVENT_KEY, function () {\n              // if select is no longer invalid, remove the bs-invalid class\n              if (this.validity.valid) that.$button[0].classList.remove('bs-invalid');\n              that.$element.off('rendered' + EVENT_KEY);\n            });\n\n          that.$button.on('blur' + EVENT_KEY, function () {\n            that.$element.trigger('focus').trigger('blur');\n            that.$button.off('blur' + EVENT_KEY);\n          });\n        });\n      }\n\n      if (form) {\n        $(form).on('reset' + EVENT_KEY, function () {\n          requestAnimationFrame(function () {\n            that.render();\n          });\n        });\n      }\n    },\n\n    createDropdown: function () {\n      // Options\n      // If we are multiple or showTick option is set, then add the show-tick class\n      var showTick = (this.multiple || this.options.showTick) ? ' show-tick' : '',\n          multiselectable = this.multiple ? ' aria-multiselectable=\"true\"' : '',\n          inputGroup = '',\n          autofocus = this.autofocus ? ' autofocus' : '';\n\n      if (version.major < 4 && this.$element.parent().hasClass('input-group')) {\n        inputGroup = ' input-group-btn';\n      }\n\n      // Elements\n      var drop,\n          header = '',\n          searchbox = '',\n          actionsbox = '',\n          donebutton = '',\n          clearButton = '';\n\n      if (this.options.header) {\n        header =\n          '<div class=\"' + classNames.POPOVERHEADER + '\">' +\n            '<button type=\"button\" class=\"close\" aria-hidden=\"true\">&times;</button>' +\n              this.options.header +\n          '</div>';\n      }\n\n      if (this.options.liveSearch) {\n        searchbox =\n          '<div class=\"bs-searchbox\">' +\n            '<input type=\"search\" class=\"form-control\" autocomplete=\"off\"' +\n              (\n                this.options.liveSearchPlaceholder === null ? ''\n                :\n                ' placeholder=\"' + htmlEscape(this.options.liveSearchPlaceholder) + '\"'\n              ) +\n              ' role=\"combobox\" aria-label=\"Search\" aria-controls=\"' + this.selectId + '\" aria-autocomplete=\"list\">' +\n          '</div>';\n      }\n\n      if (this.multiple && this.options.actionsBox) {\n        actionsbox =\n          '<div class=\"bs-actionsbox\">' +\n            '<div class=\"btn-group btn-group-sm\">' +\n              '<button type=\"button\" class=\"actions-btn bs-select-all btn ' + classNames.BUTTONCLASS + '\">' +\n                this.options.selectAllText +\n              '</button>' +\n              '<button type=\"button\" class=\"actions-btn bs-deselect-all btn ' + classNames.BUTTONCLASS + '\">' +\n                this.options.deselectAllText +\n              '</button>' +\n            '</div>' +\n          '</div>';\n      }\n\n      if (this.multiple && this.options.doneButton) {\n        donebutton =\n          '<div class=\"bs-donebutton\">' +\n            '<div class=\"btn-group\">' +\n              '<button type=\"button\" class=\"btn btn-sm ' + classNames.BUTTONCLASS + '\">' +\n                this.options.doneButtonText +\n              '</button>' +\n            '</div>' +\n          '</div>';\n      }\n\n      if (this.options.allowClear) {\n        clearButton = '<span class=\"close bs-select-clear-selected\" title=\"' + this.options.deselectAllText + '\"><span>&times;</span>';\n      }\n\n      drop =\n        '<div class=\"dropdown bootstrap-select' + showTick + inputGroup + '\">' +\n          '<button type=\"button\" tabindex=\"-1\" class=\"' +\n            this.options.styleBase +\n            ' dropdown-toggle\" ' +\n            (this.options.display === 'static' ? 'data-display=\"static\"' : '') +\n            Selector.DATA_TOGGLE +\n            autofocus +\n            ' role=\"combobox\" aria-owns=\"' +\n            this.selectId +\n            '\" aria-haspopup=\"listbox\" aria-expanded=\"false\">' +\n            '<div class=\"filter-option\">' +\n              '<div class=\"filter-option-inner\">' +\n                '<div class=\"filter-option-inner-inner\">&nbsp;</div>' +\n              '</div> ' +\n            '</div>' +\n            clearButton +\n            '</span>' +\n            (\n              version.major >= '4' ? ''\n              :\n              '<span class=\"bs-caret\">' +\n                this.options.template.caret +\n              '</span>'\n            ) +\n          '</button>' +\n          '<div class=\"' + classNames.MENU + ' ' + (version.major >= '4' ? '' : classNames.SHOW) + '\">' +\n            header +\n            searchbox +\n            actionsbox +\n            '<div class=\"inner ' + classNames.SHOW + '\" role=\"listbox\" id=\"' + this.selectId + '\" tabindex=\"-1\" ' + multiselectable + '>' +\n                '<ul class=\"' + classNames.MENU + ' inner ' + (version.major >= '4' ? classNames.SHOW : '') + '\" role=\"presentation\">' +\n                '</ul>' +\n            '</div>' +\n            donebutton +\n          '</div>' +\n        '</div>';\n\n      return $(drop);\n    },\n\n    setPositionData: function () {\n      this.selectpicker.view.canHighlight = [];\n      this.selectpicker.view.size = 0;\n      this.selectpicker.view.firstHighlightIndex = false;\n\n      for (var i = 0; i < this.selectpicker.current.data.length; i++) {\n        var li = this.selectpicker.current.data[i],\n            canHighlight = true;\n\n        if (li.type === 'divider') {\n          canHighlight = false;\n          li.height = this.sizeInfo.dividerHeight;\n        } else if (li.type === 'optgroup-label') {\n          canHighlight = false;\n          li.height = this.sizeInfo.dropdownHeaderHeight;\n        } else {\n          li.height = this.sizeInfo.liHeight;\n        }\n\n        if (li.disabled) canHighlight = false;\n\n        this.selectpicker.view.canHighlight.push(canHighlight);\n\n        if (canHighlight) {\n          this.selectpicker.view.size++;\n          li.posinset = this.selectpicker.view.size;\n          if (this.selectpicker.view.firstHighlightIndex === false) this.selectpicker.view.firstHighlightIndex = i;\n        }\n\n        li.position = (i === 0 ? 0 : this.selectpicker.current.data[i - 1].position) + li.height;\n      }\n    },\n\n    isVirtual: function () {\n      return (this.options.virtualScroll !== false) && (this.selectpicker.main.data.length >= this.options.virtualScroll) || this.options.virtualScroll === true;\n    },\n\n    createView: function (isSearching, setSize, refresh) {\n      var that = this,\n          scrollTop = 0;\n\n      this.selectpicker.isSearching = isSearching;\n      this.selectpicker.current = isSearching ? this.selectpicker.search : this.selectpicker.main;\n\n      this.setPositionData();\n\n      if (setSize) {\n        if (refresh) {\n          scrollTop = this.$menuInner[0].scrollTop;\n        } else if (!that.multiple) {\n          var element = that.$element[0],\n              selectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\n\n          if (typeof selectedIndex === 'number' && that.options.size !== false) {\n            var selectedData = that.selectpicker.main.data[selectedIndex],\n                position = selectedData && selectedData.position;\n\n            if (position) {\n              scrollTop = position - ((that.sizeInfo.menuInnerHeight + that.sizeInfo.liHeight) / 2);\n            }\n          }\n        }\n      }\n\n      scroll(scrollTop, true);\n\n      this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, updateValue) {\n        if (!that.noScroll) scroll(this.scrollTop, updateValue);\n        that.noScroll = false;\n      });\n\n      function scroll (scrollTop, init) {\n        var size = that.selectpicker.current.data.length,\n            chunks = [],\n            chunkSize,\n            chunkCount,\n            firstChunk,\n            lastChunk,\n            currentChunk,\n            prevPositions,\n            positionIsDifferent,\n            previousElements,\n            menuIsDifferent = true,\n            isVirtual = that.isVirtual();\n\n        that.selectpicker.view.scrollTop = scrollTop;\n\n        chunkSize = that.options.chunkSize; // number of options in a chunk\n        chunkCount = Math.ceil(size / chunkSize) || 1; // number of chunks\n\n        for (var i = 0; i < chunkCount; i++) {\n          var endOfChunk = (i + 1) * chunkSize;\n\n          if (i === chunkCount - 1) {\n            endOfChunk = size;\n          }\n\n          chunks[i] = [\n            (i) * chunkSize + (!i ? 0 : 1),\n            endOfChunk\n          ];\n\n          if (!size) break;\n\n          if (currentChunk === undefined && scrollTop - 1 <= that.selectpicker.current.data[endOfChunk - 1].position - that.sizeInfo.menuInnerHeight) {\n            currentChunk = i;\n          }\n        }\n\n        if (currentChunk === undefined) currentChunk = 0;\n\n        prevPositions = [that.selectpicker.view.position0, that.selectpicker.view.position1];\n\n        // always display previous, current, and next chunks\n        firstChunk = Math.max(0, currentChunk - 1);\n        lastChunk = Math.min(chunkCount - 1, currentChunk + 1);\n\n        that.selectpicker.view.position0 = isVirtual === false ? 0 : (Math.max(0, chunks[firstChunk][0]) || 0);\n        that.selectpicker.view.position1 = isVirtual === false ? size : (Math.min(size, chunks[lastChunk][1]) || 0);\n\n        positionIsDifferent = prevPositions[0] !== that.selectpicker.view.position0 || prevPositions[1] !== that.selectpicker.view.position1;\n\n        if (that.activeElement !== undefined) {\n          if (init) {\n            if (that.activeElement !== that.selectedElement) {\n              that.defocusItem(that.activeElement);\n            }\n            that.activeElement = undefined;\n          }\n\n          if (that.activeElement !== that.selectedElement) {\n            that.defocusItem(that.selectedElement);\n          }\n        }\n\n        if (that.prevActiveElement !== undefined && that.prevActiveElement !== that.activeElement && that.prevActiveElement !== that.selectedElement) {\n          that.defocusItem(that.prevActiveElement);\n        }\n\n        if (init || positionIsDifferent || that.selectpicker.current.hasMore) {\n          previousElements = that.selectpicker.view.visibleElements ? that.selectpicker.view.visibleElements.slice() : [];\n\n          if (isVirtual === false) {\n            that.selectpicker.view.visibleElements = that.selectpicker.current.elements;\n          } else {\n            that.selectpicker.view.visibleElements = that.selectpicker.current.elements.slice(that.selectpicker.view.position0, that.selectpicker.view.position1);\n          }\n\n          that.setOptionStatus();\n\n          // if searching, check to make sure the list has actually been updated before updating DOM\n          // this prevents unnecessary repaints\n          if (isSearching || (isVirtual === false && init)) menuIsDifferent = !isEqual(previousElements, that.selectpicker.view.visibleElements);\n\n          // if virtual scroll is disabled and not searching,\n          // menu should never need to be updated more than once\n          if ((init || isVirtual === true) && menuIsDifferent) {\n            var menuInner = that.$menuInner[0],\n                menuFragment = document.createDocumentFragment(),\n                emptyMenu = menuInner.firstChild.cloneNode(false),\n                marginTop,\n                marginBottom,\n                elements = that.selectpicker.view.visibleElements,\n                toSanitize = [];\n\n            // replace the existing UL with an empty one - this is faster than $.empty()\n            menuInner.replaceChild(emptyMenu, menuInner.firstChild);\n\n            for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {\n              var element = elements[i],\n                  elText,\n                  elementData;\n\n              if (that.options.sanitize) {\n                elText = element.lastChild;\n\n                if (elText) {\n                  elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0];\n\n                  if (elementData && elementData.content && !elementData.sanitized) {\n                    toSanitize.push(elText);\n                    elementData.sanitized = true;\n                  }\n                }\n              }\n\n              menuFragment.appendChild(element);\n            }\n\n            if (that.options.sanitize && toSanitize.length) {\n              sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);\n            }\n\n            if (isVirtual === true) {\n              marginTop = (that.selectpicker.view.position0 === 0 ? 0 : that.selectpicker.current.data[that.selectpicker.view.position0 - 1].position);\n              marginBottom = (that.selectpicker.view.position1 > size - 1 ? 0 : that.selectpicker.current.data[size - 1].position - that.selectpicker.current.data[that.selectpicker.view.position1 - 1].position);\n\n              menuInner.firstChild.style.marginTop = marginTop + 'px';\n              menuInner.firstChild.style.marginBottom = marginBottom + 'px';\n            } else {\n              menuInner.firstChild.style.marginTop = 0;\n              menuInner.firstChild.style.marginBottom = 0;\n            }\n\n            menuInner.firstChild.appendChild(menuFragment);\n\n            // if an option is encountered that is wider than the current menu width, update the menu width accordingly\n            // switch to ResizeObserver with increased browser support\n            if (isVirtual === true && that.sizeInfo.hasScrollBar) {\n              var menuInnerInnerWidth = menuInner.firstChild.offsetWidth;\n\n              if (init && menuInnerInnerWidth < that.sizeInfo.menuInnerInnerWidth && that.sizeInfo.totalMenuWidth > that.sizeInfo.selectWidth) {\n                menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\n              } else if (menuInnerInnerWidth > that.sizeInfo.menuInnerInnerWidth) {\n                // set to 0 to get actual width of menu\n                that.$menu[0].style.minWidth = 0;\n\n                var actualMenuWidth = menuInner.firstChild.offsetWidth;\n\n                if (actualMenuWidth > that.sizeInfo.menuInnerInnerWidth) {\n                  that.sizeInfo.menuInnerInnerWidth = actualMenuWidth;\n                  menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\n                }\n\n                // reset to default CSS styling\n                that.$menu[0].style.minWidth = '';\n              }\n            }\n          }\n\n          if ((!isSearching && that.options.source.data || isSearching && that.options.source.search) && that.selectpicker.current.hasMore && currentChunk === chunkCount - 1) {\n            // Don't load the next chunk until scrolling has started\n            // This prevents unnecessary requests while the user is typing if pageSize is <= chunkSize\n            if (scrollTop > 0) {\n              // Chunks use 0-based indexing, but pages use 1-based. Add 1 to convert and add 1 again to get next page\n              var page = Math.floor((currentChunk * that.options.chunkSize) / that.options.source.pageSize) + 2;\n\n              that.fetchData(function () {\n                that.render();\n                that.buildList(size, isSearching);\n                that.setPositionData();\n                scroll(scrollTop);\n              }, isSearching ? 'search' : 'data', page, isSearching ? that.selectpicker.search.previousValue : undefined);\n            }\n          }\n        }\n\n        that.prevActiveElement = that.activeElement;\n\n        if (!that.options.liveSearch) {\n          that.$menuInner.trigger('focus');\n        } else if (isSearching && init) {\n          var index = 0,\n              newActive;\n\n          if (!that.selectpicker.view.canHighlight[index]) {\n            index = 1 + that.selectpicker.view.canHighlight.slice(1).indexOf(true);\n          }\n\n          newActive = that.selectpicker.view.visibleElements[index];\n\n          that.defocusItem(that.selectpicker.view.currentActive);\n\n          that.activeElement = (that.selectpicker.current.data[index] || {}).element;\n\n          that.focusItem(newActive);\n        }\n      }\n\n      $(window)\n        .off('resize' + EVENT_KEY + '.' + this.selectId + '.createView')\n        .on('resize' + EVENT_KEY + '.' + this.selectId + '.createView', function () {\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\n\n          if (isActive) scroll(that.$menuInner[0].scrollTop);\n        });\n    },\n\n    focusItem: function (li, liData, noStyle) {\n      if (li) {\n        liData = liData || this.selectpicker.current.data[this.selectpicker.current.elements.indexOf(this.activeElement)];\n        var a = li.firstChild;\n\n        if (a) {\n          a.setAttribute('aria-setsize', this.selectpicker.view.size);\n          a.setAttribute('aria-posinset', liData.posinset);\n\n          if (noStyle !== true) {\n            this.focusedParent.setAttribute('aria-activedescendant', a.id);\n            li.classList.add('active');\n            a.classList.add('active');\n          }\n        }\n      }\n    },\n\n    defocusItem: function (li) {\n      if (li) {\n        li.classList.remove('active');\n        if (li.firstChild) li.firstChild.classList.remove('active');\n      }\n    },\n\n    setPlaceholder: function () {\n      var that = this,\n          updateIndex = false;\n\n      if ((this.options.placeholder || this.options.allowClear) && !this.multiple) {\n        if (!this.selectpicker.view.titleOption) this.selectpicker.view.titleOption = document.createElement('option');\n\n        // this option doesn't create a new <li> element, but does add a new option at the start,\n        // so startIndex should increase to prevent having to check every option for the bs-title-option class\n        updateIndex = true;\n\n        var element = this.$element[0],\n            selectTitleOption = false,\n            titleNotAppended = !this.selectpicker.view.titleOption.parentNode,\n            selectedIndex = element.selectedIndex,\n            selectedOption = element.options[selectedIndex],\n            firstSelectable = element.querySelector('select > *:not(:disabled)'),\n            firstSelectableIndex = firstSelectable ? firstSelectable.index : 0,\n            navigation = window.performance && window.performance.getEntriesByType('navigation'),\n            // Safari doesn't support getEntriesByType('navigation') - fall back to performance.navigation\n            isNotBackForward = (navigation && navigation.length) ? navigation[0].type !== 'back_forward' : window.performance.navigation.type !== 2;\n\n        if (titleNotAppended) {\n          // Use native JS to prepend option (faster)\n          this.selectpicker.view.titleOption.className = 'bs-title-option';\n          this.selectpicker.view.titleOption.value = '';\n\n          // Check if selected or data-selected attribute is already set on an option. If not, select the titleOption option.\n          // the selected item may have been changed by user or programmatically before the bootstrap select plugin runs,\n          // if so, the select will have the data-selected attribute\n          selectTitleOption = !selectedOption || (selectedIndex === firstSelectableIndex && selectedOption.defaultSelected === false && this.$element.data('selected') === undefined);\n        }\n\n        if (titleNotAppended || this.selectpicker.view.titleOption.index !== 0) {\n          element.insertBefore(this.selectpicker.view.titleOption, element.firstChild);\n        }\n\n        // Set selected *after* appending to select,\n        // otherwise the option doesn't get selected in IE\n        // set using selectedIndex, as setting the selected attr to true here doesn't work in IE11\n        if (selectTitleOption && isNotBackForward) {\n          element.selectedIndex = 0;\n        } else if (document.readyState !== 'complete') {\n          // if navigation type is back_forward, there's a chance the select will have its value set by BFCache\n          // wait for that value to be set, then run render again\n          window.addEventListener('pageshow', function () {\n            if (that.selectpicker.view.displayedValue !== element.value) that.render();\n          });\n        }\n      }\n\n      return updateIndex;\n    },\n\n    fetchData: function (callback, type, page, searchValue) {\n      page = page || 1;\n      type = type || 'data';\n\n      var that = this,\n          data = this.options.source[type],\n          builtData;\n\n      if (data) {\n        this.options.virtualScroll = true;\n\n        if (typeof data === 'function') {\n          data.call(\n            this,\n            function (data, more, totalItems) {\n              var current = that.selectpicker[type === 'search' ? 'search' : 'main'];\n              current.hasMore = more;\n              current.totalItems = totalItems;\n              builtData = that.buildData(data, type);\n              callback.call(that, builtData);\n              that.$element.trigger('fetched' + EVENT_KEY);\n            },\n            page,\n            searchValue\n          );\n        } else if (Array.isArray(data)) {\n          builtData = that.buildData(data, type);\n          callback.call(that, builtData);\n        }\n      } else {\n        builtData = this.buildData(false, type);\n        callback.call(that, builtData);\n      }\n    },\n\n    buildData: function (data, type) {\n      var that = this;\n      var dataGetter = data === false ? getOptionData.fromOption : getOptionData.fromDataSource;\n\n      var optionSelector = ':not([hidden]):not([data-hidden=\"true\"]):not([style*=\"display: none\"])',\n          mainData = [],\n          startLen = this.selectpicker.main.data ? this.selectpicker.main.data.length : 0,\n          optID = 0,\n          startIndex = this.setPlaceholder() && !data ? 1 : 0; // append the titleOption if necessary and skip the first option in the loop\n\n      if (type === 'search') {\n        startLen = this.selectpicker.search.data.length;\n      }\n\n      if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\n\n      var selectOptions = data ? data.filter(filterHidden, this) : this.$element[0].querySelectorAll('select > *' + optionSelector);\n\n      function addDivider (config) {\n        var previousData = mainData[mainData.length - 1];\n\n        // ensure optgroup doesn't create back-to-back dividers\n        if (\n          previousData &&\n          previousData.type === 'divider' &&\n          (previousData.optID || config.optID)\n        ) {\n          return;\n        }\n\n        config = config || {};\n        config.type = 'divider';\n\n        mainData.push(config);\n      }\n\n      function addOption (item, config) {\n        config = config || {};\n\n        config.divider = dataGetter(item, 'divider');\n\n        if (config.divider === true) {\n          addDivider({\n            optID: config.optID\n          });\n        } else {\n          var liIndex = mainData.length + startLen,\n              cssText = dataGetter(item, 'style'),\n              inlineStyle = cssText ? htmlEscape(cssText) : '',\n              optionClass = (item.className || '') + (config.optgroupClass || '');\n\n          if (config.optID) optionClass = 'opt ' + optionClass;\n\n          config.optionClass = optionClass.trim();\n          config.inlineStyle = inlineStyle;\n\n          config.text = dataGetter(item, 'text');\n          config.title = dataGetter(item, 'title');\n          config.content = dataGetter(item, 'content');\n          config.tokens = dataGetter(item, 'tokens');\n          config.subtext = dataGetter(item, 'subtext');\n          config.icon = dataGetter(item, 'icon');\n\n          config.display = config.content || config.text;\n          config.value = item.value === undefined ? item.text : item.value;\n          config.type = 'option';\n          config.index = liIndex;\n\n          config.option = !item.option ? item : item.option; // reference option element if it exists\n          config.option.liIndex = liIndex;\n          config.selected = !!item.selected;\n          config.disabled = config.disabled || !!item.disabled;\n\n          if (data !== false) {\n            if (that.selectpicker.optionValuesDataMap[config.value]) {\n              config = $.extend(that.selectpicker.optionValuesDataMap[config.value], config);\n            } else {\n              that.selectpicker.optionValuesDataMap[config.value] = config;\n            }\n          }\n\n          mainData.push(config);\n        }\n      }\n\n      function addOptgroup (index, selectOptions) {\n        var optgroup = selectOptions[index],\n            // skip placeholder option\n            previous = index - 1 < startIndex ? false : selectOptions[index - 1],\n            next = selectOptions[index + 1],\n            options = data ? optgroup.children.filter(filterHidden, this) : optgroup.querySelectorAll('option' + optionSelector);\n\n        if (!options.length) return;\n\n        var config = {\n              display: htmlEscape(dataGetter(item, 'label')),\n              subtext: dataGetter(optgroup, 'subtext'),\n              icon: dataGetter(optgroup, 'icon'),\n              type: 'optgroup-label',\n              optgroupClass: ' ' + (optgroup.className || ''),\n              optgroup: optgroup\n            },\n            headerIndex,\n            lastIndex;\n\n        optID++;\n\n        if (previous) {\n          addDivider({ optID: optID });\n        }\n\n        config.optID = optID;\n\n        mainData.push(config);\n\n        for (var j = 0, len = options.length; j < len; j++) {\n          var option = options[j];\n\n          if (j === 0) {\n            headerIndex = mainData.length - 1;\n            lastIndex = headerIndex + len;\n          }\n\n          addOption(option, {\n            headerIndex: headerIndex,\n            lastIndex: lastIndex,\n            optID: config.optID,\n            optgroupClass: config.optgroupClass,\n            disabled: optgroup.disabled\n          });\n        }\n\n        if (next) {\n          addDivider({ optID: optID });\n        }\n      }\n\n      for (var len = selectOptions.length, i = startIndex; i < len; i++) {\n        var item = selectOptions[i],\n            children = item.children;\n\n        if (children && children.length) {\n          addOptgroup.call(this, i, selectOptions);\n        } else {\n          addOption.call(this, item, {});\n        }\n      }\n\n      switch (type) {\n        case 'data': {\n          if (!this.selectpicker.main.data) {\n            this.selectpicker.main.data = [];\n          }\n          Array.prototype.push.apply(this.selectpicker.main.data, mainData);\n          this.selectpicker.current.data = this.selectpicker.main.data;\n          break;\n        }\n        case 'search': {\n          Array.prototype.push.apply(this.selectpicker.search.data, mainData);\n          break;\n        }\n      }\n\n      return mainData;\n    },\n\n    buildList: function (size, searching) {\n      var that = this,\n          selectData = searching ? this.selectpicker.search.data : this.selectpicker.main.data,\n          mainElements = [],\n          widestOptionLength = 0;\n\n      if ((that.options.showTick || that.multiple) && !elementTemplates.checkMark.parentNode) {\n        elementTemplates.checkMark.className = this.options.iconBase + ' ' + that.options.tickIcon + ' check-mark';\n        elementTemplates.a.appendChild(elementTemplates.checkMark);\n      }\n\n      function buildElement (mainElements, item) {\n        var liElement,\n            combinedLength = 0;\n\n        switch (item.type) {\n          case 'divider':\n            liElement = generateOption.li(\n              false,\n              classNames.DIVIDER,\n              (item.optID ? item.optID + 'div' : undefined)\n            );\n\n            break;\n\n          case 'option':\n            liElement = generateOption.li(\n              generateOption.a(\n                generateOption.text.call(that, item),\n                item.optionClass,\n                item.inlineStyle\n              ),\n              '',\n              item.optID\n            );\n\n            if (liElement.firstChild) {\n              liElement.firstChild.id = that.selectId + '-' + item.index;\n            }\n\n            break;\n\n          case 'optgroup-label':\n            liElement = generateOption.li(\n              generateOption.label.call(that, item),\n              'dropdown-header' + item.optgroupClass,\n              item.optID\n            );\n\n            break;\n        }\n\n        if (!item.element) {\n          item.element = liElement;\n        } else {\n          item.element.innerHTML = liElement.innerHTML;\n        }\n        mainElements.push(item.element);\n\n        // count the number of characters in the option - not perfect, but should work in most cases\n        if (item.display) combinedLength += item.display.length;\n        if (item.subtext) combinedLength += item.subtext.length;\n        // if there is an icon, ensure this option's width is checked\n        if (item.icon) combinedLength += 1;\n\n        if (combinedLength > widestOptionLength) {\n          widestOptionLength = combinedLength;\n\n          // guess which option is the widest\n          // use this when calculating menu width\n          // not perfect, but it's fast, and the width will be updating accordingly when scrolling\n          that.selectpicker.view.widestOption = mainElements[mainElements.length - 1];\n        }\n      }\n\n      var startIndex = size || 0;\n\n      for (var len = selectData.length, i = startIndex; i < len; i++) {\n        var item = selectData[i];\n\n        buildElement(mainElements, item);\n      }\n\n      if (size) {\n        if (searching) {\n          Array.prototype.push.apply(this.selectpicker.search.elements, mainElements);\n        } else {\n          Array.prototype.push.apply(this.selectpicker.main.elements, mainElements);\n          this.selectpicker.current.elements = this.selectpicker.main.elements;\n        }\n      } else {\n        if (searching) {\n          this.selectpicker.search.elements = mainElements;\n        } else {\n          this.selectpicker.main.elements = this.selectpicker.current.elements = mainElements;\n        }\n      }\n    },\n\n    findLis: function () {\n      return this.$menuInner.find('.inner > li');\n    },\n\n    render: function (init) {\n      var that = this,\n          element = this.$element[0],\n          // ensure titleOption is appended and selected (if necessary) before getting selectedOptions\n          placeholderSelected = this.setPlaceholder() && element.selectedIndex === 0,\n          selectedOptions = getSelectedOptions.call(this),\n          selectedCount = selectedOptions.length,\n          selectedValues = getSelectValues.call(this, selectedOptions),\n          button = this.$button[0],\n          buttonInner = button.querySelector('.filter-option-inner-inner'),\n          multipleSeparator = document.createTextNode(this.options.multipleSeparator),\n          titleFragment = elementTemplates.fragment.cloneNode(false),\n          showCount,\n          countMax,\n          hasContent = false;\n\n      function createSelected (item) {\n        if (item.selected) {\n          that.createOption(item, true);\n        } else if (item.children && item.children.length) {\n          item.children.map(createSelected);\n        }\n      }\n\n      // create selected option elements to ensure select value is correct\n      if (this.options.source.data && init) {\n        selectedOptions.map(createSelected);\n        element.appendChild(this.selectpicker.main.optionQueue);\n\n        if (placeholderSelected) placeholderSelected = element.selectedIndex === 0;\n      }\n\n      button.classList.toggle('bs-placeholder', that.multiple ? !selectedCount : !selectedValues && selectedValues !== 0);\n\n      if (!that.multiple && selectedOptions.length === 1) {\n        that.selectpicker.view.displayedValue = selectedValues;\n      }\n\n      if (this.options.selectedTextFormat === 'static') {\n        titleFragment = generateOption.text.call(this, { text: this.options.placeholder }, true);\n      } else {\n        showCount = this.multiple && this.options.selectedTextFormat.indexOf('count') !== -1 && selectedCount > 0;\n\n        // determine if the number of selected options will be shown (showCount === true)\n        if (showCount) {\n          countMax = this.options.selectedTextFormat.split('>');\n          showCount = (countMax.length > 1 && selectedCount > countMax[1]) || (countMax.length === 1 && selectedCount >= 2);\n        }\n\n        // only loop through all selected options if the count won't be shown\n        if (showCount === false) {\n          if (!placeholderSelected) {\n            for (var selectedIndex = 0; selectedIndex < selectedCount; selectedIndex++) {\n              if (selectedIndex < 50) {\n                var option = selectedOptions[selectedIndex],\n                    titleOptions = {};\n\n                if (option) {\n                  if (this.multiple && selectedIndex > 0) {\n                    titleFragment.appendChild(multipleSeparator.cloneNode(false));\n                  }\n\n                  if (option.title) {\n                    titleOptions.text = option.title;\n                  } else if (option.content && that.options.showContent) {\n                    titleOptions.content = option.content.toString();\n                    hasContent = true;\n                  } else {\n                    if (that.options.showIcon) {\n                      titleOptions.icon = option.icon;\n                    }\n                    if (that.options.showSubtext && !that.multiple && option.subtext) titleOptions.subtext = ' ' + option.subtext;\n                    titleOptions.text = option.text.trim();\n                  }\n\n                  titleFragment.appendChild(generateOption.text.call(this, titleOptions, true));\n                }\n              } else {\n                break;\n              }\n            }\n\n            // add ellipsis\n            if (selectedCount > 49) {\n              titleFragment.appendChild(document.createTextNode('...'));\n            }\n          }\n        } else {\n          var optionSelector = ':not([hidden]):not([data-hidden=\"true\"]):not([data-divider=\"true\"]):not([style*=\"display: none\"])';\n          if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\n\n          // If this is a multiselect, and selectedTextFormat is count, then show 1 of 2 selected, etc.\n          var totalCount = this.$element[0].querySelectorAll('select > option' + optionSelector + ', optgroup' + optionSelector + ' option' + optionSelector).length,\n              tr8nText = (typeof this.options.countSelectedText === 'function') ? this.options.countSelectedText(selectedCount, totalCount) : this.options.countSelectedText;\n\n          titleFragment = generateOption.text.call(this, {\n            text: tr8nText.replace('{0}', selectedCount.toString()).replace('{1}', totalCount.toString())\n          }, true);\n        }\n      }\n\n      // If the select doesn't have a title, then use the default, or if nothing is set at all, use noneSelectedText\n      if (!titleFragment.childNodes.length) {\n        titleFragment = generateOption.text.call(this, {\n          text: this.options.placeholder ? this.options.placeholder : this.options.noneSelectedText\n        }, true);\n      }\n\n      // if the select has a title, apply it to the button, and if not, apply titleFragment text\n      // strip all HTML tags and trim the result, then unescape any escaped tags\n      button.title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();\n\n      if (this.options.sanitize && hasContent) {\n        sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);\n      }\n\n      buttonInner.innerHTML = '';\n      buttonInner.appendChild(titleFragment);\n\n      if (version.major < 4 && this.$newElement[0].classList.contains('bs3-has-addon')) {\n        var filterExpand = button.querySelector('.filter-expand'),\n            clone = buttonInner.cloneNode(true);\n\n        clone.className = 'filter-expand';\n\n        if (filterExpand) {\n          button.replaceChild(clone, filterExpand);\n        } else {\n          button.appendChild(clone);\n        }\n      }\n\n      this.$element.trigger('rendered' + EVENT_KEY);\n    },\n\n    /**\n     * @param [style]\n     * @param [status]\n     */\n    setStyle: function (newStyle, status) {\n      var button = this.$button[0],\n          newElement = this.$newElement[0],\n          style = this.options.style.trim(),\n          buttonClass;\n\n      if (this.$element.attr('class')) {\n        this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\\[.*\\]/gi, ''));\n      }\n\n      if (version.major < 4) {\n        newElement.classList.add('bs3');\n\n        if (newElement.parentNode.classList && newElement.parentNode.classList.contains('input-group') &&\n            (newElement.previousElementSibling || newElement.nextElementSibling) &&\n            (newElement.previousElementSibling || newElement.nextElementSibling).classList.contains('input-group-addon')\n        ) {\n          newElement.classList.add('bs3-has-addon');\n        }\n      }\n\n      if (newStyle) {\n        buttonClass = newStyle.trim();\n      } else {\n        buttonClass = style;\n      }\n\n      if (status == 'add') {\n        if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\n      } else if (status == 'remove') {\n        if (buttonClass) button.classList.remove.apply(button.classList, buttonClass.split(' '));\n      } else {\n        if (style) button.classList.remove.apply(button.classList, style.split(' '));\n        if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\n      }\n    },\n\n    liHeight: function (refresh) {\n      if (!refresh && (this.options.size === false || Object.keys(this.sizeInfo).length)) return;\n\n      var newElement = elementTemplates.div.cloneNode(false),\n          menu = elementTemplates.div.cloneNode(false),\n          menuInner = elementTemplates.div.cloneNode(false),\n          menuInnerInner = document.createElement('ul'),\n          divider = elementTemplates.li.cloneNode(false),\n          dropdownHeader = elementTemplates.li.cloneNode(false),\n          li,\n          a = elementTemplates.a.cloneNode(false),\n          text = elementTemplates.span.cloneNode(false),\n          header = this.options.header && this.$menu.find('.' + classNames.POPOVERHEADER).length > 0 ? this.$menu.find('.' + classNames.POPOVERHEADER)[0].cloneNode(true) : null,\n          search = this.options.liveSearch ? elementTemplates.div.cloneNode(false) : null,\n          actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,\n          doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null,\n          firstOption = this.$element[0].options[0];\n\n      this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth;\n\n      text.className = 'text';\n      a.className = 'dropdown-item ' + (firstOption ? firstOption.className : '');\n      newElement.className = this.$menu[0].parentNode.className + ' ' + classNames.SHOW;\n      newElement.style.width = 0; // ensure button width doesn't affect natural width of menu when calculating\n      if (this.options.width === 'auto') menu.style.minWidth = 0;\n      menu.className = classNames.MENU + ' ' + classNames.SHOW;\n      menuInner.className = 'inner ' + classNames.SHOW;\n      menuInnerInner.className = classNames.MENU + ' inner ' + (version.major >= '4' ? classNames.SHOW : '');\n      divider.className = classNames.DIVIDER;\n      dropdownHeader.className = 'dropdown-header';\n\n      text.appendChild(document.createTextNode('\\u200b'));\n\n      if (this.selectpicker.current.data.length) {\n        for (var i = 0; i < this.selectpicker.current.data.length; i++) {\n          var data = this.selectpicker.current.data[i];\n          if (data.type === 'option' && $(data.element.firstChild).css('display') !== 'none') {\n            li = data.element;\n            break;\n          }\n        }\n      } else {\n        li = elementTemplates.li.cloneNode(false);\n        a.appendChild(text);\n        li.appendChild(a);\n      }\n\n      dropdownHeader.appendChild(text.cloneNode(true));\n\n      if (this.selectpicker.view.widestOption) {\n        menuInnerInner.appendChild(this.selectpicker.view.widestOption.cloneNode(true));\n      }\n\n      menuInnerInner.appendChild(li);\n      menuInnerInner.appendChild(divider);\n      menuInnerInner.appendChild(dropdownHeader);\n      if (header) menu.appendChild(header);\n      if (search) {\n        var input = document.createElement('input');\n        search.className = 'bs-searchbox';\n        input.className = 'form-control';\n        search.appendChild(input);\n        menu.appendChild(search);\n      }\n      if (actions) menu.appendChild(actions);\n      menuInner.appendChild(menuInnerInner);\n      menu.appendChild(menuInner);\n      if (doneButton) menu.appendChild(doneButton);\n      newElement.appendChild(menu);\n\n      document.body.appendChild(newElement);\n\n      var liHeight = li.offsetHeight,\n          dropdownHeaderHeight = dropdownHeader ? dropdownHeader.offsetHeight : 0,\n          headerHeight = header ? header.offsetHeight : 0,\n          searchHeight = search ? search.offsetHeight : 0,\n          actionsHeight = actions ? actions.offsetHeight : 0,\n          doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,\n          dividerHeight = $(divider).outerHeight(true),\n          menuStyle = window.getComputedStyle(menu),\n          menuWidth = menu.offsetWidth,\n          menuPadding = {\n            vert: toInteger(menuStyle.paddingTop) +\n                  toInteger(menuStyle.paddingBottom) +\n                  toInteger(menuStyle.borderTopWidth) +\n                  toInteger(menuStyle.borderBottomWidth),\n            horiz: toInteger(menuStyle.paddingLeft) +\n                  toInteger(menuStyle.paddingRight) +\n                  toInteger(menuStyle.borderLeftWidth) +\n                  toInteger(menuStyle.borderRightWidth)\n          },\n          menuExtras = {\n            vert: menuPadding.vert +\n                  toInteger(menuStyle.marginTop) +\n                  toInteger(menuStyle.marginBottom) + 2,\n            horiz: menuPadding.horiz +\n                  toInteger(menuStyle.marginLeft) +\n                  toInteger(menuStyle.marginRight) + 2\n          },\n          scrollBarWidth;\n\n      menuInner.style.overflowY = 'scroll';\n\n      scrollBarWidth = menu.offsetWidth - menuWidth;\n\n      document.body.removeChild(newElement);\n\n      this.sizeInfo.liHeight = liHeight;\n      this.sizeInfo.dropdownHeaderHeight = dropdownHeaderHeight;\n      this.sizeInfo.headerHeight = headerHeight;\n      this.sizeInfo.searchHeight = searchHeight;\n      this.sizeInfo.actionsHeight = actionsHeight;\n      this.sizeInfo.doneButtonHeight = doneButtonHeight;\n      this.sizeInfo.dividerHeight = dividerHeight;\n      this.sizeInfo.menuPadding = menuPadding;\n      this.sizeInfo.menuExtras = menuExtras;\n      this.sizeInfo.menuWidth = menuWidth;\n      this.sizeInfo.menuInnerInnerWidth = menuWidth - menuPadding.horiz;\n      this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth;\n      this.sizeInfo.scrollBarWidth = scrollBarWidth;\n      this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight;\n\n      this.setPositionData();\n    },\n\n    getSelectPosition: function () {\n      var that = this,\n          $window = $(window),\n          pos = that.$newElement.offset(),\n          $container = $(that.options.container),\n          containerPos;\n\n      if (that.options.container && $container.length && !$container.is('body')) {\n        containerPos = $container.offset();\n        containerPos.top += parseInt($container.css('borderTopWidth'));\n        containerPos.left += parseInt($container.css('borderLeftWidth'));\n      } else {\n        containerPos = { top: 0, left: 0 };\n      }\n\n      var winPad = that.options.windowPadding;\n\n      this.sizeInfo.selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();\n      this.sizeInfo.selectOffsetBot = $window.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo.selectHeight - containerPos.top - winPad[2];\n      this.sizeInfo.selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();\n      this.sizeInfo.selectOffsetRight = $window.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo.selectWidth - containerPos.left - winPad[1];\n      this.sizeInfo.selectOffsetTop -= winPad[0];\n      this.sizeInfo.selectOffsetLeft -= winPad[3];\n    },\n\n    setMenuSize: function (isAuto) {\n      this.getSelectPosition();\n\n      var selectWidth = this.sizeInfo.selectWidth,\n          liHeight = this.sizeInfo.liHeight,\n          headerHeight = this.sizeInfo.headerHeight,\n          searchHeight = this.sizeInfo.searchHeight,\n          actionsHeight = this.sizeInfo.actionsHeight,\n          doneButtonHeight = this.sizeInfo.doneButtonHeight,\n          divHeight = this.sizeInfo.dividerHeight,\n          menuPadding = this.sizeInfo.menuPadding,\n          menuInnerHeight,\n          menuHeight,\n          divLength = 0,\n          minHeight,\n          _minHeight,\n          maxHeight,\n          menuInnerMinHeight,\n          estimate,\n          isDropup;\n\n      if (this.options.dropupAuto) {\n        // Get the estimated height of the menu without scrollbars.\n        // This is useful for smaller menus, where there might be plenty of room\n        // below the button without setting dropup, but we can't know\n        // the exact height of the menu until createView is called later\n        estimate = liHeight * this.selectpicker.current.data.length + menuPadding.vert;\n\n        isDropup = this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && estimate + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot;\n\n        // ensure dropup doesn't change while searching (so menu doesn't bounce back and forth)\n        if (this.selectpicker.isSearching === true) {\n          isDropup = this.selectpicker.dropup;\n        }\n\n        this.$newElement.toggleClass(classNames.DROPUP, isDropup);\n        this.selectpicker.dropup = isDropup;\n      }\n\n      if (this.options.size === 'auto') {\n        _minHeight = this.selectpicker.current.data.length > 3 ? this.sizeInfo.liHeight * 3 + this.sizeInfo.menuExtras.vert - 2 : 0;\n        menuHeight = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert;\n        minHeight = _minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\n        menuInnerMinHeight = Math.max(_minHeight - menuPadding.vert, 0);\n\n        if (this.$newElement.hasClass(classNames.DROPUP)) {\n          menuHeight = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert;\n        }\n\n        maxHeight = menuHeight;\n        menuInnerHeight = menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert;\n      } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\n        for (var i = 0; i < this.options.size; i++) {\n          if (this.selectpicker.current.data[i].type === 'divider') divLength++;\n        }\n\n        menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;\n        menuInnerHeight = menuHeight - menuPadding.vert;\n        maxHeight = menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\n        minHeight = menuInnerMinHeight = '';\n      }\n\n      this.$menu.css({\n        'max-height': maxHeight + 'px',\n        'overflow': 'hidden',\n        'min-height': minHeight + 'px'\n      });\n\n      this.$menuInner.css({\n        'max-height': menuInnerHeight + 'px',\n        'overflow': 'hidden auto',\n        'min-height': menuInnerMinHeight + 'px'\n      });\n\n      // ensure menuInnerHeight is always a positive number to prevent issues calculating chunkSize in createView\n      this.sizeInfo.menuInnerHeight = Math.max(menuInnerHeight, 1);\n\n      if (this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight) {\n        this.sizeInfo.hasScrollBar = true;\n        this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth;\n      }\n\n      if (this.options.dropdownAlignRight === 'auto') {\n        this.$menu.toggleClass(classNames.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < (this.sizeInfo.totalMenuWidth - selectWidth));\n      }\n\n      if (this.dropdown && this.dropdown._popper) this.dropdown._popper.update();\n    },\n\n    setSize: function (refresh) {\n      this.liHeight(refresh);\n\n      if (this.options.header) this.$menu.css('padding-top', 0);\n\n      if (this.options.size !== false) {\n        var that = this,\n            $window = $(window);\n\n        this.setMenuSize();\n\n        if (this.options.liveSearch) {\n          this.$searchbox\n            .off('input.setMenuSize propertychange.setMenuSize')\n            .on('input.setMenuSize propertychange.setMenuSize', function () {\n              return that.setMenuSize();\n            });\n        }\n\n        if (this.options.size === 'auto') {\n          $window\n            .off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize')\n            .on('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize', function () {\n              return that.setMenuSize();\n            });\n        } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\n          $window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize');\n        }\n      }\n\n      this.createView(false, true, refresh);\n    },\n\n    setWidth: function () {\n      var that = this;\n\n      if (this.options.width === 'auto') {\n        requestAnimationFrame(function () {\n          that.$menu.css('min-width', '0');\n\n          that.$element.on('loaded' + EVENT_KEY, function () {\n            that.liHeight();\n            that.setMenuSize();\n\n            // Get correct width if element is hidden\n            var $selectClone = that.$newElement.clone().appendTo('body'),\n                btnWidth = $selectClone.css('width', 'auto').children('button').outerWidth();\n\n            $selectClone.remove();\n\n            // Set width to whatever's larger, button title or longest option\n            that.sizeInfo.selectWidth = Math.max(that.sizeInfo.totalMenuWidth, btnWidth);\n            that.$newElement.css('width', that.sizeInfo.selectWidth + 'px');\n          });\n        });\n      } else if (this.options.width === 'fit') {\n        // Remove inline min-width so width can be changed from 'auto'\n        this.$menu.css('min-width', '');\n        this.$newElement.css('width', '').addClass('fit-width');\n      } else if (this.options.width) {\n        // Remove inline min-width so width can be changed from 'auto'\n        this.$menu.css('min-width', '');\n        this.$newElement.css('width', this.options.width);\n      } else {\n        // Remove inline min-width/width so width can be changed\n        this.$menu.css('min-width', '');\n        this.$newElement.css('width', '');\n      }\n      // Remove fit-width class if width is changed programmatically\n      if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {\n        this.$newElement[0].classList.remove('fit-width');\n      }\n    },\n\n    selectPosition: function () {\n      this.$bsContainer = $('<div class=\"bs-container\" />');\n\n      var that = this,\n          $container = $(this.options.container),\n          pos,\n          containerPos,\n          actualHeight,\n          getPlacement = function ($element) {\n            var containerPosition = {},\n                // fall back to dropdown's default display setting if display is not manually set\n                display = that.options.display || (\n                  // Bootstrap 3 doesn't have $.fn.dropdown.Constructor.Default\n                  $.fn.dropdown.Constructor.Default ? $.fn.dropdown.Constructor.Default.display\n                  : false\n                );\n\n            that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(classNames.DROPUP, $element.hasClass(classNames.DROPUP));\n            pos = $element.offset();\n\n            if (!$container.is('body')) {\n              containerPos = $container.offset();\n              containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();\n              containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();\n            } else {\n              containerPos = { top: 0, left: 0 };\n            }\n\n            actualHeight = $element.hasClass(classNames.DROPUP) ? 0 : $element[0].offsetHeight;\n\n            // Bootstrap 4+ uses Popper for menu positioning\n            if (version.major < 4 || display === 'static') {\n              containerPosition.top = pos.top - containerPos.top + actualHeight;\n              containerPosition.left = pos.left - containerPos.left;\n            }\n\n            containerPosition.width = $element[0].offsetWidth;\n\n            that.$bsContainer.css(containerPosition);\n          };\n\n      this.$button.on('click.bs.dropdown.data-api', function () {\n        if (that.isDisabled()) {\n          return;\n        }\n\n        getPlacement(that.$newElement);\n\n        that.$bsContainer\n          .appendTo(that.options.container)\n          .toggleClass(classNames.SHOW, !that.$button.hasClass(classNames.SHOW))\n          .append(that.$menu);\n      });\n\n      $(window)\n        .off('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId)\n        .on('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId, function () {\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\n\n          if (isActive) getPlacement(that.$newElement);\n        });\n\n      this.$element.on('hide' + EVENT_KEY, function () {\n        that.$menu.data('height', that.$menu.height());\n        that.$bsContainer.detach();\n      });\n    },\n\n    createOption: function (data, init) {\n      var optionData = !data.option ? data : data.option;\n\n      if (optionData && optionData.nodeType !== 1) {\n        var option = (init ? elementTemplates.selectedOption : elementTemplates.option).cloneNode(true);\n        if (optionData.value !== undefined) option.value = optionData.value;\n        option.textContent = optionData.text;\n\n        option.selected = true;\n\n        if (optionData.liIndex !== undefined) {\n          option.liIndex = optionData.liIndex;\n        } else if (!init) {\n          option.liIndex = data.index;\n        }\n\n        data.option = option;\n\n        this.selectpicker.main.optionQueue.appendChild(option);\n      }\n    },\n\n    setOptionStatus: function (selectedOnly) {\n      var that = this;\n\n      that.noScroll = false;\n\n      if (that.selectpicker.view.visibleElements && that.selectpicker.view.visibleElements.length) {\n        for (var i = 0; i < that.selectpicker.view.visibleElements.length; i++) {\n          var liData = that.selectpicker.current.data[i + that.selectpicker.view.position0],\n              option = liData.option;\n\n          if (option) {\n            if (selectedOnly !== true) {\n              that.setDisabled(liData);\n            }\n\n            that.setSelected(liData);\n          }\n        }\n\n        // append optionQueue (documentFragment with option elements for select options)\n        if (this.options.source.data) this.$element[0].appendChild(this.selectpicker.main.optionQueue);\n      }\n    },\n\n    /**\n     * @param {Object} liData - the option object that is being changed\n     * @param {boolean} selected - true if the option is being selected, false if being deselected\n     */\n    setSelected: function (liData, selected) {\n      selected = selected === undefined ? liData.selected : selected;\n\n      var li = liData.element,\n          activeElementIsSet = this.activeElement !== undefined,\n          thisIsActive = this.activeElement === li,\n          prevActive,\n          a,\n          // if current option is already active\n          // OR\n          // if the current option is being selected, it's NOT multiple, and\n          // activeElement is undefined:\n          //  - when the menu is first being opened, OR\n          //  - after a search has been performed, OR\n          //  - when retainActive is false when selecting a new option (i.e. index of the newly selected option is not the same as the current activeElement)\n          keepActive = thisIsActive || (selected && !this.multiple && !activeElementIsSet);\n\n      if (!li) return;\n\n      if (selected !== undefined) {\n        liData.selected = selected;\n        if (liData.option) liData.option.selected = selected;\n      }\n\n      if (selected && this.options.source.data) {\n        this.createOption(liData, false);\n      }\n\n      a = li.firstChild;\n\n      if (selected) {\n        this.selectedElement = li;\n      }\n\n      li.classList.toggle('selected', selected);\n\n      if (keepActive) {\n        this.focusItem(li, liData);\n        this.selectpicker.view.currentActive = li;\n        this.activeElement = li;\n      } else {\n        this.defocusItem(li);\n      }\n\n      if (a) {\n        a.classList.toggle('selected', selected);\n\n        if (selected) {\n          a.setAttribute('aria-selected', true);\n        } else {\n          if (this.multiple) {\n            a.setAttribute('aria-selected', false);\n          } else {\n            a.removeAttribute('aria-selected');\n          }\n        }\n      }\n\n      if (!keepActive && !activeElementIsSet && selected && this.prevActiveElement !== undefined) {\n        prevActive = this.prevActiveElement;\n\n        this.defocusItem(prevActive);\n      }\n    },\n\n    /**\n     * @param {number} index - the index of the option that is being disabled\n     * @param {boolean} disabled - true if the option is being disabled, false if being enabled\n     */\n    setDisabled: function (liData) {\n      var disabled = liData.disabled,\n          li = liData.element,\n          a;\n\n      if (!li) return;\n\n      a = li.firstChild;\n\n      li.classList.toggle(classNames.DISABLED, disabled);\n\n      if (a) {\n        if (version.major >= '4') a.classList.toggle(classNames.DISABLED, disabled);\n\n        if (disabled) {\n          a.setAttribute('aria-disabled', disabled);\n          a.setAttribute('tabindex', -1);\n        } else {\n          a.removeAttribute('aria-disabled');\n          a.setAttribute('tabindex', 0);\n        }\n      }\n    },\n\n    isDisabled: function () {\n      return this.$element[0].disabled;\n    },\n\n    checkDisabled: function () {\n      if (this.isDisabled()) {\n        this.$newElement[0].classList.add(classNames.DISABLED);\n        this.$button.addClass(classNames.DISABLED).attr('aria-disabled', true);\n      } else {\n        if (this.$button[0].classList.contains(classNames.DISABLED)) {\n          this.$newElement[0].classList.remove(classNames.DISABLED);\n          this.$button.removeClass(classNames.DISABLED).attr('aria-disabled', false);\n        }\n      }\n    },\n\n    clickListener: function () {\n      var that = this,\n          $document = $(document);\n\n      $document.data('spaceSelect', false);\n\n      this.$button.on('keyup', function (e) {\n        if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {\n          e.preventDefault();\n          $document.data('spaceSelect', false);\n        }\n      });\n\n      this.$newElement.on('show.bs.dropdown', function () {\n        if (!that.dropdown && version.major === '4') {\n          that.dropdown = that.$button.data('bs.dropdown');\n          that.dropdown._menu = that.$menu[0];\n        }\n      });\n\n      function clearSelection (e) {\n        if (that.multiple) {\n          that.deselectAll();\n        } else {\n          var element = that.$element[0],\n              prevValue = element.value,\n              prevIndex = element.selectedIndex,\n              prevOption = element.options[prevIndex],\n              prevData = prevOption ? that.selectpicker.main.data[prevOption.liIndex] : false;\n\n          if (prevData) {\n            that.setSelected(prevData, false);\n          }\n\n          element.selectedIndex = 0;\n\n          changedArguments = [prevIndex, false, prevValue];\n          that.$element.triggerNative('change');\n        }\n\n        // remove selected styling if menu is open\n        if (that.$newElement.hasClass(classNames.SHOW)) {\n          if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n          }\n\n          that.createView(false);\n        }\n      }\n\n      this.$button.on('click.bs.dropdown.data-api', function (e) {\n        if (that.options.allowClear) {\n          var target = e.target,\n              clearButton = that.$clearButton[0];\n\n          // IE doesn't support event listeners on child elements of buttons\n          if (/MSIE|Trident/.test(window.navigator.userAgent)) {\n            target = document.elementFromPoint(e.clientX, e.clientY);\n          }\n\n          if (target === clearButton || target.parentElement === clearButton) {\n            e.stopImmediatePropagation();\n            clearSelection(e);\n          }\n        }\n\n        if (!that.$newElement.hasClass(classNames.SHOW)) {\n          that.setSize();\n        }\n      });\n\n      function setFocus () {\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n        } else {\n          that.$menuInner.trigger('focus');\n        }\n      }\n\n      function checkPopperExists () {\n        if (that.dropdown && that.dropdown._popper && that.dropdown._popper.state) {\n          setFocus();\n        } else {\n          requestAnimationFrame(checkPopperExists);\n        }\n      }\n\n      this.$element.on('shown' + EVENT_KEY, function () {\n        if (that.$menuInner[0].scrollTop !== that.selectpicker.view.scrollTop) {\n          that.$menuInner[0].scrollTop = that.selectpicker.view.scrollTop;\n        }\n\n        if (version.major > 3) {\n          requestAnimationFrame(checkPopperExists);\n        } else {\n          setFocus();\n        }\n      });\n\n      // ensure posinset and setsize are correct before selecting an option via a click\n      this.$menuInner.on('mouseenter', 'li a', function (e) {\n        var hoverLi = this.parentElement,\n            position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\n            index = Array.prototype.indexOf.call(hoverLi.parentElement.children, hoverLi),\n            hoverData = that.selectpicker.current.data[index + position0];\n\n        that.focusItem(hoverLi, hoverData, true);\n      });\n\n      this.$menuInner.on('click', 'li a', function (e, retainActive) {\n        var $this = $(this),\n            element = that.$element[0],\n            position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\n            clickedData = that.selectpicker.current.data[$this.parent().index() + position0],\n            clickedElement = clickedData.element,\n            prevValue = getSelectValues.call(that),\n            prevIndex = element.selectedIndex,\n            prevOption = element.options[prevIndex],\n            prevData = prevOption ? that.selectpicker.main.data[prevOption.liIndex] : false,\n            triggerChange = true;\n\n        // Don't close on multi choice menu\n        if (that.multiple && that.options.maxOptions !== 1) {\n          e.stopPropagation();\n        }\n\n        e.preventDefault();\n\n        // Don't run if the select is disabled\n        if (!that.isDisabled() && !$this.parent().hasClass(classNames.DISABLED)) {\n          var option = clickedData.option,\n              $option = $(option),\n              state = option.selected,\n              optgroupData = that.selectpicker.current.data.find(function (datum) {\n                return datum.optID === clickedData.optID && datum.type === 'optgroup-label';\n              }),\n              optgroup = optgroupData ? optgroupData.optgroup : undefined,\n              dataGetter = optgroup instanceof Element ? getOptionData.fromOption : getOptionData.fromDataSource,\n              optgroupOptions = optgroup && optgroup.children,\n              maxOptions = parseInt(that.options.maxOptions),\n              maxOptionsGrp = optgroup && parseInt(dataGetter(optgroup, 'maxOptions')) || false;\n\n          if (clickedElement === that.activeElement) retainActive = true;\n\n          if (!retainActive) {\n            that.prevActiveElement = that.activeElement;\n            that.activeElement = undefined;\n          }\n\n          if (!that.multiple || maxOptions === 1) { // Deselect previous option if not multi select\n            if (prevData) that.setSelected(prevData, false);\n            that.setSelected(clickedData, true);\n          } else { // Toggle the clicked option if multi select.\n            that.setSelected(clickedData, !state);\n            that.focusedParent.focus();\n\n            if (maxOptions !== false || maxOptionsGrp !== false) {\n              var maxReached = maxOptions < getSelectedOptions.call(that).length,\n                  selectedGroupOptions = 0;\n\n              if (optgroup && optgroup.children) {\n                for (var i = 0; i < optgroup.children.length; i++) {\n                  if (optgroup.children[i].selected) selectedGroupOptions++;\n                }\n              }\n\n              var maxReachedGrp = maxOptionsGrp < selectedGroupOptions;\n\n              if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {\n                if (maxOptions && maxOptions === 1) {\n                  element.selectedIndex = -1;\n                  that.setOptionStatus(true);\n                } else if (maxOptionsGrp && maxOptionsGrp === 1) {\n                  for (var i = 0; i < optgroupOptions.length; i++) {\n                    var _option = optgroupOptions[i];\n                    that.setSelected(that.selectpicker.current.data[_option.liIndex], false);\n                  }\n\n                  that.setSelected(clickedData, true);\n                } else {\n                  var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,\n                      maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,\n                      maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),\n                      maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),\n                      $notify = $('<div class=\"notify\"></div>');\n                  // If {var} is set in array, replace it\n                  /** @deprecated */\n                  if (maxOptionsArr[2]) {\n                    maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);\n                    maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);\n                  }\n\n                  that.$menu.append($notify);\n\n                  if (maxOptions && maxReached) {\n                    $notify.append($('<div>' + maxTxt + '</div>'));\n                    triggerChange = false;\n                    that.$element.trigger('maxReached' + EVENT_KEY);\n                  }\n\n                  if (maxOptionsGrp && maxReachedGrp) {\n                    $notify.append($('<div>' + maxTxtGrp + '</div>'));\n                    triggerChange = false;\n                    that.$element.trigger('maxReachedGrp' + EVENT_KEY);\n                  }\n\n                  setTimeout(function () {\n                    that.setSelected(clickedData, false);\n                  }, 10);\n\n                  $notify[0].classList.add('fadeOut');\n\n                  setTimeout(function () {\n                    $notify.remove();\n                  }, 1050);\n                }\n              }\n            }\n          }\n\n          if (that.options.source.data) that.$element[0].appendChild(that.selectpicker.main.optionQueue);\n\n          if (!that.multiple || (that.multiple && that.options.maxOptions === 1)) {\n            that.$button.trigger('focus');\n          } else if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n          }\n\n          // Trigger select 'change'\n          if (triggerChange) {\n            if (that.multiple || prevIndex !== element.selectedIndex) {\n              // $option.prop('selected') is current option state (selected/unselected). prevValue is the value of the select prior to being changed.\n              changedArguments = [option.index, $option.prop('selected'), prevValue];\n              that.$element\n                .triggerNative('change');\n            }\n          }\n        }\n      });\n\n      this.$menu.on('click', 'li.' + classNames.DISABLED + ' a, .' + classNames.POPOVERHEADER + ', .' + classNames.POPOVERHEADER + ' :not(.close)', function (e) {\n        if (e.currentTarget == this) {\n          e.preventDefault();\n          e.stopPropagation();\n          if (that.options.liveSearch && !$(e.target).hasClass('close')) {\n            that.$searchbox.trigger('focus');\n          } else {\n            that.$button.trigger('focus');\n          }\n        }\n      });\n\n      this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n        } else {\n          that.$button.trigger('focus');\n        }\n      });\n\n      this.$menu.on('click', '.' + classNames.POPOVERHEADER + ' .close', function () {\n        that.$button.trigger('click');\n      });\n\n      this.$searchbox.on('click', function (e) {\n        e.stopPropagation();\n      });\n\n      this.$menu.on('click', '.actions-btn', function (e) {\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n        } else {\n          that.$button.trigger('focus');\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n\n        if ($(this).hasClass('bs-select-all')) {\n          that.selectAll();\n        } else {\n          that.deselectAll();\n        }\n      });\n\n      this.$button\n        .on('focus' + EVENT_KEY, function (e) {\n          var tabindex = that.$element[0].getAttribute('tabindex');\n\n          // only change when button is actually focused\n          if (tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\n            // apply select element's tabindex to ensure correct order is followed when tabbing to the next element\n            this.setAttribute('tabindex', tabindex);\n            // set element's tabindex to -1 to allow for reverse tabbing\n            that.$element[0].setAttribute('tabindex', -1);\n            that.selectpicker.view.tabindex = tabindex;\n          }\n        })\n        .on('blur' + EVENT_KEY, function (e) {\n          // revert everything to original tabindex\n          if (that.selectpicker.view.tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\n            that.$element[0].setAttribute('tabindex', that.selectpicker.view.tabindex);\n            this.setAttribute('tabindex', -1);\n            that.selectpicker.view.tabindex = undefined;\n          }\n        });\n\n      this.$element\n        .on('change' + EVENT_KEY, function () {\n          that.render();\n          that.$element.trigger('changed' + EVENT_KEY, changedArguments);\n          changedArguments = null;\n        })\n        .on('focus' + EVENT_KEY, function () {\n          if (!that.options.mobile) that.$button[0].focus();\n        });\n    },\n\n    liveSearchListener: function () {\n      var that = this;\n\n      this.$button.on('click.bs.dropdown.data-api', function () {\n        if (!!that.$searchbox.val()) {\n          that.$searchbox.val('');\n          that.selectpicker.search.previousValue = undefined;\n        }\n      });\n\n      this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', function (e) {\n        e.stopPropagation();\n      });\n\n      this.$searchbox.on('input propertychange', function () {\n        var searchValue = that.$searchbox[0].value;\n\n        that.selectpicker.search.elements = [];\n        that.selectpicker.search.data = [];\n\n        if (searchValue) {\n          that.selectpicker.search.previousValue = searchValue;\n\n          if (that.options.source.search) {\n            that.fetchData(function (builtData) {\n              that.render();\n              that.buildList(undefined, true);\n              that.noScroll = true;\n              that.$menuInner.scrollTop(0);\n              that.createView(true);\n              showNoResults.call(that, builtData, searchValue);\n            }, 'search', 0, searchValue);\n          } else {\n            var i,\n                searchMatch = [],\n                q = searchValue.toUpperCase(),\n                cache = {},\n                cacheArr = [],\n                searchStyle = that._searchStyle(),\n                normalizeSearch = that.options.liveSearchNormalize;\n\n            if (normalizeSearch) q = normalizeToBase(q);\n\n            for (var i = 0; i < that.selectpicker.main.data.length; i++) {\n              var li = that.selectpicker.main.data[i];\n\n              if (!cache[i]) {\n                cache[i] = stringSearch(li, q, searchStyle, normalizeSearch);\n              }\n\n              if (cache[i] && li.headerIndex !== undefined && cacheArr.indexOf(li.headerIndex) === -1) {\n                if (li.headerIndex > 0) {\n                  cache[li.headerIndex - 1] = true;\n                  cacheArr.push(li.headerIndex - 1);\n                }\n\n                cache[li.headerIndex] = true;\n                cacheArr.push(li.headerIndex);\n\n                cache[li.lastIndex + 1] = true;\n              }\n\n              if (cache[i] && li.type !== 'optgroup-label') cacheArr.push(i);\n            }\n\n            for (var i = 0, cacheLen = cacheArr.length; i < cacheLen; i++) {\n              var index = cacheArr[i],\n                  prevIndex = cacheArr[i - 1],\n                  li = that.selectpicker.main.data[index],\n                  liPrev = that.selectpicker.main.data[prevIndex];\n\n              if (li.type !== 'divider' || (li.type === 'divider' && liPrev && liPrev.type !== 'divider' && cacheLen - 1 !== i)) {\n                that.selectpicker.search.data.push(li);\n                searchMatch.push(that.selectpicker.main.elements[index]);\n              }\n            }\n\n            that.activeElement = undefined;\n            that.noScroll = true;\n            that.$menuInner.scrollTop(0);\n            that.selectpicker.search.elements = searchMatch;\n            that.createView(true);\n            showNoResults.call(that, searchMatch, searchValue);\n          }\n        } else if (that.selectpicker.search.previousValue) { // for IE11 (#2402)\n          that.$menuInner.scrollTop(0);\n          that.createView(false);\n        }\n      });\n    },\n\n    _searchStyle: function () {\n      return this.options.liveSearchStyle || 'contains';\n    },\n\n    val: function (value) {\n      var element = this.$element[0];\n\n      if (typeof value !== 'undefined') {\n        var selectedOptions = getSelectedOptions.call(this),\n            prevValue = getSelectValues.call(this, selectedOptions);\n\n        changedArguments = [null, null, prevValue];\n\n        if (!Array.isArray(value)) value = [ value ];\n\n        value.map(String);\n\n        for (var i = 0; i < selectedOptions.length; i++) {\n          var item = selectedOptions[i];\n\n          if (item && value.indexOf(String(item.value)) === -1) {\n            this.setSelected(item, false);\n          }\n        }\n\n        // only update selected value if it matches an existing option\n        this.selectpicker.main.data.filter(function (item) {\n          if (value.indexOf(String(item.value)) !== -1) {\n            this.setSelected(item, true);\n            return true;\n          }\n\n          return false;\n        }, this);\n\n        if (this.options.source.data) element.appendChild(this.selectpicker.main.optionQueue);\n\n        this.$element.trigger('changed' + EVENT_KEY, changedArguments);\n\n        if (this.$newElement.hasClass(classNames.SHOW)) {\n          if (this.multiple) {\n            this.setOptionStatus(true);\n          } else {\n            var liSelectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\n\n            if (typeof liSelectedIndex === 'number') {\n              this.setSelected(this.selectpicker.current.data[liSelectedIndex], true);\n            }\n          }\n        }\n\n        this.render();\n\n        changedArguments = null;\n\n        return this.$element;\n      } else {\n        return this.$element.val();\n      }\n    },\n\n    changeAll: function (status) {\n      if (!this.multiple) return;\n      if (typeof status === 'undefined') status = true;\n\n      var element = this.$element[0],\n          previousSelected = 0,\n          currentSelected = 0,\n          prevValue = getSelectValues.call(this);\n\n      element.classList.add('bs-select-hidden');\n\n      for (var i = 0, data = this.selectpicker.current.data, len = data.length; i < len; i++) {\n        var liData = data[i],\n            option = liData.option;\n\n        if (option && !liData.disabled && liData.type !== 'divider') {\n          if (liData.selected) previousSelected++;\n          option.selected = status;\n          liData.selected = status;\n          if (status === true) currentSelected++;\n        }\n      }\n\n      element.classList.remove('bs-select-hidden');\n\n      if (previousSelected === currentSelected) return;\n\n      this.setOptionStatus();\n\n      changedArguments = [null, null, prevValue];\n\n      this.$element\n        .triggerNative('change');\n    },\n\n    selectAll: function () {\n      return this.changeAll(true);\n    },\n\n    deselectAll: function () {\n      return this.changeAll(false);\n    },\n\n    toggle: function (e, state) {\n      var isActive,\n          triggerClick = state === undefined;\n\n      e = e || window.event;\n\n      if (e) e.stopPropagation();\n\n      if (triggerClick === false) {\n        isActive = this.$newElement[0].classList.contains(classNames.SHOW);\n        triggerClick = state === true && isActive === false || state === false && isActive === true;\n      }\n\n      if (triggerClick) this.$button.trigger('click.bs.dropdown.data-api');\n    },\n\n    open: function (e) {\n      this.toggle(e, true);\n    },\n\n    close: function (e) {\n      this.toggle(e, false);\n    },\n\n    keydown: function (e) {\n      var $this = $(this),\n          isToggle = $this.hasClass('dropdown-toggle'),\n          $parent = isToggle ? $this.closest('.dropdown') : $this.closest(Selector.MENU),\n          that = $parent.data('this'),\n          $items = that.findLis(),\n          index,\n          isActive,\n          liActive,\n          activeLi,\n          offset,\n          updateScroll = false,\n          downOnTab = e.which === keyCodes.TAB && !isToggle && !that.options.selectOnTab,\n          isArrowKey = REGEXP_ARROW.test(e.which) || downOnTab,\n          scrollTop = that.$menuInner[0].scrollTop,\n          isVirtual = that.isVirtual(),\n          position0 = isVirtual === true ? that.selectpicker.view.position0 : 0;\n\n      // do nothing if a function key is pressed\n      if (e.which >= 112 && e.which <= 123) return;\n\n      isActive = that.$menu.hasClass(classNames.SHOW);\n\n      if (\n        !isActive &&\n        (\n          isArrowKey ||\n          (e.which >= 48 && e.which <= 57) ||\n          (e.which >= 96 && e.which <= 105) ||\n          (e.which >= 65 && e.which <= 90)\n        )\n      ) {\n        that.$button.trigger('click.bs.dropdown.data-api');\n\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n          return;\n        }\n      }\n\n      if (e.which === keyCodes.ESCAPE && isActive) {\n        e.preventDefault();\n        that.$button.trigger('click.bs.dropdown.data-api').trigger('focus');\n      }\n\n      if (isArrowKey) { // if up or down\n        if (!$items.length) return;\n\n        liActive = that.activeElement;\n        index = liActive ? Array.prototype.indexOf.call(liActive.parentElement.children, liActive) : -1;\n\n        if (index !== -1) {\n          that.defocusItem(liActive);\n        }\n\n        if (e.which === keyCodes.ARROW_UP) { // up\n          if (index !== -1) index--;\n          if (index + position0 < 0) index += $items.length;\n\n          if (!that.selectpicker.view.canHighlight[index + position0]) {\n            index = that.selectpicker.view.canHighlight.slice(0, index + position0).lastIndexOf(true) - position0;\n            if (index === -1) index = $items.length - 1;\n          }\n        } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down\n          index++;\n          if (index + position0 >= that.selectpicker.view.canHighlight.length) index = that.selectpicker.view.firstHighlightIndex;\n\n          if (!that.selectpicker.view.canHighlight[index + position0]) {\n            index = index + 1 + that.selectpicker.view.canHighlight.slice(index + position0 + 1).indexOf(true);\n          }\n        }\n\n        e.preventDefault();\n\n        var liActiveIndex = position0 + index;\n\n        if (e.which === keyCodes.ARROW_UP) { // up\n          // scroll to bottom and highlight last option\n          if (position0 === 0 && index === $items.length - 1) {\n            that.$menuInner[0].scrollTop = that.$menuInner[0].scrollHeight;\n\n            liActiveIndex = that.selectpicker.current.elements.length - 1;\n          } else {\n            activeLi = that.selectpicker.current.data[liActiveIndex];\n\n            // could be undefined if no results exist\n            if (activeLi) {\n              offset = activeLi.position - activeLi.height;\n\n              updateScroll = offset < scrollTop;\n            }\n          }\n        } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down\n          // scroll to top and highlight first option\n          if (index === that.selectpicker.view.firstHighlightIndex) {\n            that.$menuInner[0].scrollTop = 0;\n\n            liActiveIndex = that.selectpicker.view.firstHighlightIndex;\n          } else {\n            activeLi = that.selectpicker.current.data[liActiveIndex];\n\n            // could be undefined if no results exist\n            if (activeLi) {\n              offset = activeLi.position - that.sizeInfo.menuInnerHeight;\n\n              updateScroll = offset > scrollTop;\n            }\n          }\n        }\n\n        liActive = that.selectpicker.current.elements[liActiveIndex];\n\n        that.activeElement = (that.selectpicker.current.data[liActiveIndex] || {}).element;\n\n        that.focusItem(liActive);\n\n        that.selectpicker.view.currentActive = liActive;\n\n        if (updateScroll) that.$menuInner[0].scrollTop = offset;\n\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n        } else {\n          $this.trigger('focus');\n        }\n      } else if (\n        (!$this.is('input') && !REGEXP_TAB_OR_ESCAPE.test(e.which)) ||\n        (e.which === keyCodes.SPACE && that.selectpicker.keydown.keyHistory)\n      ) {\n        var searchMatch,\n            matches = [],\n            keyHistory;\n\n        e.preventDefault();\n\n        that.selectpicker.keydown.keyHistory += keyCodeMap[e.which];\n\n        if (that.selectpicker.keydown.resetKeyHistory.cancel) clearTimeout(that.selectpicker.keydown.resetKeyHistory.cancel);\n        that.selectpicker.keydown.resetKeyHistory.cancel = that.selectpicker.keydown.resetKeyHistory.start();\n\n        keyHistory = that.selectpicker.keydown.keyHistory;\n\n        // if all letters are the same, set keyHistory to just the first character when searching\n        if (/^(.)\\1+$/.test(keyHistory)) {\n          keyHistory = keyHistory.charAt(0);\n        }\n\n        // find matches\n        for (var i = 0; i < that.selectpicker.current.data.length; i++) {\n          var li = that.selectpicker.current.data[i],\n              hasMatch;\n\n          hasMatch = stringSearch(li, keyHistory, 'startsWith', true);\n\n          if (hasMatch && that.selectpicker.view.canHighlight[i]) {\n            matches.push(li.element);\n          }\n        }\n\n        if (matches.length) {\n          var matchIndex = 0;\n\n          $items.removeClass('active').find('a').removeClass('active');\n\n          // either only one key has been pressed or they are all the same key\n          if (keyHistory.length === 1) {\n            matchIndex = matches.indexOf(that.activeElement);\n\n            if (matchIndex === -1 || matchIndex === matches.length - 1) {\n              matchIndex = 0;\n            } else {\n              matchIndex++;\n            }\n          }\n\n          searchMatch = matches[matchIndex];\n\n          activeLi = that.selectpicker.main.data[searchMatch];\n\n          if (scrollTop - activeLi.position > 0) {\n            offset = activeLi.position - activeLi.height;\n            updateScroll = true;\n          } else {\n            offset = activeLi.position - that.sizeInfo.menuInnerHeight;\n            // if the option is already visible at the current scroll position, just keep it the same\n            updateScroll = activeLi.position > scrollTop + that.sizeInfo.menuInnerHeight;\n          }\n\n          liActive = that.selectpicker.main.elements[searchMatch];\n\n          that.activeElement = liActive;\n\n          that.focusItem(liActive);\n\n          if (liActive) liActive.firstChild.focus();\n\n          if (updateScroll) that.$menuInner[0].scrollTop = offset;\n\n          $this.trigger('focus');\n        }\n      }\n\n      // Select focused option if \"Enter\", \"Spacebar\" or \"Tab\" (when selectOnTab is true) are pressed inside the menu.\n      if (\n        isActive &&\n        (\n          (e.which === keyCodes.SPACE && !that.selectpicker.keydown.keyHistory) ||\n          e.which === keyCodes.ENTER ||\n          (e.which === keyCodes.TAB && that.options.selectOnTab)\n        )\n      ) {\n        if (e.which !== keyCodes.SPACE) e.preventDefault();\n\n        if (!that.options.liveSearch || e.which !== keyCodes.SPACE) {\n          that.$menuInner.find('.active a').trigger('click', true); // retain active class\n          $this.trigger('focus');\n\n          if (!that.options.liveSearch) {\n            // Prevent screen from scrolling if the user hits the spacebar\n            e.preventDefault();\n            // Fixes spacebar selection of dropdown items in FF & IE\n            $(document).data('spaceSelect', true);\n          }\n        }\n      }\n    },\n\n    mobile: function () {\n      // ensure mobile is set to true if mobile function is called after init\n      this.options.mobile = true;\n      this.$element[0].classList.add('mobile-device');\n    },\n\n    refresh: function () {\n      var that = this;\n      // update options if data attributes have been changed\n      var config = $.extend({}, this.options, getAttributesObject(this.$element), this.$element.data()); // in this order on refresh, as user may change attributes on select, and options object is not passed on refresh\n      this.options = config;\n\n      if (this.options.source.data) {\n        this.render();\n        this.buildList();\n      } else {\n        this.fetchData(function () {\n          that.render();\n          that.buildList();\n        });\n      }\n\n      this.checkDisabled();\n      this.setStyle();\n      this.setWidth();\n\n      this.setSize(true);\n\n      this.$element.trigger('refreshed' + EVENT_KEY);\n    },\n\n    hide: function () {\n      this.$newElement.hide();\n    },\n\n    show: function () {\n      this.$newElement.show();\n    },\n\n    remove: function () {\n      this.$newElement.remove();\n      this.$element.remove();\n    },\n\n    destroy: function () {\n      this.$newElement.before(this.$element).remove();\n\n      if (this.$bsContainer) {\n        this.$bsContainer.remove();\n      } else {\n        this.$menu.remove();\n      }\n\n      if (this.selectpicker.view.titleOption && this.selectpicker.view.titleOption.parentNode) {\n        this.selectpicker.view.titleOption.parentNode.removeChild(this.selectpicker.view.titleOption);\n      }\n\n      this.$element\n        .off(EVENT_KEY)\n        .removeData('selectpicker')\n        .removeClass('bs-select-hidden selectpicker mobile-device');\n\n      $(window).off(EVENT_KEY + '.' + this.selectId);\n    }\n  };\n\n  // SELECTPICKER PLUGIN DEFINITION\n  // ==============================\n  function Plugin (option) {\n    // get the args of the outer function..\n    var args = arguments;\n    // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them\n    // to get lost/corrupted in android 2.3 and IE9 #715 #775\n    var _option = option;\n\n    [].shift.apply(args);\n\n    // if the version was not set successfully\n    if (!version.success) {\n      // try to retreive it again\n      try {\n        version.full = (getVersion() || '').split(' ')[0].split('.');\n      } catch (err) {\n        // fall back to use BootstrapVersion if set\n        if (Selectpicker.BootstrapVersion) {\n          version.full = Selectpicker.BootstrapVersion.split(' ')[0].split('.');\n        } else {\n          version.full = [version.major, '0', '0'];\n\n          console.warn(\n            'There was an issue retrieving Bootstrap\\'s version. ' +\n            'Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. ' +\n            'If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.',\n            err\n          );\n        }\n      }\n\n      version.major = version.full[0];\n      version.success = true;\n    }\n\n    if (version.major >= '4') {\n      // some defaults need to be changed if using Bootstrap 4\n      // check to see if they have already been manually changed before forcing them to update\n      var toUpdate = [];\n\n      if (Selectpicker.DEFAULTS.style === classNames.BUTTONCLASS) toUpdate.push({ name: 'style', className: 'BUTTONCLASS' });\n      if (Selectpicker.DEFAULTS.iconBase === classNames.ICONBASE) toUpdate.push({ name: 'iconBase', className: 'ICONBASE' });\n      if (Selectpicker.DEFAULTS.tickIcon === classNames.TICKICON) toUpdate.push({ name: 'tickIcon', className: 'TICKICON' });\n\n      classNames.DIVIDER = 'dropdown-divider';\n      classNames.SHOW = 'show';\n      classNames.BUTTONCLASS = 'btn-light';\n      classNames.POPOVERHEADER = 'popover-header';\n      classNames.ICONBASE = '';\n      classNames.TICKICON = 'bs-ok-default';\n\n      for (var i = 0; i < toUpdate.length; i++) {\n        var option = toUpdate[i];\n        Selectpicker.DEFAULTS[option.name] = classNames[option.className];\n      }\n    }\n\n    if (version.major > '4') {\n      Selector.DATA_TOGGLE = 'data-bs-toggle=\"dropdown\"';\n    }\n\n    var value;\n    var chain = this.each(function () {\n      var $this = $(this);\n      if ($this.is('select')) {\n        var data = $this.data('selectpicker'),\n            options = typeof _option == 'object' && _option;\n\n        // for backwards compatibility\n        // (using title as placeholder is deprecated - remove in v2.0.0)\n        if (options.title) options.placeholder = options.title;\n\n        if (!data) {\n          var dataAttributes = $this.data();\n\n          for (var dataAttr in dataAttributes) {\n            if (Object.prototype.hasOwnProperty.call(dataAttributes, dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {\n              delete dataAttributes[dataAttr];\n            }\n          }\n\n          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, getAttributesObject($this), dataAttributes, options); // this is correct order on initial render\n          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), dataAttributes.template, options.template);\n          config.source = $.extend({}, Selectpicker.DEFAULTS.source, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.source : {}), options.source);\n          $this.data('selectpicker', (data = new Selectpicker(this, config)));\n        } else if (options) {\n          for (var i in options) {\n            if (Object.prototype.hasOwnProperty.call(options, i)) {\n              data.options[i] = options[i];\n            }\n          }\n        }\n\n        if (typeof _option == 'string') {\n          if (data[_option] instanceof Function) {\n            value = data[_option].apply(data, args);\n          } else {\n            value = data.options[_option];\n          }\n        }\n      }\n    });\n\n    if (typeof value !== 'undefined') {\n      // noinspection JSUnusedAssignment\n      return value;\n    } else {\n      return chain;\n    }\n  }\n\n  var old = $.fn.selectpicker;\n  $.fn.selectpicker = Plugin;\n  $.fn.selectpicker.Constructor = Selectpicker;\n\n  // SELECTPICKER NO CONFLICT\n  // ========================\n  $.fn.selectpicker.noConflict = function () {\n    $.fn.selectpicker = old;\n    return this;\n  };\n\n  // get Bootstrap's keydown event handler for either Bootstrap 4 or Bootstrap 3\n  function keydownHandler () {\n    if (version.major < 5) {\n      if ($.fn.dropdown) {\n        // wait to define until function is called in case Bootstrap isn't loaded yet\n        var bootstrapKeydown = $.fn.dropdown.Constructor._dataApiKeydownHandler || $.fn.dropdown.Constructor.prototype.keydown;\n        return bootstrapKeydown.apply(this, arguments);\n      }\n    } else {\n      return Dropdown.dataApiKeydownHandler;\n    }\n  }\n\n  $(document)\n    .off('keydown.bs.dropdown.data-api')\n    .on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > [' + Selector.DATA_TOGGLE + ']', keydownHandler)\n    .on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > .dropdown-menu', keydownHandler)\n    .on('keydown' + EVENT_KEY, '.bootstrap-select [' + Selector.DATA_TOGGLE + '], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', Selectpicker.prototype.keydown)\n    .on('focusin.modal', '.bootstrap-select [' + Selector.DATA_TOGGLE + '], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', function (e) {\n      e.stopPropagation();\n    });\n\n  // SELECTPICKER DATA-API\n  // =====================\n  document.addEventListener('DOMContentLoaded', function () {\n    $('.selectpicker').each(function () {\n      var $selectpicker = $(this);\n      Plugin.call($selectpicker, $selectpicker.data());\n    });\n  });\n})(jQuery);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXNlbGVjdC9qcy9ib290c3RyYXAtc2VsZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJOztBQUV2SSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlELFNBQVM7QUFDMUQ7O0FBRUEsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQsVUFBVTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRkFBb0YsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBLG9DQUFvQyxHQUFHLG1CQUFtQixHQUFHO0FBQzdELEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDLEdBQUcsOEJBQThCLEdBQUc7QUFDN0UsaURBQWlELEdBQUcsb0NBQW9DLEdBQUc7QUFDM0Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4SEFBOEg7QUFDOUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDJDQUEyQztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBNEM7QUFDNUMsdURBQXVEOztBQUV2RCx3QkFBd0IsZ0JBQWdCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0VBQWtFLHdCQUF3QjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkVBQTJFOztBQUUzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7O0FBRUEsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdEQUF3RCxTQUFTO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsZ0NBQWdDO0FBQ3pGLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxFQUFFLHVDQUF1QyxFQUFFO0FBQ2hGLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCO0FBQ3pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLCtCQUErQjtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLG1EQUFtRDtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSwwREFBMEQsRUFBRTtBQUM1RCw2REFBNkQsRUFBRTtBQUMvRDtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRCxvREFBb0QsSUFBSTtBQUN4RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLHdDQUF3QztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3REFBd0QsY0FBYztBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtREFBbUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLDRCQUE0QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwrRUFBK0U7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdGQUFnRixTQUFTO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUF5RDtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQXlEO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUZBQWlGOztBQUVqRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJFQUEyRTtBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0ZBQWtGLHlDQUF5QztBQUMzSCxrRkFBa0YseUNBQXlDO0FBQzNILGtGQUFrRix5Q0FBeUM7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MseURBQXlELHdEQUF3RDtBQUNuSix1Q0FBdUMsd0dBQXdHO0FBQy9JLHFDQUFxQyxvR0FBb0c7QUFDekk7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NYXRlcmlvLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC1zZWxlY3QvanMvYm9vdHN0cmFwLXNlbGVjdC5qcz83NWI3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIERJU0FMTE9XRURfQVRUUklCVVRFUyA9IFsnc2FuaXRpemUnLCAnd2hpdGVMaXN0JywgJ3Nhbml0aXplRm4nXTtcblxuICB2YXIgdXJpQXR0cnMgPSBbXG4gICAgJ2JhY2tncm91bmQnLFxuICAgICdjaXRlJyxcbiAgICAnaHJlZicsXG4gICAgJ2l0ZW10eXBlJyxcbiAgICAnbG9uZ2Rlc2MnLFxuICAgICdwb3N0ZXInLFxuICAgICdzcmMnLFxuICAgICd4bGluazpocmVmJ1xuICBdO1xuXG4gIHZhciBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXHctXSokL2k7XG5cbiAgdmFyIERlZmF1bHRXaGl0ZWxpc3QgPSB7XG4gICAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsICd0YWJpbmRleCcsICdzdHlsZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxuICAgIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXG4gICAgYXJlYTogW10sXG4gICAgYjogW10sXG4gICAgYnI6IFtdLFxuICAgIGNvbDogW10sXG4gICAgY29kZTogW10sXG4gICAgZGl2OiBbXSxcbiAgICBlbTogW10sXG4gICAgaHI6IFtdLFxuICAgIGgxOiBbXSxcbiAgICBoMjogW10sXG4gICAgaDM6IFtdLFxuICAgIGg0OiBbXSxcbiAgICBoNTogW10sXG4gICAgaDY6IFtdLFxuICAgIGk6IFtdLFxuICAgIGltZzogWydzcmMnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuICAgIGxpOiBbXSxcbiAgICBvbDogW10sXG4gICAgcDogW10sXG4gICAgcHJlOiBbXSxcbiAgICBzOiBbXSxcbiAgICBzbWFsbDogW10sXG4gICAgc3BhbjogW10sXG4gICAgc3ViOiBbXSxcbiAgICBzdXA6IFtdLFxuICAgIHN0cm9uZzogW10sXG4gICAgdTogW10sXG4gICAgdWw6IFtdXG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cbiAgICpcbiAgICogU2hvdXRvdXQgdG8gQW5ndWxhciA3IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83LjIuNC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICAgKi9cbiAgdmFyIFNBRkVfVVJMX1BBVFRFUk4gPSAvXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlKTp8W14mOi8/I10qKD86Wy8/I118JCkpL2dpO1xuXG4gIC8qKlxuICAgKiBBIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHNhZmUgZGF0YSBVUkxzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpbyB0eXBlcy5cbiAgICpcbiAgICogU2hvdXRvdXQgdG8gQW5ndWxhciA3IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83LjIuNC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICAgKi9cbiAgdmFyIERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbYS16MC05Ky9dKz0qJC9pO1xuXG4gIHZhciBQYXJzZWFibGVBdHRyaWJ1dGVzID0gWyd0aXRsZScsICdwbGFjZWhvbGRlciddOyAvLyBhdHRyaWJ1dGVzIHRvIHVzZSBhcyBzZXR0aW5ncywgY2FuIGFkZCBvdGhlcnMgaW4gdGhlIGZ1dHVyZVxuXG4gIGZ1bmN0aW9uIGFsbG93ZWRBdHRyaWJ1dGUgKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSB7XG4gICAgdmFyIGF0dHJOYW1lID0gYXR0ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKCQuaW5BcnJheShhdHRyTmFtZSwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpICE9PSAtMSkge1xuICAgICAgaWYgKCQuaW5BcnJheShhdHRyTmFtZSwgdXJpQXR0cnMpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihhdHRyLm5vZGVWYWx1ZS5tYXRjaChTQUZFX1VSTF9QQVRURVJOKSB8fCBhdHRyLm5vZGVWYWx1ZS5tYXRjaChEQVRBX1VSTF9QQVRURVJOKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciByZWdFeHAgPSAkKGFsbG93ZWRBdHRyaWJ1dGVMaXN0KS5maWx0ZXIoZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgaWYgYSByZWd1bGFyIGV4cHJlc3Npb24gdmFsaWRhdGVzIHRoZSBhdHRyaWJ1dGUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZWdFeHAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXR0ck5hbWUubWF0Y2gocmVnRXhwW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzYW5pdGl6ZUh0bWwgKHVuc2FmZUVsZW1lbnRzLCB3aGl0ZUxpc3QsIHNhbml0aXplRm4pIHtcbiAgICBpZiAoc2FuaXRpemVGbiAmJiB0eXBlb2Ygc2FuaXRpemVGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHNhbml0aXplRm4odW5zYWZlRWxlbWVudHMpO1xuICAgIH1cblxuICAgIHZhciB3aGl0ZWxpc3RLZXlzID0gT2JqZWN0LmtleXMod2hpdGVMaXN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB1bnNhZmVFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGVsZW1lbnRzID0gdW5zYWZlRWxlbWVudHNbaV0ucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IGVsZW1lbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICB2YXIgZWwgPSBlbGVtZW50c1tqXTtcbiAgICAgICAgdmFyIGVsTmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKHdoaXRlbGlzdEtleXMuaW5kZXhPZihlbE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmlidXRlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZWwuYXR0cmlidXRlcyk7XG4gICAgICAgIHZhciB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQod2hpdGVMaXN0WycqJ10gfHwgW10sIHdoaXRlTGlzdFtlbE5hbWVdIHx8IFtdKTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMCwgbGVuMyA9IGF0dHJpYnV0ZUxpc3QubGVuZ3RoOyBrIDwgbGVuMzsgaysrKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVMaXN0W2tdO1xuXG4gICAgICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHIsIHdoaXRlbGlzdGVkQXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzT2JqZWN0ICgkc2VsZWN0KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXNPYmplY3QgPSB7fSxcbiAgICAgICAgYXR0clZhbDtcblxuICAgIFBhcnNlYWJsZUF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgYXR0clZhbCA9ICRzZWxlY3QuYXR0cihpdGVtKTtcbiAgICAgIGlmIChhdHRyVmFsKSBhdHRyaWJ1dGVzT2JqZWN0W2l0ZW1dID0gYXR0clZhbDtcbiAgICB9KTtcblxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIC8vICh1c2luZyB0aXRsZSBhcyBwbGFjZWhvbGRlciBpcyBkZXByZWNhdGVkIC0gcmVtb3ZlIGluIHYyLjAuMClcbiAgICBpZiAoIWF0dHJpYnV0ZXNPYmplY3QucGxhY2Vob2xkZXIgJiYgYXR0cmlidXRlc09iamVjdC50aXRsZSkge1xuICAgICAgYXR0cmlidXRlc09iamVjdC5wbGFjZWhvbGRlciA9IGF0dHJpYnV0ZXNPYmplY3QudGl0bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNPYmplY3Q7XG4gIH1cblxuICAvLyBQb2x5ZmlsbCBmb3IgYnJvd3NlcnMgd2l0aCBubyBjbGFzc0xpc3Qgc3VwcG9ydFxuICAvLyBSZW1vdmUgaW4gdjJcbiAgaWYgKCEoJ2NsYXNzTGlzdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnXycpKSkge1xuICAgIChmdW5jdGlvbiAodmlldykge1xuICAgICAgaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XG5cbiAgICAgIHZhciBjbGFzc0xpc3RQcm9wID0gJ2NsYXNzTGlzdCcsXG4gICAgICAgICAgcHJvdG9Qcm9wID0gJ3Byb3RvdHlwZScsXG4gICAgICAgICAgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF0sXG4gICAgICAgICAgb2JqQ3RyID0gT2JqZWN0LFxuICAgICAgICAgIGNsYXNzTGlzdEdldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRlbGVtLmFkZENsYXNzKGNsYXNzZXMpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkZWxlbS5yZW1vdmVDbGFzcyhjbGFzc2VzKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiAoY2xhc3NlcywgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGVsZW0udG9nZ2xlQ2xhc3MoY2xhc3NlcywgZm9yY2UpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjb250YWluczogZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGVsZW0uaGFzQ2xhc3MoY2xhc3Nlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKG9iakN0ci5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XG4gICAgICAgICAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXIsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7IC8vIElFIDggZG9lc24ndCBzdXBwb3J0IGVudW1lcmFibGU6dHJ1ZVxuICAgICAgICAgIC8vIGFkZGluZyB1bmRlZmluZWQgdG8gZmlnaHQgdGhpcyBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9jbGFzc0xpc3QuanMvaXNzdWVzLzM2XG4gICAgICAgICAgLy8gbW9kZXJuaWUgSUU4LU1TVzcgbWFjaGluZSBoYXMgSUU4IDguMC42MDAxLjE4NzAyIGFuZCBpcyBhZmZlY3RlZFxuICAgICAgICAgIGlmIChleC5udW1iZXIgPT09IHVuZGVmaW5lZCB8fCBleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XG4gICAgICAgICAgICBjbGFzc0xpc3RQcm9wRGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9iakN0cltwcm90b1Byb3BdLl9fZGVmaW5lR2V0dGVyX18pIHtcbiAgICAgICAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcbiAgICAgIH1cbiAgICB9KHdpbmRvdykpO1xuICB9XG5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnXycpO1xuXG4gIHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2MxJywgJ2MyJyk7XG5cbiAgaWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2MyJykpIHtcbiAgICB2YXIgX2FkZCA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUuYWRkLFxuICAgICAgICBfcmVtb3ZlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5yZW1vdmU7XG5cbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBfYWRkLmJpbmQodGhpcykpO1xuICAgIH07XG5cbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBfcmVtb3ZlLmJpbmQodGhpcykpO1xuICAgIH07XG4gIH1cblxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdjMycsIGZhbHNlKTtcblxuICAvLyBQb2x5ZmlsbCBmb3IgSUUgMTAgYW5kIEZpcmVmb3ggPDI0LCB3aGVyZSBjbGFzc0xpc3QudG9nZ2xlIGRvZXMgbm90XG4gIC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgaWYgKHRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnYzMnKSkge1xuICAgIHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XG5cbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcbiAgICAgIGlmICgxIGluIGFyZ3VtZW50cyAmJiAhdGhpcy5jb250YWlucyh0b2tlbikgPT09ICFmb3JjZSkge1xuICAgICAgICByZXR1cm4gZm9yY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3RvZ2dsZS5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdGVzdEVsZW1lbnQgPSBudWxsO1xuXG4gIC8vIFBvbHlmaWxsIGZvciBJRSAocmVtb3ZlIGluIHYyKVxuICBPYmplY3QudmFsdWVzID0gdHlwZW9mIE9iamVjdC52YWx1ZXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QudmFsdWVzIDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gc2hhbGxvdyBhcnJheSBjb21wYXJpc29uXG4gIGZ1bmN0aW9uIGlzRXF1YWwgKGFycmF5MSwgYXJyYXkyKSB7XG4gICAgcmV0dXJuIGFycmF5MS5sZW5ndGggPT09IGFycmF5Mi5sZW5ndGggJiYgYXJyYXkxLmV2ZXJ5KGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IGFycmF5MltpbmRleF07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gPGVkaXRvci1mb2xkIGRlc2M9XCJTaGltc1wiPlxuICBpZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAndXNlIHN0cmljdCc7IC8vIG5lZWRlZCB0byBzdXBwb3J0IGBhcHBseWAvYGNhbGxgIHdpdGggYHVuZGVmaW5lZGAvYG51bGxgXG4gICAgICB2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbiAgICAgIHZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICAgIGlmIChzZWFyY2ggJiYgdG9TdHJpbmcuY2FsbChzZWFyY2gpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICB2YXIgc2VhcmNoU3RyaW5nID0gU3RyaW5nKHNlYXJjaCk7XG4gICAgICAgIHZhciBzZWFyY2hMZW5ndGggPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gYFRvSW50ZWdlcmBcbiAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XG4gICAgICAgIGlmIChwb3MgIT0gcG9zKSB7IC8vIGJldHRlciBgaXNOYU5gXG4gICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihNYXRoLm1heChwb3MsIDApLCBzdHJpbmdMZW5ndGgpO1xuICAgICAgICAvLyBBdm9pZCB0aGUgYGluZGV4T2ZgIGNhbGwgaWYgbm8gbWF0Y2ggaXMgcG9zc2libGVcbiAgICAgICAgaWYgKHNlYXJjaExlbmd0aCArIHN0YXJ0ID4gc3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHNlYXJjaExlbmd0aCkge1xuICAgICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChzdGFydCArIGluZGV4KSAhPSBzZWFyY2hTdHJpbmcuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgJ3N0YXJ0c1dpdGgnLCB7XG4gICAgICAgICAgJ3ZhbHVlJzogc3RhcnRzV2l0aCxcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICAgIH1cbiAgICB9KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9LZWJhYkNhc2UgKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW0EtWl0rKD8hW2Etel0pfFtBLVpdL2csIGZ1bmN0aW9uICgkLCBvZnMpIHtcbiAgICAgIHJldHVybiAob2ZzID8gJy0nIDogJycpICsgJC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25zICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlLmRhdGEgfHwgdGhpcy5vcHRpb25zLnNvdXJjZS5zZWFyY2gpIHtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMuc2VsZWN0cGlja2VyLm9wdGlvblZhbHVlc0RhdGFNYXApO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3RlZE9wdGlvbnMgPSBvcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlRGlzYWJsZWQgJiYgaXRlbS5kaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gZW5zdXJlIG9ubHkgMSBvcHRpb24gaXMgc2VsZWN0ZWQgaWYgbXVsdGlwbGUgYXJlIHNldCBpbiB0aGUgZGF0YSBzb3VyY2VcbiAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZS5kYXRhICYmICF0aGlzLm11bHRpcGxlICYmIHNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgc2VsZWN0ZWRPcHRpb25zW2ldLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdGVkT3B0aW9ucyA9IFsgc2VsZWN0ZWRPcHRpb25zW3NlbGVjdGVkT3B0aW9ucy5sZW5ndGggLSAxXSBdO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RlZE9wdGlvbnM7XG4gIH1cblxuICAvLyBtdWNoIGZhc3RlciB0aGFuICQudmFsKClcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0VmFsdWVzIChzZWxlY3RlZE9wdGlvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSBbXSxcbiAgICAgICAgb3B0aW9ucyA9IHNlbGVjdGVkT3B0aW9ucyB8fCBnZXRTZWxlY3RlZE9wdGlvbnMuY2FsbCh0aGlzKSxcbiAgICAgICAgb3B0O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9wdCA9IG9wdGlvbnNbaV07XG5cbiAgICAgIGlmICghb3B0LmRpc2FibGVkKSB7XG4gICAgICAgIHZhbHVlLnB1c2gob3B0LnZhbHVlID09PSB1bmRlZmluZWQgPyBvcHQudGV4dCA6IG9wdC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XG4gICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aCA/IG51bGwgOiB2YWx1ZVswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBzZXQgZGF0YS1zZWxlY3RlZCBvbiBzZWxlY3QgZWxlbWVudCBpZiB0aGUgdmFsdWUgaGFzIGJlZW4gcHJvZ3JhbW1hdGljYWxseSBzZWxlY3RlZFxuICAvLyBwcmlvciB0byBpbml0aWFsaXphdGlvbiBvZiBib290c3RyYXAtc2VsZWN0XG4gIC8vICogY29uc2lkZXIgcmVtb3Zpbmcgb3IgcmVwbGFjaW5nIGFuIGFsdGVybmF0aXZlIG1ldGhvZCAqXG4gIHZhciB2YWxIb29rcyA9IHtcbiAgICB1c2VEZWZhdWx0OiBmYWxzZSxcbiAgICBfc2V0OiAkLnZhbEhvb2tzLnNlbGVjdC5zZXRcbiAgfTtcblxuICAkLnZhbEhvb2tzLnNlbGVjdC5zZXQgPSBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgIXZhbEhvb2tzLnVzZURlZmF1bHQpICQoZWxlbSkuZGF0YSgnc2VsZWN0ZWQnLCB0cnVlKTtcblxuICAgIHJldHVybiB2YWxIb29rcy5fc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIGNoYW5nZWRBcmd1bWVudHMgPSBudWxsO1xuXG4gIHZhciBFdmVudElzU3VwcG9ydGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEV2ZW50KCdjaGFuZ2UnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgJC5mbi50cmlnZ2VyTmF0aXZlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIHZhciBlbCA9IHRoaXNbMF0sXG4gICAgICAgIGV2ZW50O1xuXG4gICAgaWYgKGVsLmRpc3BhdGNoRXZlbnQpIHsgLy8gZm9yIG1vZGVybiBicm93c2VycyAmIElFOStcbiAgICAgIGlmIChFdmVudElzU3VwcG9ydGVkKSB7XG4gICAgICAgIC8vIEZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBJRSBzaW5jZSBpdCBkb2Vzbid0IHN1cHBvcnQgRXZlbnQgY29uc3RydWN0b3JcbiAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH07XG4gIC8vIDwvZWRpdG9yLWZvbGQ+XG5cbiAgZnVuY3Rpb24gc3RyaW5nU2VhcmNoIChsaSwgc2VhcmNoU3RyaW5nLCBtZXRob2QsIG5vcm1hbGl6ZSkge1xuICAgIHZhciBzdHJpbmdUeXBlcyA9IFtcbiAgICAgICAgICAnZGlzcGxheScsXG4gICAgICAgICAgJ3N1YnRleHQnLFxuICAgICAgICAgICd0b2tlbnMnXG4gICAgICAgIF0sXG4gICAgICAgIHNlYXJjaFN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdHJpbmdUeXBlID0gc3RyaW5nVHlwZXNbaV0sXG4gICAgICAgICAgc3RyaW5nID0gbGlbc3RyaW5nVHlwZV07XG5cbiAgICAgIGlmIChzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgLy8gU3RyaXAgSFRNTCB0YWdzLiBUaGlzIGlzbid0IHBlcmZlY3QsIGJ1dCBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gYW55IG90aGVyIG1ldGhvZFxuICAgICAgICBpZiAoc3RyaW5nVHlwZSA9PT0gJ2Rpc3BsYXknKSB7XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLzxbXj5dKz4vZywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZSkgc3RyaW5nID0gbm9ybWFsaXplVG9CYXNlKHN0cmluZyk7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2VhcmNoU3VjY2VzcyA9IG1ldGhvZChzdHJpbmcsIHNlYXJjaFN0cmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSAnY29udGFpbnMnKSB7XG4gICAgICAgICAgc2VhcmNoU3VjY2VzcyA9IHN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZykgPj0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWFyY2hTdWNjZXNzID0gc3RyaW5nLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWFyY2hTdWNjZXNzKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VhcmNoU3VjY2VzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSW50ZWdlciAodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKSB8fCAwO1xuICB9XG5cbiAgLy8gQm9ycm93ZWQgZnJvbSBMb2Rhc2ggKF8uZGVidXJyKVxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvTWFya3NFeHRlbmRlZFJhbmdlID0gJ1xcXFx1MWFiMC1cXFxcdTFhZmYnLFxuICAgICAgcnNDb21ib01hcmtzU3VwcGxlbWVudFJhbmdlID0gJ1xcXFx1MWRjMC1cXFxcdTFkZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgcnNDb21ib01hcmtzRXh0ZW5kZWRSYW5nZSArIHJzQ29tYm9NYXJrc1N1cHBsZW1lbnRSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuICBmdW5jdGlvbiBkZWJ1cnJMZXR0ZXIgKGtleSkge1xuICAgIHJldHVybiBkZWJ1cnJlZExldHRlcnNba2V5XTtcbiAgfTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVUb0Jhc2UgKHN0cmluZykge1xuICAgIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygpO1xuICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gIH1cblxuICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkLlxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIE9iamVjdC5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuXG4gIHZhciBodG1sRXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIga2V5Q29kZU1hcCA9IHtcbiAgICAzMjogJyAnLFxuICAgIDQ4OiAnMCcsXG4gICAgNDk6ICcxJyxcbiAgICA1MDogJzInLFxuICAgIDUxOiAnMycsXG4gICAgNTI6ICc0JyxcbiAgICA1MzogJzUnLFxuICAgIDU0OiAnNicsXG4gICAgNTU6ICc3JyxcbiAgICA1NjogJzgnLFxuICAgIDU3OiAnOScsXG4gICAgNTk6ICc7JyxcbiAgICA2NTogJ0EnLFxuICAgIDY2OiAnQicsXG4gICAgNjc6ICdDJyxcbiAgICA2ODogJ0QnLFxuICAgIDY5OiAnRScsXG4gICAgNzA6ICdGJyxcbiAgICA3MTogJ0cnLFxuICAgIDcyOiAnSCcsXG4gICAgNzM6ICdJJyxcbiAgICA3NDogJ0onLFxuICAgIDc1OiAnSycsXG4gICAgNzY6ICdMJyxcbiAgICA3NzogJ00nLFxuICAgIDc4OiAnTicsXG4gICAgNzk6ICdPJyxcbiAgICA4MDogJ1AnLFxuICAgIDgxOiAnUScsXG4gICAgODI6ICdSJyxcbiAgICA4MzogJ1MnLFxuICAgIDg0OiAnVCcsXG4gICAgODU6ICdVJyxcbiAgICA4NjogJ1YnLFxuICAgIDg3OiAnVycsXG4gICAgODg6ICdYJyxcbiAgICA4OTogJ1knLFxuICAgIDkwOiAnWicsXG4gICAgOTY6ICcwJyxcbiAgICA5NzogJzEnLFxuICAgIDk4OiAnMicsXG4gICAgOTk6ICczJyxcbiAgICAxMDA6ICc0JyxcbiAgICAxMDE6ICc1JyxcbiAgICAxMDI6ICc2JyxcbiAgICAxMDM6ICc3JyxcbiAgICAxMDQ6ICc4JyxcbiAgICAxMDU6ICc5J1xuICB9O1xuXG4gIHZhciBrZXlDb2RlcyA9IHtcbiAgICBFU0NBUEU6IDI3LCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFc2NhcGUgKEVzYykga2V5XG4gICAgRU5URVI6IDEzLCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFbnRlciBrZXlcbiAgICBTUEFDRTogMzIsIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHNwYWNlIGtleVxuICAgIFRBQjogOSwgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdGFiIGtleVxuICAgIEFSUk9XX1VQOiAzOCwgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdXAgYXJyb3cga2V5XG4gICAgQVJST1dfRE9XTjogNDAgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgZG93biBhcnJvdyBrZXlcbiAgfTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIERyb3Bkb3duID0gd2luZG93LkRyb3Bkb3duIHx8IGJvb3RzdHJhcC5Ecm9wZG93bjtcblxuICBmdW5jdGlvbiBnZXRWZXJzaW9uICgpIHtcbiAgICB2YXIgdmVyc2lvbjtcblxuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9uID0gJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3Rvci5WRVJTSU9OO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdmVyc2lvbiA9IERyb3Bkb3duLlZFUlNJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBtYWpvcjogJzMnXG4gIH07XG5cbiAgdHJ5IHtcbiAgICB2ZXJzaW9uLmZ1bGwgPSAoZ2V0VmVyc2lvbigpIHx8ICcnKS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJyk7XG4gICAgdmVyc2lvbi5tYWpvciA9IHZlcnNpb24uZnVsbFswXTtcbiAgICB2ZXJzaW9uLnN1Y2Nlc3MgPSB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICB2YXIgc2VsZWN0SWQgPSAwO1xuXG4gIHZhciBFVkVOVF9LRVkgPSAnLmJzLnNlbGVjdCc7XG5cbiAgdmFyIGNsYXNzTmFtZXMgPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgRElWSURFUjogJ2RpdmlkZXInLFxuICAgIFNIT1c6ICdvcGVuJyxcbiAgICBEUk9QVVA6ICdkcm9wdXAnLFxuICAgIE1FTlU6ICdkcm9wZG93bi1tZW51JyxcbiAgICBNRU5VUklHSFQ6ICdkcm9wZG93bi1tZW51LXJpZ2h0JyxcbiAgICBNRU5VTEVGVDogJ2Ryb3Bkb3duLW1lbnUtbGVmdCcsXG4gICAgLy8gdG8tZG86IHJlcGxhY2Ugd2l0aCBtb3JlIGFkdmFuY2VkIHRlbXBsYXRlL2N1c3RvbWl6YXRpb24gb3B0aW9uc1xuICAgIEJVVFRPTkNMQVNTOiAnYnRuLWRlZmF1bHQnLFxuICAgIFBPUE9WRVJIRUFERVI6ICdwb3BvdmVyLXRpdGxlJyxcbiAgICBJQ09OQkFTRTogJ2dseXBoaWNvbicsXG4gICAgVElDS0lDT046ICdnbHlwaGljb24tb2snXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIE1FTlU6ICcuJyArIGNsYXNzTmFtZXMuTUVOVSxcbiAgICBEQVRBX1RPR0dMRTogJ2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIidcbiAgfTtcblxuICB2YXIgZWxlbWVudFRlbXBsYXRlcyA9IHtcbiAgICBkaXY6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHNwYW46IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSxcbiAgICBpOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyksXG4gICAgc3VidGV4dDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc21hbGwnKSxcbiAgICBhOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyksXG4gICAgbGk6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyksXG4gICAgd2hpdGVzcGFjZTogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTAwQTAnKSxcbiAgICBmcmFnbWVudDogZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgIG9wdGlvbjogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJylcbiAgfTtcblxuICBlbGVtZW50VGVtcGxhdGVzLnNlbGVjdGVkT3B0aW9uID0gZWxlbWVudFRlbXBsYXRlcy5vcHRpb24uY2xvbmVOb2RlKGZhbHNlKTtcbiAgZWxlbWVudFRlbXBsYXRlcy5zZWxlY3RlZE9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgdHJ1ZSk7XG5cbiAgZWxlbWVudFRlbXBsYXRlcy5ub1Jlc3VsdHMgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSk7XG4gIGVsZW1lbnRUZW1wbGF0ZXMubm9SZXN1bHRzLmNsYXNzTmFtZSA9ICduby1yZXN1bHRzJztcblxuICBlbGVtZW50VGVtcGxhdGVzLmEuc2V0QXR0cmlidXRlKCdyb2xlJywgJ29wdGlvbicpO1xuICBlbGVtZW50VGVtcGxhdGVzLmEuY2xhc3NOYW1lID0gJ2Ryb3Bkb3duLWl0ZW0nO1xuXG4gIGVsZW1lbnRUZW1wbGF0ZXMuc3VidGV4dC5jbGFzc05hbWUgPSAndGV4dC1tdXRlZCc7XG5cbiAgZWxlbWVudFRlbXBsYXRlcy50ZXh0ID0gZWxlbWVudFRlbXBsYXRlcy5zcGFuLmNsb25lTm9kZShmYWxzZSk7XG4gIGVsZW1lbnRUZW1wbGF0ZXMudGV4dC5jbGFzc05hbWUgPSAndGV4dCc7XG5cbiAgZWxlbWVudFRlbXBsYXRlcy5jaGVja01hcmsgPSBlbGVtZW50VGVtcGxhdGVzLnNwYW4uY2xvbmVOb2RlKGZhbHNlKTtcblxuICB2YXIgUkVHRVhQX0FSUk9XID0gbmV3IFJlZ0V4cChrZXlDb2Rlcy5BUlJPV19VUCArICd8JyArIGtleUNvZGVzLkFSUk9XX0RPV04pO1xuICB2YXIgUkVHRVhQX1RBQl9PUl9FU0NBUEUgPSBuZXcgUmVnRXhwKCdeJyArIGtleUNvZGVzLlRBQiArICckfCcgKyBrZXlDb2Rlcy5FU0NBUEUpO1xuXG4gIHZhciBnZW5lcmF0ZU9wdGlvbiA9IHtcbiAgICBsaTogZnVuY3Rpb24gKGNvbnRlbnQsIGNsYXNzZXMsIG9wdGdyb3VwKSB7XG4gICAgICB2YXIgbGkgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSk7XG5cbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50Lm5vZGVUeXBlID09PSAxIHx8IGNvbnRlbnQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgbGkuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGkuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNsYXNzZXMgIT09ICd1bmRlZmluZWQnICYmIGNsYXNzZXMgIT09ICcnKSBsaS5jbGFzc05hbWUgPSBjbGFzc2VzO1xuICAgICAgaWYgKHR5cGVvZiBvcHRncm91cCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0Z3JvdXAgIT09IG51bGwpIGxpLmNsYXNzTGlzdC5hZGQoJ29wdGdyb3VwLScgKyBvcHRncm91cCk7XG5cbiAgICAgIHJldHVybiBsaTtcbiAgICB9LFxuXG4gICAgYTogZnVuY3Rpb24gKHRleHQsIGNsYXNzZXMsIGlubGluZSkge1xuICAgICAgdmFyIGEgPSBlbGVtZW50VGVtcGxhdGVzLmEuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBpZiAodGV4dC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICBhLmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNsYXNzZXMgIT09ICd1bmRlZmluZWQnICYmIGNsYXNzZXMgIT09ICcnKSBhLmNsYXNzTGlzdC5hZGQuYXBwbHkoYS5jbGFzc0xpc3QsIGNsYXNzZXMuc3BsaXQoL1xccysvKSk7XG4gICAgICBpZiAoaW5saW5lKSBhLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBpbmxpbmUpO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgdGV4dDogZnVuY3Rpb24gKG9wdGlvbnMsIHVzZUZyYWdtZW50KSB7XG4gICAgICB2YXIgdGV4dEVsZW1lbnQgPSBlbGVtZW50VGVtcGxhdGVzLnRleHQuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICBzdWJ0ZXh0RWxlbWVudCxcbiAgICAgICAgICBpY29uRWxlbWVudDtcblxuICAgICAgaWYgKG9wdGlvbnMuY29udGVudCkge1xuICAgICAgICB0ZXh0RWxlbWVudC5pbm5lckhUTUwgPSBvcHRpb25zLmNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0RWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbnMudGV4dDtcblxuICAgICAgICBpZiAob3B0aW9ucy5pY29uKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UgPSBlbGVtZW50VGVtcGxhdGVzLndoaXRlc3BhY2UuY2xvbmVOb2RlKGZhbHNlKTtcblxuICAgICAgICAgIC8vIG5lZWQgdG8gdXNlIDxpPiBmb3IgaWNvbnMgaW4gdGhlIGJ1dHRvbiB0byBwcmV2ZW50IGEgYnJlYWtpbmcgY2hhbmdlXG4gICAgICAgICAgLy8gbm90ZTogc3dpdGNoIHRvIHNwYW4gaW4gbmV4dCBtYWpvciByZWxlYXNlXG4gICAgICAgICAgaWNvbkVsZW1lbnQgPSAodXNlRnJhZ21lbnQgPT09IHRydWUgPyBlbGVtZW50VGVtcGxhdGVzLmkgOiBlbGVtZW50VGVtcGxhdGVzLnNwYW4pLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgaWNvbkVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmljb25CYXNlICsgJyAnICsgb3B0aW9ucy5pY29uO1xuXG4gICAgICAgICAgZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5hcHBlbmRDaGlsZChpY29uRWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5hcHBlbmRDaGlsZCh3aGl0ZXNwYWNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnN1YnRleHQpIHtcbiAgICAgICAgICBzdWJ0ZXh0RWxlbWVudCA9IGVsZW1lbnRUZW1wbGF0ZXMuc3VidGV4dC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgIHN1YnRleHRFbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9ucy5zdWJ0ZXh0O1xuICAgICAgICAgIHRleHRFbGVtZW50LmFwcGVuZENoaWxkKHN1YnRleHRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodXNlRnJhZ21lbnQgPT09IHRydWUpIHtcbiAgICAgICAgd2hpbGUgKHRleHRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudDtcbiAgICB9LFxuXG4gICAgbGFiZWw6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgdGV4dEVsZW1lbnQgPSBlbGVtZW50VGVtcGxhdGVzLnRleHQuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICBzdWJ0ZXh0RWxlbWVudCxcbiAgICAgICAgICBpY29uRWxlbWVudDtcblxuICAgICAgdGV4dEVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5kaXNwbGF5O1xuXG4gICAgICBpZiAob3B0aW9ucy5pY29uKSB7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlID0gZWxlbWVudFRlbXBsYXRlcy53aGl0ZXNwYWNlLmNsb25lTm9kZShmYWxzZSk7XG5cbiAgICAgICAgaWNvbkVsZW1lbnQgPSBlbGVtZW50VGVtcGxhdGVzLnNwYW4uY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgaWNvbkVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmljb25CYXNlICsgJyAnICsgb3B0aW9ucy5pY29uO1xuXG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQoaWNvbkVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKHdoaXRlc3BhY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zdWJ0ZXh0KSB7XG4gICAgICAgIHN1YnRleHRFbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy5zdWJ0ZXh0LmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIHN1YnRleHRFbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9ucy5zdWJ0ZXh0O1xuICAgICAgICB0ZXh0RWxlbWVudC5hcHBlbmRDaGlsZChzdWJ0ZXh0RWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldE9wdGlvbkRhdGEgPSB7XG4gICAgZnJvbU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbiwgdHlwZSkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZGl2aWRlcic6XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCdkYXRhLWRpdmlkZXInKSA9PT0gJ3RydWUnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIHZhbHVlID0gb3B0aW9uLnRleHRDb250ZW50O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbi5sYWJlbDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb24uc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb24udGl0bGU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIHRvS2ViYWJDYXNlKHR5cGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZnJvbURhdGFTb3VyY2U6IGZ1bmN0aW9uIChvcHRpb24sIHR5cGUpIHtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb24udGV4dCB8fCBvcHRpb24udmFsdWUgfHwgJyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvblt0eXBlXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBzaG93Tm9SZXN1bHRzIChzZWFyY2hNYXRjaCwgc2VhcmNoVmFsdWUpIHtcbiAgICBpZiAoIXNlYXJjaE1hdGNoLmxlbmd0aCkge1xuICAgICAgZWxlbWVudFRlbXBsYXRlcy5ub1Jlc3VsdHMuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLm5vbmVSZXN1bHRzVGV4dC5yZXBsYWNlKCd7MH0nLCAnXCInICsgaHRtbEVzY2FwZShzZWFyY2hWYWx1ZSkgKyAnXCInKTtcbiAgICAgIHRoaXMuJG1lbnVJbm5lclswXS5maXJzdENoaWxkLmFwcGVuZENoaWxkKGVsZW1lbnRUZW1wbGF0ZXMubm9SZXN1bHRzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJIaWRkZW4gKGl0ZW0pIHtcbiAgICByZXR1cm4gIShpdGVtLmhpZGRlbiB8fCB0aGlzLm9wdGlvbnMuaGlkZURpc2FibGVkICYmIGl0ZW0uZGlzYWJsZWQpO1xuICB9XG5cbiAgdmFyIFNlbGVjdHBpY2tlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgLy8gYm9vdHN0cmFwLXNlbGVjdCBoYXMgYmVlbiBpbml0aWFsaXplZCAtIHJldmVydCB2YWxIb29rcy5zZWxlY3Quc2V0IGJhY2sgdG8gaXRzIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgaWYgKCF2YWxIb29rcy51c2VEZWZhdWx0KSB7XG4gICAgICAkLnZhbEhvb2tzLnNlbGVjdC5zZXQgPSB2YWxIb29rcy5fc2V0O1xuICAgICAgdmFsSG9va3MudXNlRGVmYXVsdCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgdGhpcy4kbmV3RWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy4kYnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiRtZW51ID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2VsZWN0cGlja2VyID0ge1xuICAgICAgbWFpbjoge1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgb3B0aW9uUXVldWU6IGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgaGFzTW9yZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzZWFyY2g6IHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGhhc01vcmU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY3VycmVudDoge30sIC8vIGN1cnJlbnQgaXMgZWl0aGVyIGVxdWFsIHRvIG1haW4gb3Igc2VhcmNoIGRlcGVuZGluZyBvbiBpZiBhIHNlYXJjaCBpcyBpbiBwcm9ncmVzc1xuICAgICAgdmlldzoge30sXG4gICAgICAvLyBtYXAgb2Ygb3B0aW9uIHZhbHVlcyBhbmQgdGhlaXIgcmVzcGVjdGl2ZSBkYXRhIChvbmx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBvcHRpb25zLnNvdXJjZSlcbiAgICAgIG9wdGlvblZhbHVlc0RhdGFNYXA6IHt9LFxuICAgICAgaXNTZWFyY2hpbmc6IGZhbHNlLFxuICAgICAga2V5ZG93bjoge1xuICAgICAgICBrZXlIaXN0b3J5OiAnJyxcbiAgICAgICAgcmVzZXRLZXlIaXN0b3J5OiB7XG4gICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5rZXlIaXN0b3J5ID0gJyc7XG4gICAgICAgICAgICB9LCA4MDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnNpemVJbmZvID0ge307XG5cbiAgICAvLyBGb3JtYXQgd2luZG93IHBhZGRpbmdcbiAgICB2YXIgd2luUGFkID0gdGhpcy5vcHRpb25zLndpbmRvd1BhZGRpbmc7XG4gICAgaWYgKHR5cGVvZiB3aW5QYWQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm9wdGlvbnMud2luZG93UGFkZGluZyA9IFt3aW5QYWQsIHdpblBhZCwgd2luUGFkLCB3aW5QYWRdO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kc1xuICAgIHRoaXMudmFsID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS52YWw7XG4gICAgdGhpcy5yZW5kZXIgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnJlbmRlcjtcbiAgICB0aGlzLnJlZnJlc2ggPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnJlZnJlc2g7XG4gICAgdGhpcy5zZXRTdHlsZSA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUuc2V0U3R5bGU7XG4gICAgdGhpcy5zZWxlY3RBbGwgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnNlbGVjdEFsbDtcbiAgICB0aGlzLmRlc2VsZWN0QWxsID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5kZXNlbGVjdEFsbDtcbiAgICB0aGlzLmRlc3Ryb3kgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLmRlc3Ryb3k7XG4gICAgdGhpcy5yZW1vdmUgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnJlbW92ZTtcbiAgICB0aGlzLnNob3cgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnNob3c7XG4gICAgdGhpcy5oaWRlID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5oaWRlO1xuXG4gICAgdGhpcy5pbml0KCk7XG4gIH07XG5cbiAgU2VsZWN0cGlja2VyLlZFUlNJT04gPSAnMS4xNC4wLWJldGEzJztcblxuICAvLyBwYXJ0IG9mIHRoaXMgaXMgZHVwbGljYXRlZCBpbiBpMThuL2RlZmF1bHRzLWVuX1VTLmpzLiBNYWtlIHN1cmUgdG8gdXBkYXRlIGJvdGguXG4gIFNlbGVjdHBpY2tlci5ERUZBVUxUUyA9IHtcbiAgICBub25lU2VsZWN0ZWRUZXh0OiAnTm90aGluZyBzZWxlY3RlZCcsXG4gICAgbm9uZVJlc3VsdHNUZXh0OiAnTm8gcmVzdWx0cyBtYXRjaGVkIHswfScsXG4gICAgY291bnRTZWxlY3RlZFRleHQ6IGZ1bmN0aW9uIChudW1TZWxlY3RlZCwgbnVtVG90YWwpIHtcbiAgICAgIHJldHVybiAobnVtU2VsZWN0ZWQgPT0gMSkgPyAnezB9IGl0ZW0gc2VsZWN0ZWQnIDogJ3swfSBpdGVtcyBzZWxlY3RlZCc7XG4gICAgfSxcbiAgICBtYXhPcHRpb25zVGV4dDogZnVuY3Rpb24gKG51bUFsbCwgbnVtR3JvdXApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIChudW1BbGwgPT0gMSkgPyAnTGltaXQgcmVhY2hlZCAoe259IGl0ZW0gbWF4KScgOiAnTGltaXQgcmVhY2hlZCAoe259IGl0ZW1zIG1heCknLFxuICAgICAgICAobnVtR3JvdXAgPT0gMSkgPyAnR3JvdXAgbGltaXQgcmVhY2hlZCAoe259IGl0ZW0gbWF4KScgOiAnR3JvdXAgbGltaXQgcmVhY2hlZCAoe259IGl0ZW1zIG1heCknXG4gICAgICBdO1xuICAgIH0sXG4gICAgc2VsZWN0QWxsVGV4dDogJ1NlbGVjdCBBbGwnLFxuICAgIGRlc2VsZWN0QWxsVGV4dDogJ0Rlc2VsZWN0IEFsbCcsXG4gICAgc291cmNlOiB7XG4gICAgICBwYWdlU2l6ZTogNDBcbiAgICB9LFxuICAgIGNodW5rU2l6ZTogNDAsXG4gICAgZG9uZUJ1dHRvbjogZmFsc2UsXG4gICAgZG9uZUJ1dHRvblRleHQ6ICdDbG9zZScsXG4gICAgbXVsdGlwbGVTZXBhcmF0b3I6ICcsICcsXG4gICAgc3R5bGVCYXNlOiAnYnRuJyxcbiAgICBzdHlsZTogY2xhc3NOYW1lcy5CVVRUT05DTEFTUyxcbiAgICBzaXplOiAnYXV0bycsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgYWxsb3dDbGVhcjogZmFsc2UsXG4gICAgc2VsZWN0ZWRUZXh0Rm9ybWF0OiAndmFsdWVzJyxcbiAgICB3aWR0aDogZmFsc2UsXG4gICAgY29udGFpbmVyOiBmYWxzZSxcbiAgICBoaWRlRGlzYWJsZWQ6IGZhbHNlLFxuICAgIHNob3dTdWJ0ZXh0OiBmYWxzZSxcbiAgICBzaG93SWNvbjogdHJ1ZSxcbiAgICBzaG93Q29udGVudDogdHJ1ZSxcbiAgICBkcm9wdXBBdXRvOiB0cnVlLFxuICAgIGhlYWRlcjogZmFsc2UsXG4gICAgbGl2ZVNlYXJjaDogZmFsc2UsXG4gICAgbGl2ZVNlYXJjaFBsYWNlaG9sZGVyOiBudWxsLFxuICAgIGxpdmVTZWFyY2hOb3JtYWxpemU6IGZhbHNlLFxuICAgIGxpdmVTZWFyY2hTdHlsZTogJ2NvbnRhaW5zJyxcbiAgICBhY3Rpb25zQm94OiBmYWxzZSxcbiAgICBpY29uQmFzZTogY2xhc3NOYW1lcy5JQ09OQkFTRSxcbiAgICB0aWNrSWNvbjogY2xhc3NOYW1lcy5USUNLSUNPTixcbiAgICBzaG93VGljazogZmFsc2UsXG4gICAgdGVtcGxhdGU6IHtcbiAgICAgIGNhcmV0OiAnPHNwYW4gY2xhc3M9XCJjYXJldFwiPjwvc3Bhbj4nXG4gICAgfSxcbiAgICBtYXhPcHRpb25zOiBmYWxzZSxcbiAgICBtb2JpbGU6IGZhbHNlLFxuICAgIHNlbGVjdE9uVGFiOiB0cnVlLFxuICAgIGRyb3Bkb3duQWxpZ25SaWdodDogZmFsc2UsXG4gICAgd2luZG93UGFkZGluZzogMCxcbiAgICB2aXJ0dWFsU2Nyb2xsOiA2MDAsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgc2FuaXRpemU6IHRydWUsXG4gICAgc2FuaXRpemVGbjogbnVsbCxcbiAgICB3aGl0ZUxpc3Q6IERlZmF1bHRXaGl0ZWxpc3RcbiAgfTtcblxuICBTZWxlY3RwaWNrZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFNlbGVjdHBpY2tlcixcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSxcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy4kZWxlbWVudFswXSxcbiAgICAgICAgICBmb3JtID0gZWxlbWVudC5mb3JtO1xuXG4gICAgICBzZWxlY3RJZCsrO1xuICAgICAgdGhpcy5zZWxlY3RJZCA9ICdicy1zZWxlY3QtJyArIHNlbGVjdElkO1xuXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2JzLXNlbGVjdC1oaWRkZW4nKTtcblxuICAgICAgdGhpcy5tdWx0aXBsZSA9IHRoaXMuJGVsZW1lbnQucHJvcCgnbXVsdGlwbGUnKTtcbiAgICAgIHRoaXMuYXV0b2ZvY3VzID0gdGhpcy4kZWxlbWVudC5wcm9wKCdhdXRvZm9jdXMnKTtcblxuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93LXRpY2snKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd1RpY2sgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRuZXdFbGVtZW50ID0gdGhpcy5jcmVhdGVEcm9wZG93bigpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5hZnRlcih0aGlzLiRuZXdFbGVtZW50KVxuICAgICAgICAucHJlcGVuZFRvKHRoaXMuJG5ld0VsZW1lbnQpO1xuXG4gICAgICAvLyBlbnN1cmUgc2VsZWN0IGlzIGFzc29jaWF0ZWQgd2l0aCBmb3JtIGVsZW1lbnQgaWYgaXQgZ290IHVubGlua2VkIGFmdGVyIG1vdmluZyBpdCBpbnNpZGUgbmV3RWxlbWVudFxuICAgICAgaWYgKGZvcm0gJiYgZWxlbWVudC5mb3JtID09PSBudWxsKSB7XG4gICAgICAgIGlmICghZm9ybS5pZCkgZm9ybS5pZCA9ICdmb3JtLScgKyB0aGlzLnNlbGVjdElkO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9ybScsIGZvcm0uaWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRidXR0b24gPSB0aGlzLiRuZXdFbGVtZW50LmNoaWxkcmVuKCdidXR0b24nKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dDbGVhcikgdGhpcy4kY2xlYXJCdXR0b24gPSB0aGlzLiRidXR0b24uY2hpbGRyZW4oJy5icy1zZWxlY3QtY2xlYXItc2VsZWN0ZWQnKTtcbiAgICAgIHRoaXMuJG1lbnUgPSB0aGlzLiRuZXdFbGVtZW50LmNoaWxkcmVuKFNlbGVjdG9yLk1FTlUpO1xuICAgICAgdGhpcy4kbWVudUlubmVyID0gdGhpcy4kbWVudS5jaGlsZHJlbignLmlubmVyJyk7XG4gICAgICB0aGlzLiRzZWFyY2hib3ggPSB0aGlzLiRtZW51LmZpbmQoJ2lucHV0Jyk7XG5cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYnMtc2VsZWN0LWhpZGRlbicpO1xuXG4gICAgICB0aGlzLmZldGNoRGF0YShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQucmVuZGVyKHRydWUpO1xuICAgICAgICB0aGF0LmJ1aWxkTGlzdCgpO1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQnICsgRVZFTlRfS0VZKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wZG93bkFsaWduUmlnaHQgPT09IHRydWUpIHRoaXMuJG1lbnVbMF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWVzLk1FTlVSSUdIVCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuJGJ1dHRvbi5hdHRyKCdkYXRhLWlkJywgaWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrRGlzYWJsZWQoKTtcbiAgICAgIHRoaXMuY2xpY2tMaXN0ZW5lcigpO1xuXG4gICAgICBpZiAodmVyc2lvbi5tYWpvciA+IDQpIHRoaXMuZHJvcGRvd24gPSBuZXcgRHJvcGRvd24odGhpcy4kYnV0dG9uWzBdKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgIHRoaXMubGl2ZVNlYXJjaExpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuZm9jdXNlZFBhcmVudCA9IHRoaXMuJHNlYXJjaGJveFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZFBhcmVudCA9IHRoaXMuJG1lbnVJbm5lclswXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdHlsZSgpO1xuICAgICAgdGhpcy5zZXRXaWR0aCgpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RQb3NpdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignaGlkZScgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhhdC5pc1ZpcnR1YWwoKSkge1xuICAgICAgICAgICAgLy8gZW1wdHkgbWVudSBvbiBjbG9zZVxuICAgICAgICAgICAgdmFyIG1lbnVJbm5lciA9IHRoYXQuJG1lbnVJbm5lclswXSxcbiAgICAgICAgICAgICAgICBlbXB0eU1lbnUgPSBtZW51SW5uZXIuZmlyc3RDaGlsZC5jbG9uZU5vZGUoZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBleGlzdGluZyBVTCB3aXRoIGFuIGVtcHR5IG9uZSAtIHRoaXMgaXMgZmFzdGVyIHRoYW4gJC5lbXB0eSgpIG9yIGlubmVySFRNTCA9ICcnXG4gICAgICAgICAgICBtZW51SW5uZXIucmVwbGFjZUNoaWxkKGVtcHR5TWVudSwgbWVudUlubmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgbWVudUlubmVyLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuJG1lbnUuZGF0YSgndGhpcycsIHRoaXMpO1xuICAgICAgdGhpcy4kbmV3RWxlbWVudC5kYXRhKCd0aGlzJywgdGhpcyk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1vYmlsZSkgdGhpcy5tb2JpbGUoKTtcblxuICAgICAgdGhpcy4kbmV3RWxlbWVudC5vbih7XG4gICAgICAgICdoaWRlLmJzLmRyb3Bkb3duJzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUnICsgRVZFTlRfS0VZLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2hpZGRlbi5icy5kcm9wZG93bic6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRkZW4nICsgRVZFTlRfS0VZLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3Nob3cuYnMuZHJvcGRvd24nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignc2hvdycgKyBFVkVOVF9LRVksIGUpO1xuICAgICAgICB9LFxuICAgICAgICAnc2hvd24uYnMuZHJvcGRvd24nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignc2hvd24nICsgRVZFTlRfS0VZLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmVxdWlyZWQnKSkge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdpbnZhbGlkJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuJGJ1dHRvblswXS5jbGFzc0xpc3QuYWRkKCdicy1pbnZhbGlkJyk7XG5cbiAgICAgICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgICAgICAub24oJ3Nob3duJyArIEVWRU5UX0tFWSArICcuaW52YWxpZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAgICAgICAgIC52YWwodGhhdC4kZWxlbWVudC52YWwoKSkgLy8gc2V0IHRoZSB2YWx1ZSB0byBoaWRlIHRoZSB2YWxpZGF0aW9uIG1lc3NhZ2UgaW4gQ2hyb21lIHdoZW4gbWVudSBpcyBvcGVuZWRcbiAgICAgICAgICAgICAgICAub2ZmKCdzaG93bicgKyBFVkVOVF9LRVkgKyAnLmludmFsaWQnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ3JlbmRlcmVkJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBpZiBzZWxlY3QgaXMgbm8gbG9uZ2VyIGludmFsaWQsIHJlbW92ZSB0aGUgYnMtaW52YWxpZCBjbGFzc1xuICAgICAgICAgICAgICBpZiAodGhpcy52YWxpZGl0eS52YWxpZCkgdGhhdC4kYnV0dG9uWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ2JzLWludmFsaWQnKTtcbiAgICAgICAgICAgICAgdGhhdC4kZWxlbWVudC5vZmYoJ3JlbmRlcmVkJyArIEVWRU5UX0tFWSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoYXQuJGJ1dHRvbi5vbignYmx1cicgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKCdibHVyJyk7XG4gICAgICAgICAgICB0aGF0LiRidXR0b24ub2ZmKCdibHVyJyArIEVWRU5UX0tFWSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICAkKGZvcm0pLm9uKCdyZXNldCcgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5yZW5kZXIoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZURyb3Bkb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBPcHRpb25zXG4gICAgICAvLyBJZiB3ZSBhcmUgbXVsdGlwbGUgb3Igc2hvd1RpY2sgb3B0aW9uIGlzIHNldCwgdGhlbiBhZGQgdGhlIHNob3ctdGljayBjbGFzc1xuICAgICAgdmFyIHNob3dUaWNrID0gKHRoaXMubXVsdGlwbGUgfHwgdGhpcy5vcHRpb25zLnNob3dUaWNrKSA/ICcgc2hvdy10aWNrJyA6ICcnLFxuICAgICAgICAgIG11bHRpc2VsZWN0YWJsZSA9IHRoaXMubXVsdGlwbGUgPyAnIGFyaWEtbXVsdGlzZWxlY3RhYmxlPVwidHJ1ZVwiJyA6ICcnLFxuICAgICAgICAgIGlucHV0R3JvdXAgPSAnJyxcbiAgICAgICAgICBhdXRvZm9jdXMgPSB0aGlzLmF1dG9mb2N1cyA/ICcgYXV0b2ZvY3VzJyA6ICcnO1xuXG4gICAgICBpZiAodmVyc2lvbi5tYWpvciA8IDQgJiYgdGhpcy4kZWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcygnaW5wdXQtZ3JvdXAnKSkge1xuICAgICAgICBpbnB1dEdyb3VwID0gJyBpbnB1dC1ncm91cC1idG4nO1xuICAgICAgfVxuXG4gICAgICAvLyBFbGVtZW50c1xuICAgICAgdmFyIGRyb3AsXG4gICAgICAgICAgaGVhZGVyID0gJycsXG4gICAgICAgICAgc2VhcmNoYm94ID0gJycsXG4gICAgICAgICAgYWN0aW9uc2JveCA9ICcnLFxuICAgICAgICAgIGRvbmVidXR0b24gPSAnJyxcbiAgICAgICAgICBjbGVhckJ1dHRvbiA9ICcnO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcikge1xuICAgICAgICBoZWFkZXIgPVxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzTmFtZXMuUE9QT1ZFUkhFQURFUiArICdcIj4nICtcbiAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvYnV0dG9uPicgK1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGVhZGVyICtcbiAgICAgICAgICAnPC9kaXY+JztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaGJveCA9XG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJicy1zZWFyY2hib3hcIj4nICtcbiAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInNlYXJjaFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCInICtcbiAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5saXZlU2VhcmNoUGxhY2Vob2xkZXIgPT09IG51bGwgPyAnJ1xuICAgICAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgICAnIHBsYWNlaG9sZGVyPVwiJyArIGh0bWxFc2NhcGUodGhpcy5vcHRpb25zLmxpdmVTZWFyY2hQbGFjZWhvbGRlcikgKyAnXCInXG4gICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAnIHJvbGU9XCJjb21ib2JveFwiIGFyaWEtbGFiZWw9XCJTZWFyY2hcIiBhcmlhLWNvbnRyb2xzPVwiJyArIHRoaXMuc2VsZWN0SWQgKyAnXCIgYXJpYS1hdXRvY29tcGxldGU9XCJsaXN0XCI+JyArXG4gICAgICAgICAgJzwvZGl2Pic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5hY3Rpb25zQm94KSB7XG4gICAgICAgIGFjdGlvbnNib3ggPVxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYnMtYWN0aW9uc2JveFwiPicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnRuLWdyb3VwLXNtXCI+JyArXG4gICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImFjdGlvbnMtYnRuIGJzLXNlbGVjdC1hbGwgYnRuICcgKyBjbGFzc05hbWVzLkJVVFRPTkNMQVNTICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RBbGxUZXh0ICtcbiAgICAgICAgICAgICAgJzwvYnV0dG9uPicgK1xuICAgICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJhY3Rpb25zLWJ0biBicy1kZXNlbGVjdC1hbGwgYnRuICcgKyBjbGFzc05hbWVzLkJVVFRPTkNMQVNTICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kZXNlbGVjdEFsbFRleHQgK1xuICAgICAgICAgICAgICAnPC9idXR0b24+JyArXG4gICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgJzwvZGl2Pic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5kb25lQnV0dG9uKSB7XG4gICAgICAgIGRvbmVidXR0b24gPVxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYnMtZG9uZWJ1dHRvblwiPicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIj4nICtcbiAgICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSAnICsgY2xhc3NOYW1lcy5CVVRUT05DTEFTUyArICdcIj4nICtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZG9uZUJ1dHRvblRleHQgK1xuICAgICAgICAgICAgICAnPC9idXR0b24+JyArXG4gICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgJzwvZGl2Pic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dDbGVhcikge1xuICAgICAgICBjbGVhckJ1dHRvbiA9ICc8c3BhbiBjbGFzcz1cImNsb3NlIGJzLXNlbGVjdC1jbGVhci1zZWxlY3RlZFwiIHRpdGxlPVwiJyArIHRoaXMub3B0aW9ucy5kZXNlbGVjdEFsbFRleHQgKyAnXCI+PHNwYW4+JnRpbWVzOzwvc3Bhbj4nO1xuICAgICAgfVxuXG4gICAgICBkcm9wID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJkcm9wZG93biBib290c3RyYXAtc2VsZWN0JyArIHNob3dUaWNrICsgaW5wdXRHcm91cCArICdcIj4nICtcbiAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCItMVwiIGNsYXNzPVwiJyArXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3R5bGVCYXNlICtcbiAgICAgICAgICAgICcgZHJvcGRvd24tdG9nZ2xlXCIgJyArXG4gICAgICAgICAgICAodGhpcy5vcHRpb25zLmRpc3BsYXkgPT09ICdzdGF0aWMnID8gJ2RhdGEtZGlzcGxheT1cInN0YXRpY1wiJyA6ICcnKSArXG4gICAgICAgICAgICBTZWxlY3Rvci5EQVRBX1RPR0dMRSArXG4gICAgICAgICAgICBhdXRvZm9jdXMgK1xuICAgICAgICAgICAgJyByb2xlPVwiY29tYm9ib3hcIiBhcmlhLW93bnM9XCInICtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SWQgK1xuICAgICAgICAgICAgJ1wiIGFyaWEtaGFzcG9wdXA9XCJsaXN0Ym94XCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+JyArXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZpbHRlci1vcHRpb25cIj4nICtcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmaWx0ZXItb3B0aW9uLWlubmVyXCI+JyArXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmaWx0ZXItb3B0aW9uLWlubmVyLWlubmVyXCI+Jm5ic3A7PC9kaXY+JyArXG4gICAgICAgICAgICAgICc8L2Rpdj4gJyArXG4gICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICBjbGVhckJ1dHRvbiArXG4gICAgICAgICAgICAnPC9zcGFuPicgK1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICB2ZXJzaW9uLm1ham9yID49ICc0JyA/ICcnXG4gICAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiYnMtY2FyZXRcIj4nICtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGVtcGxhdGUuY2FyZXQgK1xuICAgICAgICAgICAgICAnPC9zcGFuPidcbiAgICAgICAgICAgICkgK1xuICAgICAgICAgICc8L2J1dHRvbj4nICtcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cIicgKyBjbGFzc05hbWVzLk1FTlUgKyAnICcgKyAodmVyc2lvbi5tYWpvciA+PSAnNCcgPyAnJyA6IGNsYXNzTmFtZXMuU0hPVykgKyAnXCI+JyArXG4gICAgICAgICAgICBoZWFkZXIgK1xuICAgICAgICAgICAgc2VhcmNoYm94ICtcbiAgICAgICAgICAgIGFjdGlvbnNib3ggK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpbm5lciAnICsgY2xhc3NOYW1lcy5TSE9XICsgJ1wiIHJvbGU9XCJsaXN0Ym94XCIgaWQ9XCInICsgdGhpcy5zZWxlY3RJZCArICdcIiB0YWJpbmRleD1cIi0xXCIgJyArIG11bHRpc2VsZWN0YWJsZSArICc+JyArXG4gICAgICAgICAgICAgICAgJzx1bCBjbGFzcz1cIicgKyBjbGFzc05hbWVzLk1FTlUgKyAnIGlubmVyICcgKyAodmVyc2lvbi5tYWpvciA+PSAnNCcgPyBjbGFzc05hbWVzLlNIT1cgOiAnJykgKyAnXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPicgK1xuICAgICAgICAgICAgICAgICc8L3VsPicgK1xuICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgZG9uZWJ1dHRvbiArXG4gICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPC9kaXY+JztcblxuICAgICAgcmV0dXJuICQoZHJvcCk7XG4gICAgfSxcblxuICAgIHNldFBvc2l0aW9uRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHQgPSBbXTtcbiAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuc2l6ZSA9IDA7XG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LmZpcnN0SGlnaGxpZ2h0SW5kZXggPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpID0gdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2ldLFxuICAgICAgICAgICAgY2FuSGlnaGxpZ2h0ID0gdHJ1ZTtcblxuICAgICAgICBpZiAobGkudHlwZSA9PT0gJ2RpdmlkZXInKSB7XG4gICAgICAgICAgY2FuSGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgbGkuaGVpZ2h0ID0gdGhpcy5zaXplSW5mby5kaXZpZGVySGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGxpLnR5cGUgPT09ICdvcHRncm91cC1sYWJlbCcpIHtcbiAgICAgICAgICBjYW5IaWdobGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICBsaS5oZWlnaHQgPSB0aGlzLnNpemVJbmZvLmRyb3Bkb3duSGVhZGVySGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpLmhlaWdodCA9IHRoaXMuc2l6ZUluZm8ubGlIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGkuZGlzYWJsZWQpIGNhbkhpZ2hsaWdodCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0LnB1c2goY2FuSGlnaGxpZ2h0KTtcblxuICAgICAgICBpZiAoY2FuSGlnaGxpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5zaXplKys7XG4gICAgICAgICAgbGkucG9zaW5zZXQgPSB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnNpemU7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuZmlyc3RIaWdobGlnaHRJbmRleCA9PT0gZmFsc2UpIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuZmlyc3RIaWdobGlnaHRJbmRleCA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBsaS5wb3NpdGlvbiA9IChpID09PSAwID8gMCA6IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpIC0gMV0ucG9zaXRpb24pICsgbGkuaGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1ZpcnR1YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5vcHRpb25zLnZpcnR1YWxTY3JvbGwgIT09IGZhbHNlKSAmJiAodGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMudmlydHVhbFNjcm9sbCkgfHwgdGhpcy5vcHRpb25zLnZpcnR1YWxTY3JvbGwgPT09IHRydWU7XG4gICAgfSxcblxuICAgIGNyZWF0ZVZpZXc6IGZ1bmN0aW9uIChpc1NlYXJjaGluZywgc2V0U2l6ZSwgcmVmcmVzaCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IDA7XG5cbiAgICAgIHRoaXMuc2VsZWN0cGlja2VyLmlzU2VhcmNoaW5nID0gaXNTZWFyY2hpbmc7XG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50ID0gaXNTZWFyY2hpbmcgPyB0aGlzLnNlbGVjdHBpY2tlci5zZWFyY2ggOiB0aGlzLnNlbGVjdHBpY2tlci5tYWluO1xuXG4gICAgICB0aGlzLnNldFBvc2l0aW9uRGF0YSgpO1xuXG4gICAgICBpZiAoc2V0U2l6ZSkge1xuICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgIHNjcm9sbFRvcCA9IHRoaXMuJG1lbnVJbm5lclswXS5zY3JvbGxUb3A7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoYXQubXVsdGlwbGUpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoYXQuJGVsZW1lbnRbMF0sXG4gICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSAoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0gfHwge30pLmxpSW5kZXg7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdGVkSW5kZXggPT09ICdudW1iZXInICYmIHRoYXQub3B0aW9ucy5zaXplICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtzZWxlY3RlZEluZGV4XSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHNlbGVjdGVkRGF0YSAmJiBzZWxlY3RlZERhdGEucG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICBzY3JvbGxUb3AgPSBwb3NpdGlvbiAtICgodGhhdC5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQgKyB0aGF0LnNpemVJbmZvLmxpSGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzY3JvbGwoc2Nyb2xsVG9wLCB0cnVlKTtcblxuICAgICAgdGhpcy4kbWVudUlubmVyLm9mZignc2Nyb2xsLmNyZWF0ZVZpZXcnKS5vbignc2Nyb2xsLmNyZWF0ZVZpZXcnLCBmdW5jdGlvbiAoZSwgdXBkYXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGF0Lm5vU2Nyb2xsKSBzY3JvbGwodGhpcy5zY3JvbGxUb3AsIHVwZGF0ZVZhbHVlKTtcbiAgICAgICAgdGhhdC5ub1Njcm9sbCA9IGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNjcm9sbCAoc2Nyb2xsVG9wLCBpbml0KSB7XG4gICAgICAgIHZhciBzaXplID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGNodW5rcyA9IFtdLFxuICAgICAgICAgICAgY2h1bmtTaXplLFxuICAgICAgICAgICAgY2h1bmtDb3VudCxcbiAgICAgICAgICAgIGZpcnN0Q2h1bmssXG4gICAgICAgICAgICBsYXN0Q2h1bmssXG4gICAgICAgICAgICBjdXJyZW50Q2h1bmssXG4gICAgICAgICAgICBwcmV2UG9zaXRpb25zLFxuICAgICAgICAgICAgcG9zaXRpb25Jc0RpZmZlcmVudCxcbiAgICAgICAgICAgIHByZXZpb3VzRWxlbWVudHMsXG4gICAgICAgICAgICBtZW51SXNEaWZmZXJlbnQgPSB0cnVlLFxuICAgICAgICAgICAgaXNWaXJ0dWFsID0gdGhhdC5pc1ZpcnR1YWwoKTtcblxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcblxuICAgICAgICBjaHVua1NpemUgPSB0aGF0Lm9wdGlvbnMuY2h1bmtTaXplOyAvLyBudW1iZXIgb2Ygb3B0aW9ucyBpbiBhIGNodW5rXG4gICAgICAgIGNodW5rQ291bnQgPSBNYXRoLmNlaWwoc2l6ZSAvIGNodW5rU2l6ZSkgfHwgMTsgLy8gbnVtYmVyIG9mIGNodW5rc1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtDb3VudDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVuZE9mQ2h1bmsgPSAoaSArIDEpICogY2h1bmtTaXplO1xuXG4gICAgICAgICAgaWYgKGkgPT09IGNodW5rQ291bnQgLSAxKSB7XG4gICAgICAgICAgICBlbmRPZkNodW5rID0gc2l6ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaHVua3NbaV0gPSBbXG4gICAgICAgICAgICAoaSkgKiBjaHVua1NpemUgKyAoIWkgPyAwIDogMSksXG4gICAgICAgICAgICBlbmRPZkNodW5rXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGlmICghc2l6ZSkgYnJlYWs7XG5cbiAgICAgICAgICBpZiAoY3VycmVudENodW5rID09PSB1bmRlZmluZWQgJiYgc2Nyb2xsVG9wIC0gMSA8PSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbZW5kT2ZDaHVuayAtIDFdLnBvc2l0aW9uIC0gdGhhdC5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuayA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDaHVuayA9PT0gdW5kZWZpbmVkKSBjdXJyZW50Q2h1bmsgPSAwO1xuXG4gICAgICAgIHByZXZQb3NpdGlvbnMgPSBbdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAsIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xXTtcblxuICAgICAgICAvLyBhbHdheXMgZGlzcGxheSBwcmV2aW91cywgY3VycmVudCwgYW5kIG5leHQgY2h1bmtzXG4gICAgICAgIGZpcnN0Q2h1bmsgPSBNYXRoLm1heCgwLCBjdXJyZW50Q2h1bmsgLSAxKTtcbiAgICAgICAgbGFzdENodW5rID0gTWF0aC5taW4oY2h1bmtDb3VudCAtIDEsIGN1cnJlbnRDaHVuayArIDEpO1xuXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wID0gaXNWaXJ0dWFsID09PSBmYWxzZSA/IDAgOiAoTWF0aC5tYXgoMCwgY2h1bmtzW2ZpcnN0Q2h1bmtdWzBdKSB8fCAwKTtcbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjEgPSBpc1ZpcnR1YWwgPT09IGZhbHNlID8gc2l6ZSA6IChNYXRoLm1pbihzaXplLCBjaHVua3NbbGFzdENodW5rXVsxXSkgfHwgMCk7XG5cbiAgICAgICAgcG9zaXRpb25Jc0RpZmZlcmVudCA9IHByZXZQb3NpdGlvbnNbMF0gIT09IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wIHx8IHByZXZQb3NpdGlvbnNbMV0gIT09IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xO1xuXG4gICAgICAgIGlmICh0aGF0LmFjdGl2ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICBpZiAodGhhdC5hY3RpdmVFbGVtZW50ICE9PSB0aGF0LnNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICAgICAgICB0aGF0LmRlZm9jdXNJdGVtKHRoYXQuYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0LmFjdGl2ZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoYXQuYWN0aXZlRWxlbWVudCAhPT0gdGhhdC5zZWxlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoYXQuZGVmb2N1c0l0ZW0odGhhdC5zZWxlY3RlZEVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGF0LnByZXZBY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgdGhhdC5wcmV2QWN0aXZlRWxlbWVudCAhPT0gdGhhdC5hY3RpdmVFbGVtZW50ICYmIHRoYXQucHJldkFjdGl2ZUVsZW1lbnQgIT09IHRoYXQuc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgdGhhdC5kZWZvY3VzSXRlbSh0aGF0LnByZXZBY3RpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0IHx8IHBvc2l0aW9uSXNEaWZmZXJlbnQgfHwgdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5oYXNNb3JlKSB7XG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50cyA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzID8gdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMuc2xpY2UoKSA6IFtdO1xuXG4gICAgICAgICAgaWYgKGlzVmlydHVhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzLnNsaWNlKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wLCB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhhdC5zZXRPcHRpb25TdGF0dXMoKTtcblxuICAgICAgICAgIC8vIGlmIHNlYXJjaGluZywgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBsaXN0IGhhcyBhY3R1YWxseSBiZWVuIHVwZGF0ZWQgYmVmb3JlIHVwZGF0aW5nIERPTVxuICAgICAgICAgIC8vIHRoaXMgcHJldmVudHMgdW5uZWNlc3NhcnkgcmVwYWludHNcbiAgICAgICAgICBpZiAoaXNTZWFyY2hpbmcgfHwgKGlzVmlydHVhbCA9PT0gZmFsc2UgJiYgaW5pdCkpIG1lbnVJc0RpZmZlcmVudCA9ICFpc0VxdWFsKHByZXZpb3VzRWxlbWVudHMsIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzKTtcblxuICAgICAgICAgIC8vIGlmIHZpcnR1YWwgc2Nyb2xsIGlzIGRpc2FibGVkIGFuZCBub3Qgc2VhcmNoaW5nLFxuICAgICAgICAgIC8vIG1lbnUgc2hvdWxkIG5ldmVyIG5lZWQgdG8gYmUgdXBkYXRlZCBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIGlmICgoaW5pdCB8fCBpc1ZpcnR1YWwgPT09IHRydWUpICYmIG1lbnVJc0RpZmZlcmVudCkge1xuICAgICAgICAgICAgdmFyIG1lbnVJbm5lciA9IHRoYXQuJG1lbnVJbm5lclswXSxcbiAgICAgICAgICAgICAgICBtZW51RnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICAgICAgZW1wdHlNZW51ID0gbWVudUlubmVyLmZpcnN0Q2hpbGQuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3AsXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgdG9TYW5pdGl6ZSA9IFtdO1xuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBleGlzdGluZyBVTCB3aXRoIGFuIGVtcHR5IG9uZSAtIHRoaXMgaXMgZmFzdGVyIHRoYW4gJC5lbXB0eSgpXG4gICAgICAgICAgICBtZW51SW5uZXIucmVwbGFjZUNoaWxkKGVtcHR5TWVudSwgbWVudUlubmVyLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdmlzaWJsZUVsZW1lbnRzTGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgdmlzaWJsZUVsZW1lbnRzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXSxcbiAgICAgICAgICAgICAgICAgIGVsVGV4dCxcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnREYXRhO1xuXG4gICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICAgICAgICAgICAgICBlbFRleHQgPSBlbGVtZW50Lmxhc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChlbFRleHQpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnREYXRhID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2kgKyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMF07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50RGF0YSAmJiBlbGVtZW50RGF0YS5jb250ZW50ICYmICFlbGVtZW50RGF0YS5zYW5pdGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9TYW5pdGl6ZS5wdXNoKGVsVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnREYXRhLnNhbml0aXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbWVudUZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNhbml0aXplICYmIHRvU2FuaXRpemUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHNhbml0aXplSHRtbCh0b1Nhbml0aXplLCB0aGF0Lm9wdGlvbnMud2hpdGVMaXN0LCB0aGF0Lm9wdGlvbnMuc2FuaXRpemVGbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1ZpcnR1YWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wID09PSAwID8gMCA6IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVt0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCAtIDFdLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xID4gc2l6ZSAtIDEgPyAwIDogdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW3NpemUgLSAxXS5wb3NpdGlvbiAtIHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVt0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMSAtIDFdLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICBtZW51SW5uZXIuZmlyc3RDaGlsZC5zdHlsZS5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3AgKyAncHgnO1xuICAgICAgICAgICAgICBtZW51SW5uZXIuZmlyc3RDaGlsZC5zdHlsZS5tYXJnaW5Cb3R0b20gPSBtYXJnaW5Cb3R0b20gKyAncHgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWFyZ2luVG9wID0gMDtcbiAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWFyZ2luQm90dG9tID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQobWVudUZyYWdtZW50KTtcblxuICAgICAgICAgICAgLy8gaWYgYW4gb3B0aW9uIGlzIGVuY291bnRlcmVkIHRoYXQgaXMgd2lkZXIgdGhhbiB0aGUgY3VycmVudCBtZW51IHdpZHRoLCB1cGRhdGUgdGhlIG1lbnUgd2lkdGggYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIC8vIHN3aXRjaCB0byBSZXNpemVPYnNlcnZlciB3aXRoIGluY3JlYXNlZCBicm93c2VyIHN1cHBvcnRcbiAgICAgICAgICAgIGlmIChpc1ZpcnR1YWwgPT09IHRydWUgJiYgdGhhdC5zaXplSW5mby5oYXNTY3JvbGxCYXIpIHtcbiAgICAgICAgICAgICAgdmFyIG1lbnVJbm5lcklubmVyV2lkdGggPSBtZW51SW5uZXIuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgICBpZiAoaW5pdCAmJiBtZW51SW5uZXJJbm5lcldpZHRoIDwgdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoICYmIHRoYXQuc2l6ZUluZm8udG90YWxNZW51V2lkdGggPiB0aGF0LnNpemVJbmZvLnNlbGVjdFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWluV2lkdGggPSB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lbnVJbm5lcklubmVyV2lkdGggPiB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdG8gMCB0byBnZXQgYWN0dWFsIHdpZHRoIG9mIG1lbnVcbiAgICAgICAgICAgICAgICB0aGF0LiRtZW51WzBdLnN0eWxlLm1pbldpZHRoID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBhY3R1YWxNZW51V2lkdGggPSBtZW51SW5uZXIuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhY3R1YWxNZW51V2lkdGggPiB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgIHRoYXQuc2l6ZUluZm8ubWVudUlubmVySW5uZXJXaWR0aCA9IGFjdHVhbE1lbnVXaWR0aDtcbiAgICAgICAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLnN0eWxlLm1pbldpZHRoID0gdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZXNldCB0byBkZWZhdWx0IENTUyBzdHlsaW5nXG4gICAgICAgICAgICAgICAgdGhhdC4kbWVudVswXS5zdHlsZS5taW5XaWR0aCA9ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCghaXNTZWFyY2hpbmcgJiYgdGhhdC5vcHRpb25zLnNvdXJjZS5kYXRhIHx8IGlzU2VhcmNoaW5nICYmIHRoYXQub3B0aW9ucy5zb3VyY2Uuc2VhcmNoKSAmJiB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50Lmhhc01vcmUgJiYgY3VycmVudENodW5rID09PSBjaHVua0NvdW50IC0gMSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgbG9hZCB0aGUgbmV4dCBjaHVuayB1bnRpbCBzY3JvbGxpbmcgaGFzIHN0YXJ0ZWRcbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgdW5uZWNlc3NhcnkgcmVxdWVzdHMgd2hpbGUgdGhlIHVzZXIgaXMgdHlwaW5nIGlmIHBhZ2VTaXplIGlzIDw9IGNodW5rU2l6ZVxuICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gQ2h1bmtzIHVzZSAwLWJhc2VkIGluZGV4aW5nLCBidXQgcGFnZXMgdXNlIDEtYmFzZWQuIEFkZCAxIHRvIGNvbnZlcnQgYW5kIGFkZCAxIGFnYWluIHRvIGdldCBuZXh0IHBhZ2VcbiAgICAgICAgICAgICAgdmFyIHBhZ2UgPSBNYXRoLmZsb29yKChjdXJyZW50Q2h1bmsgKiB0aGF0Lm9wdGlvbnMuY2h1bmtTaXplKSAvIHRoYXQub3B0aW9ucy5zb3VyY2UucGFnZVNpemUpICsgMjtcblxuICAgICAgICAgICAgICB0aGF0LmZldGNoRGF0YShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGF0LmJ1aWxkTGlzdChzaXplLCBpc1NlYXJjaGluZyk7XG4gICAgICAgICAgICAgICAgdGhhdC5zZXRQb3NpdGlvbkRhdGEoKTtcbiAgICAgICAgICAgICAgICBzY3JvbGwoc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgfSwgaXNTZWFyY2hpbmcgPyAnc2VhcmNoJyA6ICdkYXRhJywgcGFnZSwgaXNTZWFyY2hpbmcgPyB0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2gucHJldmlvdXNWYWx1ZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5wcmV2QWN0aXZlRWxlbWVudCA9IHRoYXQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICBpZiAoIXRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTZWFyY2hpbmcgJiYgaW5pdCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIG5ld0FjdGl2ZTtcblxuICAgICAgICAgIGlmICghdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHRbaW5kZXhdKSB7XG4gICAgICAgICAgICBpbmRleCA9IDEgKyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5zbGljZSgxKS5pbmRleE9mKHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld0FjdGl2ZSA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgIHRoYXQuZGVmb2N1c0l0ZW0odGhhdC5zZWxlY3RwaWNrZXIudmlldy5jdXJyZW50QWN0aXZlKTtcblxuICAgICAgICAgIHRoYXQuYWN0aXZlRWxlbWVudCA9ICh0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbaW5kZXhdIHx8IHt9KS5lbGVtZW50O1xuXG4gICAgICAgICAgdGhhdC5mb2N1c0l0ZW0obmV3QWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkKHdpbmRvdylcbiAgICAgICAgLm9mZigncmVzaXplJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnLmNyZWF0ZVZpZXcnKVxuICAgICAgICAub24oJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5jcmVhdGVWaWV3JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IHRoYXQuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKTtcblxuICAgICAgICAgIGlmIChpc0FjdGl2ZSkgc2Nyb2xsKHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3ApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZm9jdXNJdGVtOiBmdW5jdGlvbiAobGksIGxpRGF0YSwgbm9TdHlsZSkge1xuICAgICAgaWYgKGxpKSB7XG4gICAgICAgIGxpRGF0YSA9IGxpRGF0YSB8fCB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cy5pbmRleE9mKHRoaXMuYWN0aXZlRWxlbWVudCldO1xuICAgICAgICB2YXIgYSA9IGxpLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnYXJpYS1zZXRzaXplJywgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5zaXplKTtcbiAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnYXJpYS1wb3NpbnNldCcsIGxpRGF0YS5wb3NpbnNldCk7XG5cbiAgICAgICAgICBpZiAobm9TdHlsZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkUGFyZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgYS5pZCk7XG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIGEuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlZm9jdXNJdGVtOiBmdW5jdGlvbiAobGkpIHtcbiAgICAgIGlmIChsaSkge1xuICAgICAgICBsaS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgaWYgKGxpLmZpcnN0Q2hpbGQpIGxpLmZpcnN0Q2hpbGQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldFBsYWNlaG9sZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgdXBkYXRlSW5kZXggPSBmYWxzZTtcblxuICAgICAgaWYgKCh0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIgfHwgdGhpcy5vcHRpb25zLmFsbG93Q2xlYXIpICYmICF0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbikgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuXG4gICAgICAgIC8vIHRoaXMgb3B0aW9uIGRvZXNuJ3QgY3JlYXRlIGEgbmV3IDxsaT4gZWxlbWVudCwgYnV0IGRvZXMgYWRkIGEgbmV3IG9wdGlvbiBhdCB0aGUgc3RhcnQsXG4gICAgICAgIC8vIHNvIHN0YXJ0SW5kZXggc2hvdWxkIGluY3JlYXNlIHRvIHByZXZlbnQgaGF2aW5nIHRvIGNoZWNrIGV2ZXJ5IG9wdGlvbiBmb3IgdGhlIGJzLXRpdGxlLW9wdGlvbiBjbGFzc1xuICAgICAgICB1cGRhdGVJbmRleCA9IHRydWU7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50WzBdLFxuICAgICAgICAgICAgc2VsZWN0VGl0bGVPcHRpb24gPSBmYWxzZSxcbiAgICAgICAgICAgIHRpdGxlTm90QXBwZW5kZWQgPSAhdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbi5wYXJlbnROb2RlLFxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgIHNlbGVjdGVkT3B0aW9uID0gZWxlbWVudC5vcHRpb25zW3NlbGVjdGVkSW5kZXhdLFxuICAgICAgICAgICAgZmlyc3RTZWxlY3RhYmxlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzZWxlY3QgPiAqOm5vdCg6ZGlzYWJsZWQpJyksXG4gICAgICAgICAgICBmaXJzdFNlbGVjdGFibGVJbmRleCA9IGZpcnN0U2VsZWN0YWJsZSA/IGZpcnN0U2VsZWN0YWJsZS5pbmRleCA6IDAsXG4gICAgICAgICAgICBuYXZpZ2F0aW9uID0gd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKCduYXZpZ2F0aW9uJyksXG4gICAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBzdXBwb3J0IGdldEVudHJpZXNCeVR5cGUoJ25hdmlnYXRpb24nKSAtIGZhbGwgYmFjayB0byBwZXJmb3JtYW5jZS5uYXZpZ2F0aW9uXG4gICAgICAgICAgICBpc05vdEJhY2tGb3J3YXJkID0gKG5hdmlnYXRpb24gJiYgbmF2aWdhdGlvbi5sZW5ndGgpID8gbmF2aWdhdGlvblswXS50eXBlICE9PSAnYmFja19mb3J3YXJkJyA6IHdpbmRvdy5wZXJmb3JtYW5jZS5uYXZpZ2F0aW9uLnR5cGUgIT09IDI7XG5cbiAgICAgICAgaWYgKHRpdGxlTm90QXBwZW5kZWQpIHtcbiAgICAgICAgICAvLyBVc2UgbmF0aXZlIEpTIHRvIHByZXBlbmQgb3B0aW9uIChmYXN0ZXIpXG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbi5jbGFzc05hbWUgPSAnYnMtdGl0bGUtb3B0aW9uJztcbiAgICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLnZhbHVlID0gJyc7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBzZWxlY3RlZCBvciBkYXRhLXNlbGVjdGVkIGF0dHJpYnV0ZSBpcyBhbHJlYWR5IHNldCBvbiBhbiBvcHRpb24uIElmIG5vdCwgc2VsZWN0IHRoZSB0aXRsZU9wdGlvbiBvcHRpb24uXG4gICAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGl0ZW0gbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIGJ5IHVzZXIgb3IgcHJvZ3JhbW1hdGljYWxseSBiZWZvcmUgdGhlIGJvb3RzdHJhcCBzZWxlY3QgcGx1Z2luIHJ1bnMsXG4gICAgICAgICAgLy8gaWYgc28sIHRoZSBzZWxlY3Qgd2lsbCBoYXZlIHRoZSBkYXRhLXNlbGVjdGVkIGF0dHJpYnV0ZVxuICAgICAgICAgIHNlbGVjdFRpdGxlT3B0aW9uID0gIXNlbGVjdGVkT3B0aW9uIHx8IChzZWxlY3RlZEluZGV4ID09PSBmaXJzdFNlbGVjdGFibGVJbmRleCAmJiBzZWxlY3RlZE9wdGlvbi5kZWZhdWx0U2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMuJGVsZW1lbnQuZGF0YSgnc2VsZWN0ZWQnKSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aXRsZU5vdEFwcGVuZGVkIHx8IHRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24uaW5kZXggIT09IDApIHtcbiAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLCBlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHNlbGVjdGVkICphZnRlciogYXBwZW5kaW5nIHRvIHNlbGVjdCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBvcHRpb24gZG9lc24ndCBnZXQgc2VsZWN0ZWQgaW4gSUVcbiAgICAgICAgLy8gc2V0IHVzaW5nIHNlbGVjdGVkSW5kZXgsIGFzIHNldHRpbmcgdGhlIHNlbGVjdGVkIGF0dHIgdG8gdHJ1ZSBoZXJlIGRvZXNuJ3Qgd29yayBpbiBJRTExXG4gICAgICAgIGlmIChzZWxlY3RUaXRsZU9wdGlvbiAmJiBpc05vdEJhY2tGb3J3YXJkKSB7XG4gICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgLy8gaWYgbmF2aWdhdGlvbiB0eXBlIGlzIGJhY2tfZm9yd2FyZCwgdGhlcmUncyBhIGNoYW5jZSB0aGUgc2VsZWN0IHdpbGwgaGF2ZSBpdHMgdmFsdWUgc2V0IGJ5IEJGQ2FjaGVcbiAgICAgICAgICAvLyB3YWl0IGZvciB0aGF0IHZhbHVlIHRvIGJlIHNldCwgdGhlbiBydW4gcmVuZGVyIGFnYWluXG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuZGlzcGxheWVkVmFsdWUgIT09IGVsZW1lbnQudmFsdWUpIHRoYXQucmVuZGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZUluZGV4O1xuICAgIH0sXG5cbiAgICBmZXRjaERhdGE6IGZ1bmN0aW9uIChjYWxsYmFjaywgdHlwZSwgcGFnZSwgc2VhcmNoVmFsdWUpIHtcbiAgICAgIHBhZ2UgPSBwYWdlIHx8IDE7XG4gICAgICB0eXBlID0gdHlwZSB8fCAnZGF0YSc7XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBkYXRhID0gdGhpcy5vcHRpb25zLnNvdXJjZVt0eXBlXSxcbiAgICAgICAgICBidWlsdERhdGE7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52aXJ0dWFsU2Nyb2xsID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkYXRhLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGRhdGEsIG1vcmUsIHRvdGFsSXRlbXMpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGF0LnNlbGVjdHBpY2tlclt0eXBlID09PSAnc2VhcmNoJyA/ICdzZWFyY2gnIDogJ21haW4nXTtcbiAgICAgICAgICAgICAgY3VycmVudC5oYXNNb3JlID0gbW9yZTtcbiAgICAgICAgICAgICAgY3VycmVudC50b3RhbEl0ZW1zID0gdG90YWxJdGVtcztcbiAgICAgICAgICAgICAgYnVpbHREYXRhID0gdGhhdC5idWlsZERhdGEoZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhhdCwgYnVpbHREYXRhKTtcbiAgICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmZXRjaGVkJyArIEVWRU5UX0tFWSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFnZSxcbiAgICAgICAgICAgIHNlYXJjaFZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgYnVpbHREYXRhID0gdGhhdC5idWlsZERhdGEoZGF0YSwgdHlwZSk7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGF0LCBidWlsdERhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWlsdERhdGEgPSB0aGlzLmJ1aWxkRGF0YShmYWxzZSwgdHlwZSk7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhhdCwgYnVpbHREYXRhKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYnVpbGREYXRhOiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGRhdGFHZXR0ZXIgPSBkYXRhID09PSBmYWxzZSA/IGdldE9wdGlvbkRhdGEuZnJvbU9wdGlvbiA6IGdldE9wdGlvbkRhdGEuZnJvbURhdGFTb3VyY2U7XG5cbiAgICAgIHZhciBvcHRpb25TZWxlY3RvciA9ICc6bm90KFtoaWRkZW5dKTpub3QoW2RhdGEtaGlkZGVuPVwidHJ1ZVwiXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdKScsXG4gICAgICAgICAgbWFpbkRhdGEgPSBbXSxcbiAgICAgICAgICBzdGFydExlbiA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YSA/IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YS5sZW5ndGggOiAwLFxuICAgICAgICAgIG9wdElEID0gMCxcbiAgICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZXRQbGFjZWhvbGRlcigpICYmICFkYXRhID8gMSA6IDA7IC8vIGFwcGVuZCB0aGUgdGl0bGVPcHRpb24gaWYgbmVjZXNzYXJ5IGFuZCBza2lwIHRoZSBmaXJzdCBvcHRpb24gaW4gdGhlIGxvb3BcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWFyY2gnKSB7XG4gICAgICAgIHN0YXJ0TGVuID0gdGhpcy5zZWxlY3RwaWNrZXIuc2VhcmNoLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZGVEaXNhYmxlZCkgb3B0aW9uU2VsZWN0b3IgKz0gJzpub3QoOmRpc2FibGVkKSc7XG5cbiAgICAgIHZhciBzZWxlY3RPcHRpb25zID0gZGF0YSA/IGRhdGEuZmlsdGVyKGZpbHRlckhpZGRlbiwgdGhpcykgOiB0aGlzLiRlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCA+IConICsgb3B0aW9uU2VsZWN0b3IpO1xuXG4gICAgICBmdW5jdGlvbiBhZGREaXZpZGVyIChjb25maWcpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzRGF0YSA9IG1haW5EYXRhW21haW5EYXRhLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIGVuc3VyZSBvcHRncm91cCBkb2Vzbid0IGNyZWF0ZSBiYWNrLXRvLWJhY2sgZGl2aWRlcnNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByZXZpb3VzRGF0YSAmJlxuICAgICAgICAgIHByZXZpb3VzRGF0YS50eXBlID09PSAnZGl2aWRlcicgJiZcbiAgICAgICAgICAocHJldmlvdXNEYXRhLm9wdElEIHx8IGNvbmZpZy5vcHRJRClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBjb25maWcudHlwZSA9ICdkaXZpZGVyJztcblxuICAgICAgICBtYWluRGF0YS5wdXNoKGNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE9wdGlvbiAoaXRlbSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgICBjb25maWcuZGl2aWRlciA9IGRhdGFHZXR0ZXIoaXRlbSwgJ2RpdmlkZXInKTtcblxuICAgICAgICBpZiAoY29uZmlnLmRpdmlkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhZGREaXZpZGVyKHtcbiAgICAgICAgICAgIG9wdElEOiBjb25maWcub3B0SURcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGlJbmRleCA9IG1haW5EYXRhLmxlbmd0aCArIHN0YXJ0TGVuLFxuICAgICAgICAgICAgICBjc3NUZXh0ID0gZGF0YUdldHRlcihpdGVtLCAnc3R5bGUnKSxcbiAgICAgICAgICAgICAgaW5saW5lU3R5bGUgPSBjc3NUZXh0ID8gaHRtbEVzY2FwZShjc3NUZXh0KSA6ICcnLFxuICAgICAgICAgICAgICBvcHRpb25DbGFzcyA9IChpdGVtLmNsYXNzTmFtZSB8fCAnJykgKyAoY29uZmlnLm9wdGdyb3VwQ2xhc3MgfHwgJycpO1xuXG4gICAgICAgICAgaWYgKGNvbmZpZy5vcHRJRCkgb3B0aW9uQ2xhc3MgPSAnb3B0ICcgKyBvcHRpb25DbGFzcztcblxuICAgICAgICAgIGNvbmZpZy5vcHRpb25DbGFzcyA9IG9wdGlvbkNsYXNzLnRyaW0oKTtcbiAgICAgICAgICBjb25maWcuaW5saW5lU3R5bGUgPSBpbmxpbmVTdHlsZTtcblxuICAgICAgICAgIGNvbmZpZy50ZXh0ID0gZGF0YUdldHRlcihpdGVtLCAndGV4dCcpO1xuICAgICAgICAgIGNvbmZpZy50aXRsZSA9IGRhdGFHZXR0ZXIoaXRlbSwgJ3RpdGxlJyk7XG4gICAgICAgICAgY29uZmlnLmNvbnRlbnQgPSBkYXRhR2V0dGVyKGl0ZW0sICdjb250ZW50Jyk7XG4gICAgICAgICAgY29uZmlnLnRva2VucyA9IGRhdGFHZXR0ZXIoaXRlbSwgJ3Rva2VucycpO1xuICAgICAgICAgIGNvbmZpZy5zdWJ0ZXh0ID0gZGF0YUdldHRlcihpdGVtLCAnc3VidGV4dCcpO1xuICAgICAgICAgIGNvbmZpZy5pY29uID0gZGF0YUdldHRlcihpdGVtLCAnaWNvbicpO1xuXG4gICAgICAgICAgY29uZmlnLmRpc3BsYXkgPSBjb25maWcuY29udGVudCB8fCBjb25maWcudGV4dDtcbiAgICAgICAgICBjb25maWcudmFsdWUgPSBpdGVtLnZhbHVlID09PSB1bmRlZmluZWQgPyBpdGVtLnRleHQgOiBpdGVtLnZhbHVlO1xuICAgICAgICAgIGNvbmZpZy50eXBlID0gJ29wdGlvbic7XG4gICAgICAgICAgY29uZmlnLmluZGV4ID0gbGlJbmRleDtcblxuICAgICAgICAgIGNvbmZpZy5vcHRpb24gPSAhaXRlbS5vcHRpb24gPyBpdGVtIDogaXRlbS5vcHRpb247IC8vIHJlZmVyZW5jZSBvcHRpb24gZWxlbWVudCBpZiBpdCBleGlzdHNcbiAgICAgICAgICBjb25maWcub3B0aW9uLmxpSW5kZXggPSBsaUluZGV4O1xuICAgICAgICAgIGNvbmZpZy5zZWxlY3RlZCA9ICEhaXRlbS5zZWxlY3RlZDtcbiAgICAgICAgICBjb25maWcuZGlzYWJsZWQgPSBjb25maWcuZGlzYWJsZWQgfHwgISFpdGVtLmRpc2FibGVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RwaWNrZXIub3B0aW9uVmFsdWVzRGF0YU1hcFtjb25maWcudmFsdWVdKSB7XG4gICAgICAgICAgICAgIGNvbmZpZyA9ICQuZXh0ZW5kKHRoYXQuc2VsZWN0cGlja2VyLm9wdGlvblZhbHVlc0RhdGFNYXBbY29uZmlnLnZhbHVlXSwgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLm9wdGlvblZhbHVlc0RhdGFNYXBbY29uZmlnLnZhbHVlXSA9IGNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYWluRGF0YS5wdXNoKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkT3B0Z3JvdXAgKGluZGV4LCBzZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRncm91cCA9IHNlbGVjdE9wdGlvbnNbaW5kZXhdLFxuICAgICAgICAgICAgLy8gc2tpcCBwbGFjZWhvbGRlciBvcHRpb25cbiAgICAgICAgICAgIHByZXZpb3VzID0gaW5kZXggLSAxIDwgc3RhcnRJbmRleCA/IGZhbHNlIDogc2VsZWN0T3B0aW9uc1tpbmRleCAtIDFdLFxuICAgICAgICAgICAgbmV4dCA9IHNlbGVjdE9wdGlvbnNbaW5kZXggKyAxXSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkYXRhID8gb3B0Z3JvdXAuY2hpbGRyZW4uZmlsdGVyKGZpbHRlckhpZGRlbiwgdGhpcykgOiBvcHRncm91cC5xdWVyeVNlbGVjdG9yQWxsKCdvcHRpb24nICsgb3B0aW9uU2VsZWN0b3IpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBodG1sRXNjYXBlKGRhdGFHZXR0ZXIoaXRlbSwgJ2xhYmVsJykpLFxuICAgICAgICAgICAgICBzdWJ0ZXh0OiBkYXRhR2V0dGVyKG9wdGdyb3VwLCAnc3VidGV4dCcpLFxuICAgICAgICAgICAgICBpY29uOiBkYXRhR2V0dGVyKG9wdGdyb3VwLCAnaWNvbicpLFxuICAgICAgICAgICAgICB0eXBlOiAnb3B0Z3JvdXAtbGFiZWwnLFxuICAgICAgICAgICAgICBvcHRncm91cENsYXNzOiAnICcgKyAob3B0Z3JvdXAuY2xhc3NOYW1lIHx8ICcnKSxcbiAgICAgICAgICAgICAgb3B0Z3JvdXA6IG9wdGdyb3VwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVySW5kZXgsXG4gICAgICAgICAgICBsYXN0SW5kZXg7XG5cbiAgICAgICAgb3B0SUQrKztcblxuICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICBhZGREaXZpZGVyKHsgb3B0SUQ6IG9wdElEIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLm9wdElEID0gb3B0SUQ7XG5cbiAgICAgICAgbWFpbkRhdGEucHVzaChjb25maWcpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBvcHRpb25zLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbal07XG5cbiAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgaGVhZGVySW5kZXggPSBtYWluRGF0YS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gaGVhZGVySW5kZXggKyBsZW47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkT3B0aW9uKG9wdGlvbiwge1xuICAgICAgICAgICAgaGVhZGVySW5kZXg6IGhlYWRlckluZGV4LFxuICAgICAgICAgICAgbGFzdEluZGV4OiBsYXN0SW5kZXgsXG4gICAgICAgICAgICBvcHRJRDogY29uZmlnLm9wdElELFxuICAgICAgICAgICAgb3B0Z3JvdXBDbGFzczogY29uZmlnLm9wdGdyb3VwQ2xhc3MsXG4gICAgICAgICAgICBkaXNhYmxlZDogb3B0Z3JvdXAuZGlzYWJsZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgYWRkRGl2aWRlcih7IG9wdElEOiBvcHRJRCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBsZW4gPSBzZWxlY3RPcHRpb25zLmxlbmd0aCwgaSA9IHN0YXJ0SW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdE9wdGlvbnNbaV0sXG4gICAgICAgICAgICBjaGlsZHJlbiA9IGl0ZW0uY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIGFkZE9wdGdyb3VwLmNhbGwodGhpcywgaSwgc2VsZWN0T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkT3B0aW9uLmNhbGwodGhpcywgaXRlbSwge30pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkYXRhJzoge1xuICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmRhdGEgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhLCBtYWluRGF0YSk7XG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhID0gdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NlYXJjaCc6IHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnNlbGVjdHBpY2tlci5zZWFyY2guZGF0YSwgbWFpbkRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYWluRGF0YTtcbiAgICB9LFxuXG4gICAgYnVpbGRMaXN0OiBmdW5jdGlvbiAoc2l6ZSwgc2VhcmNoaW5nKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgc2VsZWN0RGF0YSA9IHNlYXJjaGluZyA/IHRoaXMuc2VsZWN0cGlja2VyLnNlYXJjaC5kYXRhIDogdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhLFxuICAgICAgICAgIG1haW5FbGVtZW50cyA9IFtdLFxuICAgICAgICAgIHdpZGVzdE9wdGlvbkxlbmd0aCA9IDA7XG5cbiAgICAgIGlmICgodGhhdC5vcHRpb25zLnNob3dUaWNrIHx8IHRoYXQubXVsdGlwbGUpICYmICFlbGVtZW50VGVtcGxhdGVzLmNoZWNrTWFyay5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuY2hlY2tNYXJrLmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5pY29uQmFzZSArICcgJyArIHRoYXQub3B0aW9ucy50aWNrSWNvbiArICcgY2hlY2stbWFyayc7XG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuYS5hcHBlbmRDaGlsZChlbGVtZW50VGVtcGxhdGVzLmNoZWNrTWFyayk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkRWxlbWVudCAobWFpbkVsZW1lbnRzLCBpdGVtKSB7XG4gICAgICAgIHZhciBsaUVsZW1lbnQsXG4gICAgICAgICAgICBjb21iaW5lZExlbmd0aCA9IDA7XG5cbiAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkaXZpZGVyJzpcbiAgICAgICAgICAgIGxpRWxlbWVudCA9IGdlbmVyYXRlT3B0aW9uLmxpKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lcy5ESVZJREVSLFxuICAgICAgICAgICAgICAoaXRlbS5vcHRJRCA/IGl0ZW0ub3B0SUQgKyAnZGl2JyA6IHVuZGVmaW5lZClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgICAgIGxpRWxlbWVudCA9IGdlbmVyYXRlT3B0aW9uLmxpKFxuICAgICAgICAgICAgICBnZW5lcmF0ZU9wdGlvbi5hKFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlT3B0aW9uLnRleHQuY2FsbCh0aGF0LCBpdGVtKSxcbiAgICAgICAgICAgICAgICBpdGVtLm9wdGlvbkNsYXNzLFxuICAgICAgICAgICAgICAgIGl0ZW0uaW5saW5lU3R5bGVcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgIGl0ZW0ub3B0SURcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChsaUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICBsaUVsZW1lbnQuZmlyc3RDaGlsZC5pZCA9IHRoYXQuc2VsZWN0SWQgKyAnLScgKyBpdGVtLmluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ29wdGdyb3VwLWxhYmVsJzpcbiAgICAgICAgICAgIGxpRWxlbWVudCA9IGdlbmVyYXRlT3B0aW9uLmxpKFxuICAgICAgICAgICAgICBnZW5lcmF0ZU9wdGlvbi5sYWJlbC5jYWxsKHRoYXQsIGl0ZW0pLFxuICAgICAgICAgICAgICAnZHJvcGRvd24taGVhZGVyJyArIGl0ZW0ub3B0Z3JvdXBDbGFzcyxcbiAgICAgICAgICAgICAgaXRlbS5vcHRJRFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWl0ZW0uZWxlbWVudCkge1xuICAgICAgICAgIGl0ZW0uZWxlbWVudCA9IGxpRWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmVsZW1lbnQuaW5uZXJIVE1MID0gbGlFbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICBtYWluRWxlbWVudHMucHVzaChpdGVtLmVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgb3B0aW9uIC0gbm90IHBlcmZlY3QsIGJ1dCBzaG91bGQgd29yayBpbiBtb3N0IGNhc2VzXG4gICAgICAgIGlmIChpdGVtLmRpc3BsYXkpIGNvbWJpbmVkTGVuZ3RoICs9IGl0ZW0uZGlzcGxheS5sZW5ndGg7XG4gICAgICAgIGlmIChpdGVtLnN1YnRleHQpIGNvbWJpbmVkTGVuZ3RoICs9IGl0ZW0uc3VidGV4dC5sZW5ndGg7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGljb24sIGVuc3VyZSB0aGlzIG9wdGlvbidzIHdpZHRoIGlzIGNoZWNrZWRcbiAgICAgICAgaWYgKGl0ZW0uaWNvbikgY29tYmluZWRMZW5ndGggKz0gMTtcblxuICAgICAgICBpZiAoY29tYmluZWRMZW5ndGggPiB3aWRlc3RPcHRpb25MZW5ndGgpIHtcbiAgICAgICAgICB3aWRlc3RPcHRpb25MZW5ndGggPSBjb21iaW5lZExlbmd0aDtcblxuICAgICAgICAgIC8vIGd1ZXNzIHdoaWNoIG9wdGlvbiBpcyB0aGUgd2lkZXN0XG4gICAgICAgICAgLy8gdXNlIHRoaXMgd2hlbiBjYWxjdWxhdGluZyBtZW51IHdpZHRoXG4gICAgICAgICAgLy8gbm90IHBlcmZlY3QsIGJ1dCBpdCdzIGZhc3QsIGFuZCB0aGUgd2lkdGggd2lsbCBiZSB1cGRhdGluZyBhY2NvcmRpbmdseSB3aGVuIHNjcm9sbGluZ1xuICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcud2lkZXN0T3B0aW9uID0gbWFpbkVsZW1lbnRzW21haW5FbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRJbmRleCA9IHNpemUgfHwgMDtcblxuICAgICAgZm9yICh2YXIgbGVuID0gc2VsZWN0RGF0YS5sZW5ndGgsIGkgPSBzdGFydEluZGV4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzZWxlY3REYXRhW2ldO1xuXG4gICAgICAgIGJ1aWxkRWxlbWVudChtYWluRWxlbWVudHMsIGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2VhcmNoaW5nKSB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5zZWxlY3RwaWNrZXIuc2VhcmNoLmVsZW1lbnRzLCBtYWluRWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHMsIG1haW5FbGVtZW50cyk7XG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cyA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzZWFyY2hpbmcpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci5zZWFyY2guZWxlbWVudHMgPSBtYWluRWxlbWVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50cyA9IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMgPSBtYWluRWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluZExpczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJG1lbnVJbm5lci5maW5kKCcuaW5uZXIgPiBsaScpO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIChpbml0KSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnRbMF0sXG4gICAgICAgICAgLy8gZW5zdXJlIHRpdGxlT3B0aW9uIGlzIGFwcGVuZGVkIGFuZCBzZWxlY3RlZCAoaWYgbmVjZXNzYXJ5KSBiZWZvcmUgZ2V0dGluZyBzZWxlY3RlZE9wdGlvbnNcbiAgICAgICAgICBwbGFjZWhvbGRlclNlbGVjdGVkID0gdGhpcy5zZXRQbGFjZWhvbGRlcigpICYmIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9PT0gMCxcbiAgICAgICAgICBzZWxlY3RlZE9wdGlvbnMgPSBnZXRTZWxlY3RlZE9wdGlvbnMuY2FsbCh0aGlzKSxcbiAgICAgICAgICBzZWxlY3RlZENvdW50ID0gc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCxcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFNlbGVjdFZhbHVlcy5jYWxsKHRoaXMsIHNlbGVjdGVkT3B0aW9ucyksXG4gICAgICAgICAgYnV0dG9uID0gdGhpcy4kYnV0dG9uWzBdLFxuICAgICAgICAgIGJ1dHRvbklubmVyID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItb3B0aW9uLWlubmVyLWlubmVyJyksXG4gICAgICAgICAgbXVsdGlwbGVTZXBhcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9wdGlvbnMubXVsdGlwbGVTZXBhcmF0b3IpLFxuICAgICAgICAgIHRpdGxlRnJhZ21lbnQgPSBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgc2hvd0NvdW50LFxuICAgICAgICAgIGNvdW50TWF4LFxuICAgICAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlU2VsZWN0ZWQgKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGF0LmNyZWF0ZU9wdGlvbihpdGVtLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgaXRlbS5jaGlsZHJlbi5tYXAoY3JlYXRlU2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHMgdG8gZW5zdXJlIHNlbGVjdCB2YWx1ZSBpcyBjb3JyZWN0XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZS5kYXRhICYmIGluaXQpIHtcbiAgICAgICAgc2VsZWN0ZWRPcHRpb25zLm1hcChjcmVhdGVTZWxlY3RlZCk7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RwaWNrZXIubWFpbi5vcHRpb25RdWV1ZSk7XG5cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyU2VsZWN0ZWQpIHBsYWNlaG9sZGVyU2VsZWN0ZWQgPSBlbGVtZW50LnNlbGVjdGVkSW5kZXggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKCdicy1wbGFjZWhvbGRlcicsIHRoYXQubXVsdGlwbGUgPyAhc2VsZWN0ZWRDb3VudCA6ICFzZWxlY3RlZFZhbHVlcyAmJiBzZWxlY3RlZFZhbHVlcyAhPT0gMCk7XG5cbiAgICAgIGlmICghdGhhdC5tdWx0aXBsZSAmJiBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuZGlzcGxheWVkVmFsdWUgPSBzZWxlY3RlZFZhbHVlcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRpdGxlRnJhZ21lbnQgPSBnZW5lcmF0ZU9wdGlvbi50ZXh0LmNhbGwodGhpcywgeyB0ZXh0OiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIgfSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG93Q291bnQgPSB0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQuaW5kZXhPZignY291bnQnKSAhPT0gLTEgJiYgc2VsZWN0ZWRDb3VudCA+IDA7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgb3B0aW9ucyB3aWxsIGJlIHNob3duIChzaG93Q291bnQgPT09IHRydWUpXG4gICAgICAgIGlmIChzaG93Q291bnQpIHtcbiAgICAgICAgICBjb3VudE1heCA9IHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQuc3BsaXQoJz4nKTtcbiAgICAgICAgICBzaG93Q291bnQgPSAoY291bnRNYXgubGVuZ3RoID4gMSAmJiBzZWxlY3RlZENvdW50ID4gY291bnRNYXhbMV0pIHx8IChjb3VudE1heC5sZW5ndGggPT09IDEgJiYgc2VsZWN0ZWRDb3VudCA+PSAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgbG9vcCB0aHJvdWdoIGFsbCBzZWxlY3RlZCBvcHRpb25zIGlmIHRoZSBjb3VudCB3b24ndCBiZSBzaG93blxuICAgICAgICBpZiAoc2hvd0NvdW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIGlmICghcGxhY2Vob2xkZXJTZWxlY3RlZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgc2VsZWN0ZWRJbmRleCA9IDA7IHNlbGVjdGVkSW5kZXggPCBzZWxlY3RlZENvdW50OyBzZWxlY3RlZEluZGV4KyspIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPCA1MCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBzZWxlY3RlZE9wdGlvbnNbc2VsZWN0ZWRJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlT3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUgJiYgc2VsZWN0ZWRJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVGcmFnbWVudC5hcHBlbmRDaGlsZChtdWx0aXBsZVNlcGFyYXRvci5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi50aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZU9wdGlvbnMudGV4dCA9IG9wdGlvbi50aXRsZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLmNvbnRlbnQgJiYgdGhhdC5vcHRpb25zLnNob3dDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlT3B0aW9ucy5jb250ZW50ID0gb3B0aW9uLmNvbnRlbnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNob3dJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGVPcHRpb25zLmljb24gPSBvcHRpb24uaWNvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNob3dTdWJ0ZXh0ICYmICF0aGF0Lm11bHRpcGxlICYmIG9wdGlvbi5zdWJ0ZXh0KSB0aXRsZU9wdGlvbnMuc3VidGV4dCA9ICcgJyArIG9wdGlvbi5zdWJ0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aXRsZU9wdGlvbnMudGV4dCA9IG9wdGlvbi50ZXh0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdGl0bGVGcmFnbWVudC5hcHBlbmRDaGlsZChnZW5lcmF0ZU9wdGlvbi50ZXh0LmNhbGwodGhpcywgdGl0bGVPcHRpb25zLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBlbGxpcHNpc1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ291bnQgPiA0OSkge1xuICAgICAgICAgICAgICB0aXRsZUZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcuLi4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcHRpb25TZWxlY3RvciA9ICc6bm90KFtoaWRkZW5dKTpub3QoW2RhdGEtaGlkZGVuPVwidHJ1ZVwiXSk6bm90KFtkYXRhLWRpdmlkZXI9XCJ0cnVlXCJdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6IG5vbmVcIl0pJztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZGVEaXNhYmxlZCkgb3B0aW9uU2VsZWN0b3IgKz0gJzpub3QoOmRpc2FibGVkKSc7XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbXVsdGlzZWxlY3QsIGFuZCBzZWxlY3RlZFRleHRGb3JtYXQgaXMgY291bnQsIHRoZW4gc2hvdyAxIG9mIDIgc2VsZWN0ZWQsIGV0Yy5cbiAgICAgICAgICB2YXIgdG90YWxDb3VudCA9IHRoaXMuJGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0ID4gb3B0aW9uJyArIG9wdGlvblNlbGVjdG9yICsgJywgb3B0Z3JvdXAnICsgb3B0aW9uU2VsZWN0b3IgKyAnIG9wdGlvbicgKyBvcHRpb25TZWxlY3RvcikubGVuZ3RoLFxuICAgICAgICAgICAgICB0cjhuVGV4dCA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLmNvdW50U2VsZWN0ZWRUZXh0ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMub3B0aW9ucy5jb3VudFNlbGVjdGVkVGV4dChzZWxlY3RlZENvdW50LCB0b3RhbENvdW50KSA6IHRoaXMub3B0aW9ucy5jb3VudFNlbGVjdGVkVGV4dDtcblxuICAgICAgICAgIHRpdGxlRnJhZ21lbnQgPSBnZW5lcmF0ZU9wdGlvbi50ZXh0LmNhbGwodGhpcywge1xuICAgICAgICAgICAgdGV4dDogdHI4blRleHQucmVwbGFjZSgnezB9Jywgc2VsZWN0ZWRDb3VudC50b1N0cmluZygpKS5yZXBsYWNlKCd7MX0nLCB0b3RhbENvdW50LnRvU3RyaW5nKCkpXG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHNlbGVjdCBkb2Vzbid0IGhhdmUgYSB0aXRsZSwgdGhlbiB1c2UgdGhlIGRlZmF1bHQsIG9yIGlmIG5vdGhpbmcgaXMgc2V0IGF0IGFsbCwgdXNlIG5vbmVTZWxlY3RlZFRleHRcbiAgICAgIGlmICghdGl0bGVGcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICB0aXRsZUZyYWdtZW50ID0gZ2VuZXJhdGVPcHRpb24udGV4dC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIgPyB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIgOiB0aGlzLm9wdGlvbnMubm9uZVNlbGVjdGVkVGV4dFxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIHNlbGVjdCBoYXMgYSB0aXRsZSwgYXBwbHkgaXQgdG8gdGhlIGJ1dHRvbiwgYW5kIGlmIG5vdCwgYXBwbHkgdGl0bGVGcmFnbWVudCB0ZXh0XG4gICAgICAvLyBzdHJpcCBhbGwgSFRNTCB0YWdzIGFuZCB0cmltIHRoZSByZXN1bHQsIHRoZW4gdW5lc2NhcGUgYW55IGVzY2FwZWQgdGFnc1xuICAgICAgYnV0dG9uLnRpdGxlID0gdGl0bGVGcmFnbWVudC50ZXh0Q29udGVudC5yZXBsYWNlKC88W14+XSo+Py9nLCAnJykudHJpbSgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNhbml0aXplICYmIGhhc0NvbnRlbnQpIHtcbiAgICAgICAgc2FuaXRpemVIdG1sKFt0aXRsZUZyYWdtZW50XSwgdGhhdC5vcHRpb25zLndoaXRlTGlzdCwgdGhhdC5vcHRpb25zLnNhbml0aXplRm4pO1xuICAgICAgfVxuXG4gICAgICBidXR0b25Jbm5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgIGJ1dHRvbklubmVyLmFwcGVuZENoaWxkKHRpdGxlRnJhZ21lbnQpO1xuXG4gICAgICBpZiAodmVyc2lvbi5tYWpvciA8IDQgJiYgdGhpcy4kbmV3RWxlbWVudFswXS5jbGFzc0xpc3QuY29udGFpbnMoJ2JzMy1oYXMtYWRkb24nKSkge1xuICAgICAgICB2YXIgZmlsdGVyRXhwYW5kID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItZXhwYW5kJyksXG4gICAgICAgICAgICBjbG9uZSA9IGJ1dHRvbklubmVyLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICBjbG9uZS5jbGFzc05hbWUgPSAnZmlsdGVyLWV4cGFuZCc7XG5cbiAgICAgICAgaWYgKGZpbHRlckV4cGFuZCkge1xuICAgICAgICAgIGJ1dHRvbi5yZXBsYWNlQ2hpbGQoY2xvbmUsIGZpbHRlckV4cGFuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3JlbmRlcmVkJyArIEVWRU5UX0tFWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBbc3R5bGVdXG4gICAgICogQHBhcmFtIFtzdGF0dXNdXG4gICAgICovXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChuZXdTdHlsZSwgc3RhdHVzKSB7XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy4kYnV0dG9uWzBdLFxuICAgICAgICAgIG5ld0VsZW1lbnQgPSB0aGlzLiRuZXdFbGVtZW50WzBdLFxuICAgICAgICAgIHN0eWxlID0gdGhpcy5vcHRpb25zLnN0eWxlLnRyaW0oKSxcbiAgICAgICAgICBidXR0b25DbGFzcztcblxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnKSkge1xuICAgICAgICB0aGlzLiRuZXdFbGVtZW50LmFkZENsYXNzKHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnKS5yZXBsYWNlKC9zZWxlY3RwaWNrZXJ8bW9iaWxlLWRldmljZXxicy1zZWxlY3QtaGlkZGVufHZhbGlkYXRlXFxbLipcXF0vZ2ksICcnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJzaW9uLm1ham9yIDwgNCkge1xuICAgICAgICBuZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2JzMycpO1xuXG4gICAgICAgIGlmIChuZXdFbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0ICYmIG5ld0VsZW1lbnQucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2lucHV0LWdyb3VwJykgJiZcbiAgICAgICAgICAgIChuZXdFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgfHwgbmV3RWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpICYmXG4gICAgICAgICAgICAobmV3RWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIHx8IG5ld0VsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5jbGFzc0xpc3QuY29udGFpbnMoJ2lucHV0LWdyb3VwLWFkZG9uJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgbmV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiczMtaGFzLWFkZG9uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1N0eWxlKSB7XG4gICAgICAgIGJ1dHRvbkNsYXNzID0gbmV3U3R5bGUudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnV0dG9uQ2xhc3MgPSBzdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXR1cyA9PSAnYWRkJykge1xuICAgICAgICBpZiAoYnV0dG9uQ2xhc3MpIGJ1dHRvbi5jbGFzc0xpc3QuYWRkLmFwcGx5KGJ1dHRvbi5jbGFzc0xpc3QsIGJ1dHRvbkNsYXNzLnNwbGl0KCcgJykpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ3JlbW92ZScpIHtcbiAgICAgICAgaWYgKGJ1dHRvbkNsYXNzKSBidXR0b24uY2xhc3NMaXN0LnJlbW92ZS5hcHBseShidXR0b24uY2xhc3NMaXN0LCBidXR0b25DbGFzcy5zcGxpdCgnICcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdHlsZSkgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUuYXBwbHkoYnV0dG9uLmNsYXNzTGlzdCwgc3R5bGUuc3BsaXQoJyAnKSk7XG4gICAgICAgIGlmIChidXR0b25DbGFzcykgYnV0dG9uLmNsYXNzTGlzdC5hZGQuYXBwbHkoYnV0dG9uLmNsYXNzTGlzdCwgYnV0dG9uQ2xhc3Muc3BsaXQoJyAnKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGxpSGVpZ2h0OiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgICAgaWYgKCFyZWZyZXNoICYmICh0aGlzLm9wdGlvbnMuc2l6ZSA9PT0gZmFsc2UgfHwgT2JqZWN0LmtleXModGhpcy5zaXplSW5mbykubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgbmV3RWxlbWVudCA9IGVsZW1lbnRUZW1wbGF0ZXMuZGl2LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgbWVudSA9IGVsZW1lbnRUZW1wbGF0ZXMuZGl2LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgbWVudUlubmVyID0gZWxlbWVudFRlbXBsYXRlcy5kaXYuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICBtZW51SW5uZXJJbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyksXG4gICAgICAgICAgZGl2aWRlciA9IGVsZW1lbnRUZW1wbGF0ZXMubGkuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICBkcm9wZG93bkhlYWRlciA9IGVsZW1lbnRUZW1wbGF0ZXMubGkuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICBsaSxcbiAgICAgICAgICBhID0gZWxlbWVudFRlbXBsYXRlcy5hLmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgdGV4dCA9IGVsZW1lbnRUZW1wbGF0ZXMuc3Bhbi5jbG9uZU5vZGUoZmFsc2UpLFxuICAgICAgICAgIGhlYWRlciA9IHRoaXMub3B0aW9ucy5oZWFkZXIgJiYgdGhpcy4kbWVudS5maW5kKCcuJyArIGNsYXNzTmFtZXMuUE9QT1ZFUkhFQURFUikubGVuZ3RoID4gMCA/IHRoaXMuJG1lbnUuZmluZCgnLicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIpWzBdLmNsb25lTm9kZSh0cnVlKSA6IG51bGwsXG4gICAgICAgICAgc2VhcmNoID0gdGhpcy5vcHRpb25zLmxpdmVTZWFyY2ggPyBlbGVtZW50VGVtcGxhdGVzLmRpdi5jbG9uZU5vZGUoZmFsc2UpIDogbnVsbCxcbiAgICAgICAgICBhY3Rpb25zID0gdGhpcy5vcHRpb25zLmFjdGlvbnNCb3ggJiYgdGhpcy5tdWx0aXBsZSAmJiB0aGlzLiRtZW51LmZpbmQoJy5icy1hY3Rpb25zYm94JykubGVuZ3RoID4gMCA/IHRoaXMuJG1lbnUuZmluZCgnLmJzLWFjdGlvbnNib3gnKVswXS5jbG9uZU5vZGUodHJ1ZSkgOiBudWxsLFxuICAgICAgICAgIGRvbmVCdXR0b24gPSB0aGlzLm9wdGlvbnMuZG9uZUJ1dHRvbiAmJiB0aGlzLm11bHRpcGxlICYmIHRoaXMuJG1lbnUuZmluZCgnLmJzLWRvbmVidXR0b24nKS5sZW5ndGggPiAwID8gdGhpcy4kbWVudS5maW5kKCcuYnMtZG9uZWJ1dHRvbicpWzBdLmNsb25lTm9kZSh0cnVlKSA6IG51bGwsXG4gICAgICAgICAgZmlyc3RPcHRpb24gPSB0aGlzLiRlbGVtZW50WzBdLm9wdGlvbnNbMF07XG5cbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0V2lkdGggPSB0aGlzLiRuZXdFbGVtZW50WzBdLm9mZnNldFdpZHRoO1xuXG4gICAgICB0ZXh0LmNsYXNzTmFtZSA9ICd0ZXh0JztcbiAgICAgIGEuY2xhc3NOYW1lID0gJ2Ryb3Bkb3duLWl0ZW0gJyArIChmaXJzdE9wdGlvbiA/IGZpcnN0T3B0aW9uLmNsYXNzTmFtZSA6ICcnKTtcbiAgICAgIG5ld0VsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy4kbWVudVswXS5wYXJlbnROb2RlLmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZXMuU0hPVztcbiAgICAgIG5ld0VsZW1lbnQuc3R5bGUud2lkdGggPSAwOyAvLyBlbnN1cmUgYnV0dG9uIHdpZHRoIGRvZXNuJ3QgYWZmZWN0IG5hdHVyYWwgd2lkdGggb2YgbWVudSB3aGVuIGNhbGN1bGF0aW5nXG4gICAgICBpZiAodGhpcy5vcHRpb25zLndpZHRoID09PSAnYXV0bycpIG1lbnUuc3R5bGUubWluV2lkdGggPSAwO1xuICAgICAgbWVudS5jbGFzc05hbWUgPSBjbGFzc05hbWVzLk1FTlUgKyAnICcgKyBjbGFzc05hbWVzLlNIT1c7XG4gICAgICBtZW51SW5uZXIuY2xhc3NOYW1lID0gJ2lubmVyICcgKyBjbGFzc05hbWVzLlNIT1c7XG4gICAgICBtZW51SW5uZXJJbm5lci5jbGFzc05hbWUgPSBjbGFzc05hbWVzLk1FTlUgKyAnIGlubmVyICcgKyAodmVyc2lvbi5tYWpvciA+PSAnNCcgPyBjbGFzc05hbWVzLlNIT1cgOiAnJyk7XG4gICAgICBkaXZpZGVyLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuRElWSURFUjtcbiAgICAgIGRyb3Bkb3duSGVhZGVyLmNsYXNzTmFtZSA9ICdkcm9wZG93bi1oZWFkZXInO1xuXG4gICAgICB0ZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDBiJykpO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2ldO1xuICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdvcHRpb24nICYmICQoZGF0YS5lbGVtZW50LmZpcnN0Q2hpbGQpLmNzcygnZGlzcGxheScpICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGxpID0gZGF0YS5lbGVtZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaSA9IGVsZW1lbnRUZW1wbGF0ZXMubGkuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgYS5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICB9XG5cbiAgICAgIGRyb3Bkb3duSGVhZGVyLmFwcGVuZENoaWxkKHRleHQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLnZpZXcud2lkZXN0T3B0aW9uKSB7XG4gICAgICAgIG1lbnVJbm5lcklubmVyLmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0cGlja2VyLnZpZXcud2lkZXN0T3B0aW9uLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIG1lbnVJbm5lcklubmVyLmFwcGVuZENoaWxkKGxpKTtcbiAgICAgIG1lbnVJbm5lcklubmVyLmFwcGVuZENoaWxkKGRpdmlkZXIpO1xuICAgICAgbWVudUlubmVySW5uZXIuYXBwZW5kQ2hpbGQoZHJvcGRvd25IZWFkZXIpO1xuICAgICAgaWYgKGhlYWRlcikgbWVudS5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBzZWFyY2guY2xhc3NOYW1lID0gJ2JzLXNlYXJjaGJveCc7XG4gICAgICAgIGlucHV0LmNsYXNzTmFtZSA9ICdmb3JtLWNvbnRyb2wnO1xuICAgICAgICBzZWFyY2guYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICBtZW51LmFwcGVuZENoaWxkKHNlYXJjaCk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9ucykgbWVudS5hcHBlbmRDaGlsZChhY3Rpb25zKTtcbiAgICAgIG1lbnVJbm5lci5hcHBlbmRDaGlsZChtZW51SW5uZXJJbm5lcik7XG4gICAgICBtZW51LmFwcGVuZENoaWxkKG1lbnVJbm5lcik7XG4gICAgICBpZiAoZG9uZUJ1dHRvbikgbWVudS5hcHBlbmRDaGlsZChkb25lQnV0dG9uKTtcbiAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQobWVudSk7XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobmV3RWxlbWVudCk7XG5cbiAgICAgIHZhciBsaUhlaWdodCA9IGxpLm9mZnNldEhlaWdodCxcbiAgICAgICAgICBkcm9wZG93bkhlYWRlckhlaWdodCA9IGRyb3Bkb3duSGVhZGVyID8gZHJvcGRvd25IZWFkZXIub2Zmc2V0SGVpZ2h0IDogMCxcbiAgICAgICAgICBoZWFkZXJIZWlnaHQgPSBoZWFkZXIgPyBoZWFkZXIub2Zmc2V0SGVpZ2h0IDogMCxcbiAgICAgICAgICBzZWFyY2hIZWlnaHQgPSBzZWFyY2ggPyBzZWFyY2gub2Zmc2V0SGVpZ2h0IDogMCxcbiAgICAgICAgICBhY3Rpb25zSGVpZ2h0ID0gYWN0aW9ucyA/IGFjdGlvbnMub2Zmc2V0SGVpZ2h0IDogMCxcbiAgICAgICAgICBkb25lQnV0dG9uSGVpZ2h0ID0gZG9uZUJ1dHRvbiA/IGRvbmVCdXR0b24ub2Zmc2V0SGVpZ2h0IDogMCxcbiAgICAgICAgICBkaXZpZGVySGVpZ2h0ID0gJChkaXZpZGVyKS5vdXRlckhlaWdodCh0cnVlKSxcbiAgICAgICAgICBtZW51U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShtZW51KSxcbiAgICAgICAgICBtZW51V2lkdGggPSBtZW51Lm9mZnNldFdpZHRoLFxuICAgICAgICAgIG1lbnVQYWRkaW5nID0ge1xuICAgICAgICAgICAgdmVydDogdG9JbnRlZ2VyKG1lbnVTdHlsZS5wYWRkaW5nVG9wKSArXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlLnBhZGRpbmdCb3R0b20pICtcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUuYm9yZGVyVG9wV2lkdGgpICtcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpLFxuICAgICAgICAgICAgaG9yaXo6IHRvSW50ZWdlcihtZW51U3R5bGUucGFkZGluZ0xlZnQpICtcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUucGFkZGluZ1JpZ2h0KSArXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlLmJvcmRlckxlZnRXaWR0aCkgK1xuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZS5ib3JkZXJSaWdodFdpZHRoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWVudUV4dHJhcyA9IHtcbiAgICAgICAgICAgIHZlcnQ6IG1lbnVQYWRkaW5nLnZlcnQgK1xuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZS5tYXJnaW5Ub3ApICtcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUubWFyZ2luQm90dG9tKSArIDIsXG4gICAgICAgICAgICBob3JpejogbWVudVBhZGRpbmcuaG9yaXogK1xuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZS5tYXJnaW5MZWZ0KSArXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlLm1hcmdpblJpZ2h0KSArIDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNjcm9sbEJhcldpZHRoO1xuXG4gICAgICBtZW51SW5uZXIuc3R5bGUub3ZlcmZsb3dZID0gJ3Njcm9sbCc7XG5cbiAgICAgIHNjcm9sbEJhcldpZHRoID0gbWVudS5vZmZzZXRXaWR0aCAtIG1lbnVXaWR0aDtcblxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChuZXdFbGVtZW50KTtcblxuICAgICAgdGhpcy5zaXplSW5mby5saUhlaWdodCA9IGxpSGVpZ2h0O1xuICAgICAgdGhpcy5zaXplSW5mby5kcm9wZG93bkhlYWRlckhlaWdodCA9IGRyb3Bkb3duSGVhZGVySGVpZ2h0O1xuICAgICAgdGhpcy5zaXplSW5mby5oZWFkZXJIZWlnaHQgPSBoZWFkZXJIZWlnaHQ7XG4gICAgICB0aGlzLnNpemVJbmZvLnNlYXJjaEhlaWdodCA9IHNlYXJjaEhlaWdodDtcbiAgICAgIHRoaXMuc2l6ZUluZm8uYWN0aW9uc0hlaWdodCA9IGFjdGlvbnNIZWlnaHQ7XG4gICAgICB0aGlzLnNpemVJbmZvLmRvbmVCdXR0b25IZWlnaHQgPSBkb25lQnV0dG9uSGVpZ2h0O1xuICAgICAgdGhpcy5zaXplSW5mby5kaXZpZGVySGVpZ2h0ID0gZGl2aWRlckhlaWdodDtcbiAgICAgIHRoaXMuc2l6ZUluZm8ubWVudVBhZGRpbmcgPSBtZW51UGFkZGluZztcbiAgICAgIHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcyA9IG1lbnVFeHRyYXM7XG4gICAgICB0aGlzLnNpemVJbmZvLm1lbnVXaWR0aCA9IG1lbnVXaWR0aDtcbiAgICAgIHRoaXMuc2l6ZUluZm8ubWVudUlubmVySW5uZXJXaWR0aCA9IG1lbnVXaWR0aCAtIG1lbnVQYWRkaW5nLmhvcml6O1xuICAgICAgdGhpcy5zaXplSW5mby50b3RhbE1lbnVXaWR0aCA9IHRoaXMuc2l6ZUluZm8ubWVudVdpZHRoO1xuICAgICAgdGhpcy5zaXplSW5mby5zY3JvbGxCYXJXaWR0aCA9IHNjcm9sbEJhcldpZHRoO1xuICAgICAgdGhpcy5zaXplSW5mby5zZWxlY3RIZWlnaHQgPSB0aGlzLiRuZXdFbGVtZW50WzBdLm9mZnNldEhlaWdodDtcblxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkRhdGEoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAkd2luZG93ID0gJCh3aW5kb3cpLFxuICAgICAgICAgIHBvcyA9IHRoYXQuJG5ld0VsZW1lbnQub2Zmc2V0KCksXG4gICAgICAgICAgJGNvbnRhaW5lciA9ICQodGhhdC5vcHRpb25zLmNvbnRhaW5lciksXG4gICAgICAgICAgY29udGFpbmVyUG9zO1xuXG4gICAgICBpZiAodGhhdC5vcHRpb25zLmNvbnRhaW5lciAmJiAkY29udGFpbmVyLmxlbmd0aCAmJiAhJGNvbnRhaW5lci5pcygnYm9keScpKSB7XG4gICAgICAgIGNvbnRhaW5lclBvcyA9ICRjb250YWluZXIub2Zmc2V0KCk7XG4gICAgICAgIGNvbnRhaW5lclBvcy50b3AgKz0gcGFyc2VJbnQoJGNvbnRhaW5lci5jc3MoJ2JvcmRlclRvcFdpZHRoJykpO1xuICAgICAgICBjb250YWluZXJQb3MubGVmdCArPSBwYXJzZUludCgkY29udGFpbmVyLmNzcygnYm9yZGVyTGVmdFdpZHRoJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyUG9zID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpblBhZCA9IHRoYXQub3B0aW9ucy53aW5kb3dQYWRkaW5nO1xuXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFRvcCA9IHBvcy50b3AgLSBjb250YWluZXJQb3MudG9wIC0gJHdpbmRvdy5zY3JvbGxUb3AoKTtcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0Qm90ID0gJHdpbmRvdy5oZWlnaHQoKSAtIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0VG9wIC0gdGhpcy5zaXplSW5mby5zZWxlY3RIZWlnaHQgLSBjb250YWluZXJQb3MudG9wIC0gd2luUGFkWzJdO1xuICAgICAgdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRMZWZ0ID0gcG9zLmxlZnQgLSBjb250YWluZXJQb3MubGVmdCAtICR3aW5kb3cuc2Nyb2xsTGVmdCgpO1xuICAgICAgdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRSaWdodCA9ICR3aW5kb3cud2lkdGgoKSAtIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0TGVmdCAtIHRoaXMuc2l6ZUluZm8uc2VsZWN0V2lkdGggLSBjb250YWluZXJQb3MubGVmdCAtIHdpblBhZFsxXTtcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0VG9wIC09IHdpblBhZFswXTtcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0TGVmdCAtPSB3aW5QYWRbM107XG4gICAgfSxcblxuICAgIHNldE1lbnVTaXplOiBmdW5jdGlvbiAoaXNBdXRvKSB7XG4gICAgICB0aGlzLmdldFNlbGVjdFBvc2l0aW9uKCk7XG5cbiAgICAgIHZhciBzZWxlY3RXaWR0aCA9IHRoaXMuc2l6ZUluZm8uc2VsZWN0V2lkdGgsXG4gICAgICAgICAgbGlIZWlnaHQgPSB0aGlzLnNpemVJbmZvLmxpSGVpZ2h0LFxuICAgICAgICAgIGhlYWRlckhlaWdodCA9IHRoaXMuc2l6ZUluZm8uaGVhZGVySGVpZ2h0LFxuICAgICAgICAgIHNlYXJjaEhlaWdodCA9IHRoaXMuc2l6ZUluZm8uc2VhcmNoSGVpZ2h0LFxuICAgICAgICAgIGFjdGlvbnNIZWlnaHQgPSB0aGlzLnNpemVJbmZvLmFjdGlvbnNIZWlnaHQsXG4gICAgICAgICAgZG9uZUJ1dHRvbkhlaWdodCA9IHRoaXMuc2l6ZUluZm8uZG9uZUJ1dHRvbkhlaWdodCxcbiAgICAgICAgICBkaXZIZWlnaHQgPSB0aGlzLnNpemVJbmZvLmRpdmlkZXJIZWlnaHQsXG4gICAgICAgICAgbWVudVBhZGRpbmcgPSB0aGlzLnNpemVJbmZvLm1lbnVQYWRkaW5nLFxuICAgICAgICAgIG1lbnVJbm5lckhlaWdodCxcbiAgICAgICAgICBtZW51SGVpZ2h0LFxuICAgICAgICAgIGRpdkxlbmd0aCA9IDAsXG4gICAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICAgIF9taW5IZWlnaHQsXG4gICAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICAgIG1lbnVJbm5lck1pbkhlaWdodCxcbiAgICAgICAgICBlc3RpbWF0ZSxcbiAgICAgICAgICBpc0Ryb3B1cDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wdXBBdXRvKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZXN0aW1hdGVkIGhlaWdodCBvZiB0aGUgbWVudSB3aXRob3V0IHNjcm9sbGJhcnMuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIGZvciBzbWFsbGVyIG1lbnVzLCB3aGVyZSB0aGVyZSBtaWdodCBiZSBwbGVudHkgb2Ygcm9vbVxuICAgICAgICAvLyBiZWxvdyB0aGUgYnV0dG9uIHdpdGhvdXQgc2V0dGluZyBkcm9wdXAsIGJ1dCB3ZSBjYW4ndCBrbm93XG4gICAgICAgIC8vIHRoZSBleGFjdCBoZWlnaHQgb2YgdGhlIG1lbnUgdW50aWwgY3JlYXRlVmlldyBpcyBjYWxsZWQgbGF0ZXJcbiAgICAgICAgZXN0aW1hdGUgPSBsaUhlaWdodCAqIHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGggKyBtZW51UGFkZGluZy52ZXJ0O1xuXG4gICAgICAgIGlzRHJvcHVwID0gdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRUb3AgLSB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldEJvdCA+IHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcy52ZXJ0ICYmIGVzdGltYXRlICsgdGhpcy5zaXplSW5mby5tZW51RXh0cmFzLnZlcnQgKyA1MCA+IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0Qm90O1xuXG4gICAgICAgIC8vIGVuc3VyZSBkcm9wdXAgZG9lc24ndCBjaGFuZ2Ugd2hpbGUgc2VhcmNoaW5nIChzbyBtZW51IGRvZXNuJ3QgYm91bmNlIGJhY2sgYW5kIGZvcnRoKVxuICAgICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIuaXNTZWFyY2hpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBpc0Ryb3B1cCA9IHRoaXMuc2VsZWN0cGlja2VyLmRyb3B1cDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJG5ld0VsZW1lbnQudG9nZ2xlQ2xhc3MoY2xhc3NOYW1lcy5EUk9QVVAsIGlzRHJvcHVwKTtcbiAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIuZHJvcHVwID0gaXNEcm9wdXA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIF9taW5IZWlnaHQgPSB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoID4gMyA/IHRoaXMuc2l6ZUluZm8ubGlIZWlnaHQgKiAzICsgdGhpcy5zaXplSW5mby5tZW51RXh0cmFzLnZlcnQgLSAyIDogMDtcbiAgICAgICAgbWVudUhlaWdodCA9IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0Qm90IC0gdGhpcy5zaXplSW5mby5tZW51RXh0cmFzLnZlcnQ7XG4gICAgICAgIG1pbkhlaWdodCA9IF9taW5IZWlnaHQgKyBoZWFkZXJIZWlnaHQgKyBzZWFyY2hIZWlnaHQgKyBhY3Rpb25zSGVpZ2h0ICsgZG9uZUJ1dHRvbkhlaWdodDtcbiAgICAgICAgbWVudUlubmVyTWluSGVpZ2h0ID0gTWF0aC5tYXgoX21pbkhlaWdodCAtIG1lbnVQYWRkaW5nLnZlcnQsIDApO1xuXG4gICAgICAgIGlmICh0aGlzLiRuZXdFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuRFJPUFVQKSkge1xuICAgICAgICAgIG1lbnVIZWlnaHQgPSB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFRvcCAtIHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcy52ZXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgbWF4SGVpZ2h0ID0gbWVudUhlaWdodDtcbiAgICAgICAgbWVudUlubmVySGVpZ2h0ID0gbWVudUhlaWdodCAtIGhlYWRlckhlaWdodCAtIHNlYXJjaEhlaWdodCAtIGFjdGlvbnNIZWlnaHQgLSBkb25lQnV0dG9uSGVpZ2h0IC0gbWVudVBhZGRpbmcudmVydDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNpemUgJiYgdGhpcy5vcHRpb25zLnNpemUgIT0gJ2F1dG8nICYmIHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5vcHRpb25zLnNpemUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpXS50eXBlID09PSAnZGl2aWRlcicpIGRpdkxlbmd0aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVudUhlaWdodCA9IGxpSGVpZ2h0ICogdGhpcy5vcHRpb25zLnNpemUgKyBkaXZMZW5ndGggKiBkaXZIZWlnaHQgKyBtZW51UGFkZGluZy52ZXJ0O1xuICAgICAgICBtZW51SW5uZXJIZWlnaHQgPSBtZW51SGVpZ2h0IC0gbWVudVBhZGRpbmcudmVydDtcbiAgICAgICAgbWF4SGVpZ2h0ID0gbWVudUhlaWdodCArIGhlYWRlckhlaWdodCArIHNlYXJjaEhlaWdodCArIGFjdGlvbnNIZWlnaHQgKyBkb25lQnV0dG9uSGVpZ2h0O1xuICAgICAgICBtaW5IZWlnaHQgPSBtZW51SW5uZXJNaW5IZWlnaHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy4kbWVudS5jc3Moe1xuICAgICAgICAnbWF4LWhlaWdodCc6IG1heEhlaWdodCArICdweCcsXG4gICAgICAgICdvdmVyZmxvdyc6ICdoaWRkZW4nLFxuICAgICAgICAnbWluLWhlaWdodCc6IG1pbkhlaWdodCArICdweCdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRtZW51SW5uZXIuY3NzKHtcbiAgICAgICAgJ21heC1oZWlnaHQnOiBtZW51SW5uZXJIZWlnaHQgKyAncHgnLFxuICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuIGF1dG8nLFxuICAgICAgICAnbWluLWhlaWdodCc6IG1lbnVJbm5lck1pbkhlaWdodCArICdweCdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBlbnN1cmUgbWVudUlubmVySGVpZ2h0IGlzIGFsd2F5cyBhIHBvc2l0aXZlIG51bWJlciB0byBwcmV2ZW50IGlzc3VlcyBjYWxjdWxhdGluZyBjaHVua1NpemUgaW4gY3JlYXRlVmlld1xuICAgICAgdGhpcy5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQgPSBNYXRoLm1heChtZW51SW5uZXJIZWlnaHQsIDEpO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aCAmJiB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aCAtIDFdLnBvc2l0aW9uID4gdGhpcy5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zaXplSW5mby5oYXNTY3JvbGxCYXIgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemVJbmZvLnRvdGFsTWVudVdpZHRoID0gdGhpcy5zaXplSW5mby5tZW51V2lkdGggKyB0aGlzLnNpemVJbmZvLnNjcm9sbEJhcldpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3Bkb3duQWxpZ25SaWdodCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMuJG1lbnUudG9nZ2xlQ2xhc3MoY2xhc3NOYW1lcy5NRU5VUklHSFQsIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0TGVmdCA+IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0UmlnaHQgJiYgdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRSaWdodCA8ICh0aGlzLnNpemVJbmZvLnRvdGFsTWVudVdpZHRoIC0gc2VsZWN0V2lkdGgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZHJvcGRvd24gJiYgdGhpcy5kcm9wZG93bi5fcG9wcGVyKSB0aGlzLmRyb3Bkb3duLl9wb3BwZXIudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIHNldFNpemU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG4gICAgICB0aGlzLmxpSGVpZ2h0KHJlZnJlc2gpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcikgdGhpcy4kbWVudS5jc3MoJ3BhZGRpbmctdG9wJywgMCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgJHdpbmRvdyA9ICQod2luZG93KTtcblxuICAgICAgICB0aGlzLnNldE1lbnVTaXplKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgICAgdGhpcy4kc2VhcmNoYm94XG4gICAgICAgICAgICAub2ZmKCdpbnB1dC5zZXRNZW51U2l6ZSBwcm9wZXJ0eWNoYW5nZS5zZXRNZW51U2l6ZScpXG4gICAgICAgICAgICAub24oJ2lucHV0LnNldE1lbnVTaXplIHByb3BlcnR5Y2hhbmdlLnNldE1lbnVTaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhhdC5zZXRNZW51U2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpemUgPT09ICdhdXRvJykge1xuICAgICAgICAgICR3aW5kb3dcbiAgICAgICAgICAgIC5vZmYoJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScgKyAnIHNjcm9sbCcgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScpXG4gICAgICAgICAgICAub24oJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScgKyAnIHNjcm9sbCcgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2V0TWVudVNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zaXplICYmIHRoaXMub3B0aW9ucy5zaXplICE9ICdhdXRvJyAmJiB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5zaXplKSB7XG4gICAgICAgICAgJHdpbmRvdy5vZmYoJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScgKyAnIHNjcm9sbCcgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3JlYXRlVmlldyhmYWxzZSwgdHJ1ZSwgcmVmcmVzaCk7XG4gICAgfSxcblxuICAgIHNldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2lkdGggPT09ICdhdXRvJykge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuJG1lbnUuY3NzKCdtaW4td2lkdGgnLCAnMCcpO1xuXG4gICAgICAgICAgdGhhdC4kZWxlbWVudC5vbignbG9hZGVkJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5saUhlaWdodCgpO1xuICAgICAgICAgICAgdGhhdC5zZXRNZW51U2l6ZSgpO1xuXG4gICAgICAgICAgICAvLyBHZXQgY29ycmVjdCB3aWR0aCBpZiBlbGVtZW50IGlzIGhpZGRlblxuICAgICAgICAgICAgdmFyICRzZWxlY3RDbG9uZSA9IHRoYXQuJG5ld0VsZW1lbnQuY2xvbmUoKS5hcHBlbmRUbygnYm9keScpLFxuICAgICAgICAgICAgICAgIGJ0bldpZHRoID0gJHNlbGVjdENsb25lLmNzcygnd2lkdGgnLCAnYXV0bycpLmNoaWxkcmVuKCdidXR0b24nKS5vdXRlcldpZHRoKCk7XG5cbiAgICAgICAgICAgICRzZWxlY3RDbG9uZS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gU2V0IHdpZHRoIHRvIHdoYXRldmVyJ3MgbGFyZ2VyLCBidXR0b24gdGl0bGUgb3IgbG9uZ2VzdCBvcHRpb25cbiAgICAgICAgICAgIHRoYXQuc2l6ZUluZm8uc2VsZWN0V2lkdGggPSBNYXRoLm1heCh0aGF0LnNpemVJbmZvLnRvdGFsTWVudVdpZHRoLCBidG5XaWR0aCk7XG4gICAgICAgICAgICB0aGF0LiRuZXdFbGVtZW50LmNzcygnd2lkdGgnLCB0aGF0LnNpemVJbmZvLnNlbGVjdFdpZHRoICsgJ3B4Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMud2lkdGggPT09ICdmaXQnKSB7XG4gICAgICAgIC8vIFJlbW92ZSBpbmxpbmUgbWluLXdpZHRoIHNvIHdpZHRoIGNhbiBiZSBjaGFuZ2VkIGZyb20gJ2F1dG8nXG4gICAgICAgIHRoaXMuJG1lbnUuY3NzKCdtaW4td2lkdGgnLCAnJyk7XG4gICAgICAgIHRoaXMuJG5ld0VsZW1lbnQuY3NzKCd3aWR0aCcsICcnKS5hZGRDbGFzcygnZml0LXdpZHRoJyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy53aWR0aCkge1xuICAgICAgICAvLyBSZW1vdmUgaW5saW5lIG1pbi13aWR0aCBzbyB3aWR0aCBjYW4gYmUgY2hhbmdlZCBmcm9tICdhdXRvJ1xuICAgICAgICB0aGlzLiRtZW51LmNzcygnbWluLXdpZHRoJywgJycpO1xuICAgICAgICB0aGlzLiRuZXdFbGVtZW50LmNzcygnd2lkdGgnLCB0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVtb3ZlIGlubGluZSBtaW4td2lkdGgvd2lkdGggc28gd2lkdGggY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgdGhpcy4kbWVudS5jc3MoJ21pbi13aWR0aCcsICcnKTtcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudC5jc3MoJ3dpZHRoJywgJycpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGZpdC13aWR0aCBjbGFzcyBpZiB3aWR0aCBpcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHlcbiAgICAgIGlmICh0aGlzLiRuZXdFbGVtZW50Lmhhc0NsYXNzKCdmaXQtd2lkdGgnKSAmJiB0aGlzLm9wdGlvbnMud2lkdGggIT09ICdmaXQnKSB7XG4gICAgICAgIHRoaXMuJG5ld0VsZW1lbnRbMF0uY2xhc3NMaXN0LnJlbW92ZSgnZml0LXdpZHRoJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRic0NvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XCJicy1jb250YWluZXJcIiAvPicpO1xuXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgJGNvbnRhaW5lciA9ICQodGhpcy5vcHRpb25zLmNvbnRhaW5lciksXG4gICAgICAgICAgcG9zLFxuICAgICAgICAgIGNvbnRhaW5lclBvcyxcbiAgICAgICAgICBhY3R1YWxIZWlnaHQsXG4gICAgICAgICAgZ2V0UGxhY2VtZW50ID0gZnVuY3Rpb24gKCRlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUG9zaXRpb24gPSB7fSxcbiAgICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZHJvcGRvd24ncyBkZWZhdWx0IGRpc3BsYXkgc2V0dGluZyBpZiBkaXNwbGF5IGlzIG5vdCBtYW51YWxseSBzZXRcbiAgICAgICAgICAgICAgICBkaXNwbGF5ID0gdGhhdC5vcHRpb25zLmRpc3BsYXkgfHwgKFxuICAgICAgICAgICAgICAgICAgLy8gQm9vdHN0cmFwIDMgZG9lc24ndCBoYXZlICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuRGVmYXVsdFxuICAgICAgICAgICAgICAgICAgJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3Rvci5EZWZhdWx0ID8gJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3Rvci5EZWZhdWx0LmRpc3BsYXlcbiAgICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGF0LiRic0NvbnRhaW5lci5hZGRDbGFzcygkZWxlbWVudC5hdHRyKCdjbGFzcycpLnJlcGxhY2UoL2Zvcm0tY29udHJvbHxmaXQtd2lkdGgvZ2ksICcnKSkudG9nZ2xlQ2xhc3MoY2xhc3NOYW1lcy5EUk9QVVAsICRlbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuRFJPUFVQKSk7XG4gICAgICAgICAgICBwb3MgPSAkZWxlbWVudC5vZmZzZXQoKTtcblxuICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyLmlzKCdib2R5JykpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zID0gJGNvbnRhaW5lci5vZmZzZXQoKTtcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zLnRvcCArPSBwYXJzZUludCgkY29udGFpbmVyLmNzcygnYm9yZGVyVG9wV2lkdGgnKSkgLSAkY29udGFpbmVyLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgICBjb250YWluZXJQb3MubGVmdCArPSBwYXJzZUludCgkY29udGFpbmVyLmNzcygnYm9yZGVyTGVmdFdpZHRoJykpIC0gJGNvbnRhaW5lci5zY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250YWluZXJQb3MgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhY3R1YWxIZWlnaHQgPSAkZWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLkRST1BVUCkgPyAwIDogJGVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBCb290c3RyYXAgNCsgdXNlcyBQb3BwZXIgZm9yIG1lbnUgcG9zaXRpb25pbmdcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLm1ham9yIDwgNCB8fCBkaXNwbGF5ID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgICBjb250YWluZXJQb3NpdGlvbi50b3AgPSBwb3MudG9wIC0gY29udGFpbmVyUG9zLnRvcCArIGFjdHVhbEhlaWdodDtcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zaXRpb24ubGVmdCA9IHBvcy5sZWZ0IC0gY29udGFpbmVyUG9zLmxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5lclBvc2l0aW9uLndpZHRoID0gJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgIHRoYXQuJGJzQ29udGFpbmVyLmNzcyhjb250YWluZXJQb3NpdGlvbik7XG4gICAgICAgICAgfTtcblxuICAgICAgdGhpcy4kYnV0dG9uLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoYXQuaXNEaXNhYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGxhY2VtZW50KHRoYXQuJG5ld0VsZW1lbnQpO1xuXG4gICAgICAgIHRoYXQuJGJzQ29udGFpbmVyXG4gICAgICAgICAgLmFwcGVuZFRvKHRoYXQub3B0aW9ucy5jb250YWluZXIpXG4gICAgICAgICAgLnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuU0hPVywgIXRoYXQuJGJ1dHRvbi5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpKVxuICAgICAgICAgIC5hcHBlbmQodGhhdC4kbWVudSk7XG4gICAgICB9KTtcblxuICAgICAgJCh3aW5kb3cpXG4gICAgICAgIC5vZmYoJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJyBzY3JvbGwnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZClcbiAgICAgICAgLm9uKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcgc2Nyb2xsJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaXNBY3RpdmUgPSB0aGF0LiRuZXdFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuU0hPVyk7XG5cbiAgICAgICAgICBpZiAoaXNBY3RpdmUpIGdldFBsYWNlbWVudCh0aGF0LiRuZXdFbGVtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2hpZGUnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQuJG1lbnUuZGF0YSgnaGVpZ2h0JywgdGhhdC4kbWVudS5oZWlnaHQoKSk7XG4gICAgICAgIHRoYXQuJGJzQ29udGFpbmVyLmRldGFjaCgpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZU9wdGlvbjogZnVuY3Rpb24gKGRhdGEsIGluaXQpIHtcbiAgICAgIHZhciBvcHRpb25EYXRhID0gIWRhdGEub3B0aW9uID8gZGF0YSA6IGRhdGEub3B0aW9uO1xuXG4gICAgICBpZiAob3B0aW9uRGF0YSAmJiBvcHRpb25EYXRhLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSAoaW5pdCA/IGVsZW1lbnRUZW1wbGF0ZXMuc2VsZWN0ZWRPcHRpb24gOiBlbGVtZW50VGVtcGxhdGVzLm9wdGlvbikuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBpZiAob3B0aW9uRGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSBvcHRpb24udmFsdWUgPSBvcHRpb25EYXRhLnZhbHVlO1xuICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBvcHRpb25EYXRhLnRleHQ7XG5cbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAob3B0aW9uRGF0YS5saUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb24ubGlJbmRleCA9IG9wdGlvbkRhdGEubGlJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmICghaW5pdCkge1xuICAgICAgICAgIG9wdGlvbi5saUluZGV4ID0gZGF0YS5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEub3B0aW9uID0gb3B0aW9uO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLm1haW4ub3B0aW9uUXVldWUuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0T3B0aW9uU3RhdHVzOiBmdW5jdGlvbiAoc2VsZWN0ZWRPbmx5KSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoYXQubm9TY3JvbGwgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzICYmIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxpRGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpICsgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjBdLFxuICAgICAgICAgICAgICBvcHRpb24gPSBsaURhdGEub3B0aW9uO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkT25seSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGF0LnNldERpc2FibGVkKGxpRGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQobGlEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgb3B0aW9uUXVldWUgKGRvY3VtZW50RnJhZ21lbnQgd2l0aCBvcHRpb24gZWxlbWVudHMgZm9yIHNlbGVjdCBvcHRpb25zKVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZS5kYXRhKSB0aGlzLiRlbGVtZW50WzBdLmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0cGlja2VyLm1haW4ub3B0aW9uUXVldWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGlEYXRhIC0gdGhlIG9wdGlvbiBvYmplY3QgdGhhdCBpcyBiZWluZyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCAtIHRydWUgaWYgdGhlIG9wdGlvbiBpcyBiZWluZyBzZWxlY3RlZCwgZmFsc2UgaWYgYmVpbmcgZGVzZWxlY3RlZFxuICAgICAqL1xuICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAobGlEYXRhLCBzZWxlY3RlZCkge1xuICAgICAgc2VsZWN0ZWQgPSBzZWxlY3RlZCA9PT0gdW5kZWZpbmVkID8gbGlEYXRhLnNlbGVjdGVkIDogc2VsZWN0ZWQ7XG5cbiAgICAgIHZhciBsaSA9IGxpRGF0YS5lbGVtZW50LFxuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJc1NldCA9IHRoaXMuYWN0aXZlRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHRoaXNJc0FjdGl2ZSA9IHRoaXMuYWN0aXZlRWxlbWVudCA9PT0gbGksXG4gICAgICAgICAgcHJldkFjdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgb3B0aW9uIGlzIGFscmVhZHkgYWN0aXZlXG4gICAgICAgICAgLy8gT1JcbiAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBvcHRpb24gaXMgYmVpbmcgc2VsZWN0ZWQsIGl0J3MgTk9UIG11bHRpcGxlLCBhbmRcbiAgICAgICAgICAvLyBhY3RpdmVFbGVtZW50IGlzIHVuZGVmaW5lZDpcbiAgICAgICAgICAvLyAgLSB3aGVuIHRoZSBtZW51IGlzIGZpcnN0IGJlaW5nIG9wZW5lZCwgT1JcbiAgICAgICAgICAvLyAgLSBhZnRlciBhIHNlYXJjaCBoYXMgYmVlbiBwZXJmb3JtZWQsIE9SXG4gICAgICAgICAgLy8gIC0gd2hlbiByZXRhaW5BY3RpdmUgaXMgZmFsc2Ugd2hlbiBzZWxlY3RpbmcgYSBuZXcgb3B0aW9uIChpLmUuIGluZGV4IG9mIHRoZSBuZXdseSBzZWxlY3RlZCBvcHRpb24gaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IGFjdGl2ZUVsZW1lbnQpXG4gICAgICAgICAga2VlcEFjdGl2ZSA9IHRoaXNJc0FjdGl2ZSB8fCAoc2VsZWN0ZWQgJiYgIXRoaXMubXVsdGlwbGUgJiYgIWFjdGl2ZUVsZW1lbnRJc1NldCk7XG5cbiAgICAgIGlmICghbGkpIHJldHVybjtcblxuICAgICAgaWYgKHNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGlEYXRhLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIGlmIChsaURhdGEub3B0aW9uKSBsaURhdGEub3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuc291cmNlLmRhdGEpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVPcHRpb24obGlEYXRhLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGEgPSBsaS5maXJzdENoaWxkO1xuXG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEVsZW1lbnQgPSBsaTtcbiAgICAgIH1cblxuICAgICAgbGkuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG5cbiAgICAgIGlmIChrZWVwQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuZm9jdXNJdGVtKGxpLCBsaURhdGEpO1xuICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LmN1cnJlbnRBY3RpdmUgPSBsaTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZm9jdXNJdGVtKGxpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEpIHtcbiAgICAgICAgYS5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFrZWVwQWN0aXZlICYmICFhY3RpdmVFbGVtZW50SXNTZXQgJiYgc2VsZWN0ZWQgJiYgdGhpcy5wcmV2QWN0aXZlRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZXZBY3RpdmUgPSB0aGlzLnByZXZBY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIHRoaXMuZGVmb2N1c0l0ZW0ocHJldkFjdGl2ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgb3B0aW9uIHRoYXQgaXMgYmVpbmcgZGlzYWJsZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkIC0gdHJ1ZSBpZiB0aGUgb3B0aW9uIGlzIGJlaW5nIGRpc2FibGVkLCBmYWxzZSBpZiBiZWluZyBlbmFibGVkXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWQ6IGZ1bmN0aW9uIChsaURhdGEpIHtcbiAgICAgIHZhciBkaXNhYmxlZCA9IGxpRGF0YS5kaXNhYmxlZCxcbiAgICAgICAgICBsaSA9IGxpRGF0YS5lbGVtZW50LFxuICAgICAgICAgIGE7XG5cbiAgICAgIGlmICghbGkpIHJldHVybjtcblxuICAgICAgYSA9IGxpLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIGxpLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lcy5ESVNBQkxFRCwgZGlzYWJsZWQpO1xuXG4gICAgICBpZiAoYSkge1xuICAgICAgICBpZiAodmVyc2lvbi5tYWpvciA+PSAnNCcpIGEuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWVzLkRJU0FCTEVELCBkaXNhYmxlZCk7XG5cbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCBkaXNhYmxlZCk7XG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJyk7XG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnRbMF0uZGlzYWJsZWQ7XG4gICAgfSxcblxuICAgIGNoZWNrRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xuICAgICAgICB0aGlzLiRuZXdFbGVtZW50WzBdLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lcy5ESVNBQkxFRCk7XG4gICAgICAgIHRoaXMuJGJ1dHRvbi5hZGRDbGFzcyhjbGFzc05hbWVzLkRJU0FCTEVEKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy4kYnV0dG9uWzBdLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWVzLkRJU0FCTEVEKSkge1xuICAgICAgICAgIHRoaXMuJG5ld0VsZW1lbnRbMF0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWVzLkRJU0FCTEVEKTtcbiAgICAgICAgICB0aGlzLiRidXR0b24ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lcy5ESVNBQkxFRCkuYXR0cignYXJpYS1kaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjbGlja0xpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgJGRvY3VtZW50ID0gJChkb2N1bWVudCk7XG5cbiAgICAgICRkb2N1bWVudC5kYXRhKCdzcGFjZVNlbGVjdCcsIGZhbHNlKTtcblxuICAgICAgdGhpcy4kYnV0dG9uLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgvKDMyKS8udGVzdChlLmtleUNvZGUudG9TdHJpbmcoMTApKSAmJiAkZG9jdW1lbnQuZGF0YSgnc3BhY2VTZWxlY3QnKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAkZG9jdW1lbnQuZGF0YSgnc3BhY2VTZWxlY3QnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRuZXdFbGVtZW50Lm9uKCdzaG93LmJzLmRyb3Bkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoYXQuZHJvcGRvd24gJiYgdmVyc2lvbi5tYWpvciA9PT0gJzQnKSB7XG4gICAgICAgICAgdGhhdC5kcm9wZG93biA9IHRoYXQuJGJ1dHRvbi5kYXRhKCdicy5kcm9wZG93bicpO1xuICAgICAgICAgIHRoYXQuZHJvcGRvd24uX21lbnUgPSB0aGF0LiRtZW51WzBdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoYXQubXVsdGlwbGUpIHtcbiAgICAgICAgICB0aGF0LmRlc2VsZWN0QWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGF0LiRlbGVtZW50WzBdLFxuICAgICAgICAgICAgICBwcmV2VmFsdWUgPSBlbGVtZW50LnZhbHVlLFxuICAgICAgICAgICAgICBwcmV2SW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgIHByZXZPcHRpb24gPSBlbGVtZW50Lm9wdGlvbnNbcHJldkluZGV4XSxcbiAgICAgICAgICAgICAgcHJldkRhdGEgPSBwcmV2T3B0aW9uID8gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW3ByZXZPcHRpb24ubGlJbmRleF0gOiBmYWxzZTtcblxuICAgICAgICAgIGlmIChwcmV2RGF0YSkge1xuICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZChwcmV2RGF0YSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IDA7XG5cbiAgICAgICAgICBjaGFuZ2VkQXJndW1lbnRzID0gW3ByZXZJbmRleCwgZmFsc2UsIHByZXZWYWx1ZV07XG4gICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyTmF0aXZlKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBzZWxlY3RlZCBzdHlsaW5nIGlmIG1lbnUgaXMgb3BlblxuICAgICAgICBpZiAodGhhdC4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpKSB7XG4gICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGF0LmNyZWF0ZVZpZXcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGJ1dHRvbi5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmFsbG93Q2xlYXIpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQsXG4gICAgICAgICAgICAgIGNsZWFyQnV0dG9uID0gdGhhdC4kY2xlYXJCdXR0b25bMF07XG5cbiAgICAgICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgZXZlbnQgbGlzdGVuZXJzIG9uIGNoaWxkIGVsZW1lbnRzIG9mIGJ1dHRvbnNcbiAgICAgICAgICBpZiAoL01TSUV8VHJpZGVudC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0YXJnZXQgPT09IGNsZWFyQnV0dG9uIHx8IHRhcmdldC5wYXJlbnRFbGVtZW50ID09PSBjbGVhckJ1dHRvbikge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGNsZWFyU2VsZWN0aW9uKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhhdC4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpKSB7XG4gICAgICAgICAgdGhhdC5zZXRTaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBzZXRGb2N1cyAoKSB7XG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQuJG1lbnVJbm5lci50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUG9wcGVyRXhpc3RzICgpIHtcbiAgICAgICAgaWYgKHRoYXQuZHJvcGRvd24gJiYgdGhhdC5kcm9wZG93bi5fcG9wcGVyICYmIHRoYXQuZHJvcGRvd24uX3BvcHBlci5zdGF0ZSkge1xuICAgICAgICAgIHNldEZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNoZWNrUG9wcGVyRXhpc3RzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdzaG93bicgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgIT09IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuc2Nyb2xsVG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPiAzKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNoZWNrUG9wcGVyRXhpc3RzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRGb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gZW5zdXJlIHBvc2luc2V0IGFuZCBzZXRzaXplIGFyZSBjb3JyZWN0IGJlZm9yZSBzZWxlY3RpbmcgYW4gb3B0aW9uIHZpYSBhIGNsaWNrXG4gICAgICB0aGlzLiRtZW51SW5uZXIub24oJ21vdXNlZW50ZXInLCAnbGkgYScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBob3ZlckxpID0gdGhpcy5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgcG9zaXRpb24wID0gdGhhdC5pc1ZpcnR1YWwoKSA/IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wIDogMCxcbiAgICAgICAgICAgIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChob3ZlckxpLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4sIGhvdmVyTGkpLFxuICAgICAgICAgICAgaG92ZXJEYXRhID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2luZGV4ICsgcG9zaXRpb24wXTtcblxuICAgICAgICB0aGF0LmZvY3VzSXRlbShob3ZlckxpLCBob3ZlckRhdGEsIHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJG1lbnVJbm5lci5vbignY2xpY2snLCAnbGkgYScsIGZ1bmN0aW9uIChlLCByZXRhaW5BY3RpdmUpIHtcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGF0LiRlbGVtZW50WzBdLFxuICAgICAgICAgICAgcG9zaXRpb24wID0gdGhhdC5pc1ZpcnR1YWwoKSA/IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wIDogMCxcbiAgICAgICAgICAgIGNsaWNrZWREYXRhID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhWyR0aGlzLnBhcmVudCgpLmluZGV4KCkgKyBwb3NpdGlvbjBdLFxuICAgICAgICAgICAgY2xpY2tlZEVsZW1lbnQgPSBjbGlja2VkRGF0YS5lbGVtZW50LFxuICAgICAgICAgICAgcHJldlZhbHVlID0gZ2V0U2VsZWN0VmFsdWVzLmNhbGwodGhhdCksXG4gICAgICAgICAgICBwcmV2SW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICBwcmV2T3B0aW9uID0gZWxlbWVudC5vcHRpb25zW3ByZXZJbmRleF0sXG4gICAgICAgICAgICBwcmV2RGF0YSA9IHByZXZPcHRpb24gPyB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmRhdGFbcHJldk9wdGlvbi5saUluZGV4XSA6IGZhbHNlLFxuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IHRydWU7XG5cbiAgICAgICAgLy8gRG9uJ3QgY2xvc2Ugb24gbXVsdGkgY2hvaWNlIG1lbnVcbiAgICAgICAgaWYgKHRoYXQubXVsdGlwbGUgJiYgdGhhdC5vcHRpb25zLm1heE9wdGlvbnMgIT09IDEpIHtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIERvbid0IHJ1biBpZiB0aGUgc2VsZWN0IGlzIGRpc2FibGVkXG4gICAgICAgIGlmICghdGhhdC5pc0Rpc2FibGVkKCkgJiYgISR0aGlzLnBhcmVudCgpLmhhc0NsYXNzKGNsYXNzTmFtZXMuRElTQUJMRUQpKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbiA9IGNsaWNrZWREYXRhLm9wdGlvbixcbiAgICAgICAgICAgICAgJG9wdGlvbiA9ICQob3B0aW9uKSxcbiAgICAgICAgICAgICAgc3RhdGUgPSBvcHRpb24uc2VsZWN0ZWQsXG4gICAgICAgICAgICAgIG9wdGdyb3VwRGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5maW5kKGZ1bmN0aW9uIChkYXR1bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bS5vcHRJRCA9PT0gY2xpY2tlZERhdGEub3B0SUQgJiYgZGF0dW0udHlwZSA9PT0gJ29wdGdyb3VwLWxhYmVsJztcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG9wdGdyb3VwID0gb3B0Z3JvdXBEYXRhID8gb3B0Z3JvdXBEYXRhLm9wdGdyb3VwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBkYXRhR2V0dGVyID0gb3B0Z3JvdXAgaW5zdGFuY2VvZiBFbGVtZW50ID8gZ2V0T3B0aW9uRGF0YS5mcm9tT3B0aW9uIDogZ2V0T3B0aW9uRGF0YS5mcm9tRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgb3B0Z3JvdXBPcHRpb25zID0gb3B0Z3JvdXAgJiYgb3B0Z3JvdXAuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIG1heE9wdGlvbnMgPSBwYXJzZUludCh0aGF0Lm9wdGlvbnMubWF4T3B0aW9ucyksXG4gICAgICAgICAgICAgIG1heE9wdGlvbnNHcnAgPSBvcHRncm91cCAmJiBwYXJzZUludChkYXRhR2V0dGVyKG9wdGdyb3VwLCAnbWF4T3B0aW9ucycpKSB8fCBmYWxzZTtcblxuICAgICAgICAgIGlmIChjbGlja2VkRWxlbWVudCA9PT0gdGhhdC5hY3RpdmVFbGVtZW50KSByZXRhaW5BY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFyZXRhaW5BY3RpdmUpIHtcbiAgICAgICAgICAgIHRoYXQucHJldkFjdGl2ZUVsZW1lbnQgPSB0aGF0LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGF0LmFjdGl2ZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGF0Lm11bHRpcGxlIHx8IG1heE9wdGlvbnMgPT09IDEpIHsgLy8gRGVzZWxlY3QgcHJldmlvdXMgb3B0aW9uIGlmIG5vdCBtdWx0aSBzZWxlY3RcbiAgICAgICAgICAgIGlmIChwcmV2RGF0YSkgdGhhdC5zZXRTZWxlY3RlZChwcmV2RGF0YSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZChjbGlja2VkRGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gVG9nZ2xlIHRoZSBjbGlja2VkIG9wdGlvbiBpZiBtdWx0aSBzZWxlY3QuXG4gICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkKGNsaWNrZWREYXRhLCAhc3RhdGUpO1xuICAgICAgICAgICAgdGhhdC5mb2N1c2VkUGFyZW50LmZvY3VzKCk7XG5cbiAgICAgICAgICAgIGlmIChtYXhPcHRpb25zICE9PSBmYWxzZSB8fCBtYXhPcHRpb25zR3JwICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICB2YXIgbWF4UmVhY2hlZCA9IG1heE9wdGlvbnMgPCBnZXRTZWxlY3RlZE9wdGlvbnMuY2FsbCh0aGF0KS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZEdyb3VwT3B0aW9ucyA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKG9wdGdyb3VwICYmIG9wdGdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRncm91cC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKG9wdGdyb3VwLmNoaWxkcmVuW2ldLnNlbGVjdGVkKSBzZWxlY3RlZEdyb3VwT3B0aW9ucysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBtYXhSZWFjaGVkR3JwID0gbWF4T3B0aW9uc0dycCA8IHNlbGVjdGVkR3JvdXBPcHRpb25zO1xuXG4gICAgICAgICAgICAgIGlmICgobWF4T3B0aW9ucyAmJiBtYXhSZWFjaGVkKSB8fCAobWF4T3B0aW9uc0dycCAmJiBtYXhSZWFjaGVkR3JwKSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXhPcHRpb25zICYmIG1heE9wdGlvbnMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25TdGF0dXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXhPcHRpb25zR3JwICYmIG1heE9wdGlvbnNHcnAgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0Z3JvdXBPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfb3B0aW9uID0gb3B0Z3JvdXBPcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkKHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtfb3B0aW9uLmxpSW5kZXhdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQoY2xpY2tlZERhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbWF4T3B0aW9uc1RleHQgPSB0eXBlb2YgdGhhdC5vcHRpb25zLm1heE9wdGlvbnNUZXh0ID09PSAnc3RyaW5nJyA/IFt0aGF0Lm9wdGlvbnMubWF4T3B0aW9uc1RleHQsIHRoYXQub3B0aW9ucy5tYXhPcHRpb25zVGV4dF0gOiB0aGF0Lm9wdGlvbnMubWF4T3B0aW9uc1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgbWF4T3B0aW9uc0FyciA9IHR5cGVvZiBtYXhPcHRpb25zVGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IG1heE9wdGlvbnNUZXh0KG1heE9wdGlvbnMsIG1heE9wdGlvbnNHcnApIDogbWF4T3B0aW9uc1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgbWF4VHh0ID0gbWF4T3B0aW9uc0FyclswXS5yZXBsYWNlKCd7bn0nLCBtYXhPcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXhUeHRHcnAgPSBtYXhPcHRpb25zQXJyWzFdLnJlcGxhY2UoJ3tufScsIG1heE9wdGlvbnNHcnApLFxuICAgICAgICAgICAgICAgICAgICAgICRub3RpZnkgPSAkKCc8ZGl2IGNsYXNzPVwibm90aWZ5XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB7dmFyfSBpcyBzZXQgaW4gYXJyYXksIHJlcGxhY2UgaXRcbiAgICAgICAgICAgICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICAgICAgICAgICAgaWYgKG1heE9wdGlvbnNBcnJbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4VHh0ID0gbWF4VHh0LnJlcGxhY2UoJ3t2YXJ9JywgbWF4T3B0aW9uc0FyclsyXVttYXhPcHRpb25zID4gMSA/IDAgOiAxXSk7XG4gICAgICAgICAgICAgICAgICAgIG1heFR4dEdycCA9IG1heFR4dEdycC5yZXBsYWNlKCd7dmFyfScsIG1heE9wdGlvbnNBcnJbMl1bbWF4T3B0aW9uc0dycCA+IDEgPyAwIDogMV0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB0aGF0LiRtZW51LmFwcGVuZCgkbm90aWZ5KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG1heE9wdGlvbnMgJiYgbWF4UmVhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAkbm90aWZ5LmFwcGVuZCgkKCc8ZGl2PicgKyBtYXhUeHQgKyAnPC9kaXY+JykpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignbWF4UmVhY2hlZCcgKyBFVkVOVF9LRVkpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAobWF4T3B0aW9uc0dycCAmJiBtYXhSZWFjaGVkR3JwKSB7XG4gICAgICAgICAgICAgICAgICAgICRub3RpZnkuYXBwZW5kKCQoJzxkaXY+JyArIG1heFR4dEdycCArICc8L2Rpdj4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdtYXhSZWFjaGVkR3JwJyArIEVWRU5UX0tFWSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkKGNsaWNrZWREYXRhLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB9LCAxMCk7XG5cbiAgICAgICAgICAgICAgICAgICRub3RpZnlbMF0uY2xhc3NMaXN0LmFkZCgnZmFkZU91dCcpO1xuXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJG5vdGlmeS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgIH0sIDEwNTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuc291cmNlLmRhdGEpIHRoYXQuJGVsZW1lbnRbMF0uYXBwZW5kQ2hpbGQodGhhdC5zZWxlY3RwaWNrZXIubWFpbi5vcHRpb25RdWV1ZSk7XG5cbiAgICAgICAgICBpZiAoIXRoYXQubXVsdGlwbGUgfHwgKHRoYXQubXVsdGlwbGUgJiYgdGhhdC5vcHRpb25zLm1heE9wdGlvbnMgPT09IDEpKSB7XG4gICAgICAgICAgICB0aGF0LiRidXR0b24udHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUcmlnZ2VyIHNlbGVjdCAnY2hhbmdlJ1xuICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5tdWx0aXBsZSB8fCBwcmV2SW5kZXggIT09IGVsZW1lbnQuc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICAgICAgICAvLyAkb3B0aW9uLnByb3AoJ3NlbGVjdGVkJykgaXMgY3VycmVudCBvcHRpb24gc3RhdGUgKHNlbGVjdGVkL3Vuc2VsZWN0ZWQpLiBwcmV2VmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWxlY3QgcHJpb3IgdG8gYmVpbmcgY2hhbmdlZC5cbiAgICAgICAgICAgICAgY2hhbmdlZEFyZ3VtZW50cyA9IFtvcHRpb24uaW5kZXgsICRvcHRpb24ucHJvcCgnc2VsZWN0ZWQnKSwgcHJldlZhbHVlXTtcbiAgICAgICAgICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAgICAgICAgIC50cmlnZ2VyTmF0aXZlKCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRtZW51Lm9uKCdjbGljaycsICdsaS4nICsgY2xhc3NOYW1lcy5ESVNBQkxFRCArICcgYSwgLicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIgKyAnLCAuJyArIGNsYXNzTmFtZXMuUE9QT1ZFUkhFQURFUiArICcgOm5vdCguY2xvc2UpJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9PSB0aGlzKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoICYmICEkKGUudGFyZ2V0KS5oYXNDbGFzcygnY2xvc2UnKSkge1xuICAgICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJG1lbnVJbm5lci5vbignY2xpY2snLCAnLmRpdmlkZXIsIC5kcm9wZG93bi1oZWFkZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kbWVudS5vbignY2xpY2snLCAnLicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIgKyAnIC5jbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kc2VhcmNoYm94Lm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kbWVudS5vbignY2xpY2snLCAnLmFjdGlvbnMtYnRuJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ2JzLXNlbGVjdC1hbGwnKSkge1xuICAgICAgICAgIHRoYXQuc2VsZWN0QWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhhdC5kZXNlbGVjdEFsbCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kYnV0dG9uXG4gICAgICAgIC5vbignZm9jdXMnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciB0YWJpbmRleCA9IHRoYXQuJGVsZW1lbnRbMF0uZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuXG4gICAgICAgICAgLy8gb25seSBjaGFuZ2Ugd2hlbiBidXR0b24gaXMgYWN0dWFsbHkgZm9jdXNlZFxuICAgICAgICAgIGlmICh0YWJpbmRleCAhPT0gdW5kZWZpbmVkICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuaXNUcnVzdGVkKSB7XG4gICAgICAgICAgICAvLyBhcHBseSBzZWxlY3QgZWxlbWVudCdzIHRhYmluZGV4IHRvIGVuc3VyZSBjb3JyZWN0IG9yZGVyIGlzIGZvbGxvd2VkIHdoZW4gdGFiYmluZyB0byB0aGUgbmV4dCBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0YWJpbmRleCk7XG4gICAgICAgICAgICAvLyBzZXQgZWxlbWVudCdzIHRhYmluZGV4IHRvIC0xIHRvIGFsbG93IGZvciByZXZlcnNlIHRhYmJpbmdcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnRbMF0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudGFiaW5kZXggPSB0YWJpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignYmx1cicgKyBFVkVOVF9LRVksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gcmV2ZXJ0IGV2ZXJ5dGhpbmcgdG8gb3JpZ2luYWwgdGFiaW5kZXhcbiAgICAgICAgICBpZiAodGhhdC5zZWxlY3RwaWNrZXIudmlldy50YWJpbmRleCAhPT0gdW5kZWZpbmVkICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuaXNUcnVzdGVkKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50WzBdLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnRhYmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudGFiaW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAub24oJ2NoYW5nZScgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnJlbmRlcigpO1xuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlZCcgKyBFVkVOVF9LRVksIGNoYW5nZWRBcmd1bWVudHMpO1xuICAgICAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBudWxsO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2ZvY3VzJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghdGhhdC5vcHRpb25zLm1vYmlsZSkgdGhhdC4kYnV0dG9uWzBdLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBsaXZlU2VhcmNoTGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgdGhpcy4kYnV0dG9uLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCEhdGhhdC4kc2VhcmNoYm94LnZhbCgpKSB7XG4gICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnZhbCgnJyk7XG4gICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLnByZXZpb3VzVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRzZWFyY2hib3gub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpIGZvY3VzLmJzLmRyb3Bkb3duLmRhdGEtYXBpIHRvdWNoZW5kLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRzZWFyY2hib3gub24oJ2lucHV0IHByb3BlcnR5Y2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VhcmNoVmFsdWUgPSB0aGF0LiRzZWFyY2hib3hbMF0udmFsdWU7XG5cbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5kYXRhID0gW107XG5cbiAgICAgICAgaWYgKHNlYXJjaFZhbHVlKSB7XG4gICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLnByZXZpb3VzVmFsdWUgPSBzZWFyY2hWYWx1ZTtcblxuICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuc291cmNlLnNlYXJjaCkge1xuICAgICAgICAgICAgdGhhdC5mZXRjaERhdGEoZnVuY3Rpb24gKGJ1aWx0RGF0YSkge1xuICAgICAgICAgICAgICB0aGF0LnJlbmRlcigpO1xuICAgICAgICAgICAgICB0aGF0LmJ1aWxkTGlzdCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICB0aGF0Lm5vU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhhdC4kbWVudUlubmVyLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgICAgICAgdGhhdC5jcmVhdGVWaWV3KHRydWUpO1xuICAgICAgICAgICAgICBzaG93Tm9SZXN1bHRzLmNhbGwodGhhdCwgYnVpbHREYXRhLCBzZWFyY2hWYWx1ZSk7XG4gICAgICAgICAgICB9LCAnc2VhcmNoJywgMCwgc2VhcmNoVmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBzZWFyY2hNYXRjaCA9IFtdLFxuICAgICAgICAgICAgICAgIHEgPSBzZWFyY2hWYWx1ZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIGNhY2hlID0ge30sXG4gICAgICAgICAgICAgICAgY2FjaGVBcnIgPSBbXSxcbiAgICAgICAgICAgICAgICBzZWFyY2hTdHlsZSA9IHRoYXQuX3NlYXJjaFN0eWxlKCksXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplU2VhcmNoID0gdGhhdC5vcHRpb25zLmxpdmVTZWFyY2hOb3JtYWxpemU7XG5cbiAgICAgICAgICAgIGlmIChub3JtYWxpemVTZWFyY2gpIHEgPSBub3JtYWxpemVUb0Jhc2UocSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBsaSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtpXTtcblxuICAgICAgICAgICAgICBpZiAoIWNhY2hlW2ldKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbaV0gPSBzdHJpbmdTZWFyY2gobGksIHEsIHNlYXJjaFN0eWxlLCBub3JtYWxpemVTZWFyY2gpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNhY2hlW2ldICYmIGxpLmhlYWRlckluZGV4ICE9PSB1bmRlZmluZWQgJiYgY2FjaGVBcnIuaW5kZXhPZihsaS5oZWFkZXJJbmRleCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpLmhlYWRlckluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgY2FjaGVbbGkuaGVhZGVySW5kZXggLSAxXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjYWNoZUFyci5wdXNoKGxpLmhlYWRlckluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FjaGVbbGkuaGVhZGVySW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWNoZUFyci5wdXNoKGxpLmhlYWRlckluZGV4KTtcblxuICAgICAgICAgICAgICAgIGNhY2hlW2xpLmxhc3RJbmRleCArIDFdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjYWNoZVtpXSAmJiBsaS50eXBlICE9PSAnb3B0Z3JvdXAtbGFiZWwnKSBjYWNoZUFyci5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgY2FjaGVMZW4gPSBjYWNoZUFyci5sZW5ndGg7IGkgPCBjYWNoZUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IGNhY2hlQXJyW2ldLFxuICAgICAgICAgICAgICAgICAgcHJldkluZGV4ID0gY2FjaGVBcnJbaSAtIDFdLFxuICAgICAgICAgICAgICAgICAgbGkgPSB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmRhdGFbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgbGlQcmV2ID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW3ByZXZJbmRleF07XG5cbiAgICAgICAgICAgICAgaWYgKGxpLnR5cGUgIT09ICdkaXZpZGVyJyB8fCAobGkudHlwZSA9PT0gJ2RpdmlkZXInICYmIGxpUHJldiAmJiBsaVByZXYudHlwZSAhPT0gJ2RpdmlkZXInICYmIGNhY2hlTGVuIC0gMSAhPT0gaSkpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2guZGF0YS5wdXNoKGxpKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hNYXRjaC5wdXNoKHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LmFjdGl2ZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGF0Lm5vU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoYXQuJG1lbnVJbm5lci5zY3JvbGxUb3AoMCk7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2guZWxlbWVudHMgPSBzZWFyY2hNYXRjaDtcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlVmlldyh0cnVlKTtcbiAgICAgICAgICAgIHNob3dOb1Jlc3VsdHMuY2FsbCh0aGF0LCBzZWFyY2hNYXRjaCwgc2VhcmNoVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2gucHJldmlvdXNWYWx1ZSkgeyAvLyBmb3IgSUUxMSAoIzI0MDIpXG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgICB0aGF0LmNyZWF0ZVZpZXcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3NlYXJjaFN0eWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxpdmVTZWFyY2hTdHlsZSB8fCAnY29udGFpbnMnO1xuICAgIH0sXG5cbiAgICB2YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50WzBdO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgc2VsZWN0ZWRPcHRpb25zID0gZ2V0U2VsZWN0ZWRPcHRpb25zLmNhbGwodGhpcyksXG4gICAgICAgICAgICBwcmV2VmFsdWUgPSBnZXRTZWxlY3RWYWx1ZXMuY2FsbCh0aGlzLCBzZWxlY3RlZE9wdGlvbnMpO1xuXG4gICAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBbbnVsbCwgbnVsbCwgcHJldlZhbHVlXTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFsgdmFsdWUgXTtcblxuICAgICAgICB2YWx1ZS5tYXAoU3RyaW5nKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gc2VsZWN0ZWRPcHRpb25zW2ldO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gJiYgdmFsdWUuaW5kZXhPZihTdHJpbmcoaXRlbS52YWx1ZSkpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZChpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSB1cGRhdGUgc2VsZWN0ZWQgdmFsdWUgaWYgaXQgbWF0Y2hlcyBhbiBleGlzdGluZyBvcHRpb25cbiAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFN0cmluZyhpdGVtLnZhbHVlKSkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkKGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZS5kYXRhKSBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0cGlja2VyLm1haW4ub3B0aW9uUXVldWUpO1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlZCcgKyBFVkVOVF9LRVksIGNoYW5nZWRBcmd1bWVudHMpO1xuXG4gICAgICAgIGlmICh0aGlzLiRuZXdFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuU0hPVykpIHtcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25TdGF0dXModHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaVNlbGVjdGVkSW5kZXggPSAoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0gfHwge30pLmxpSW5kZXg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlTZWxlY3RlZEluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkKHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtsaVNlbGVjdGVkSW5kZXhdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQudmFsKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNoYW5nZUFsbDogZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3VuZGVmaW5lZCcpIHN0YXR1cyA9IHRydWU7XG5cbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy4kZWxlbWVudFswXSxcbiAgICAgICAgICBwcmV2aW91c1NlbGVjdGVkID0gMCxcbiAgICAgICAgICBjdXJyZW50U2VsZWN0ZWQgPSAwLFxuICAgICAgICAgIHByZXZWYWx1ZSA9IGdldFNlbGVjdFZhbHVlcy5jYWxsKHRoaXMpO1xuXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2JzLXNlbGVjdC1oaWRkZW4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGRhdGEgPSB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGxpRGF0YSA9IGRhdGFbaV0sXG4gICAgICAgICAgICBvcHRpb24gPSBsaURhdGEub3B0aW9uO1xuXG4gICAgICAgIGlmIChvcHRpb24gJiYgIWxpRGF0YS5kaXNhYmxlZCAmJiBsaURhdGEudHlwZSAhPT0gJ2RpdmlkZXInKSB7XG4gICAgICAgICAgaWYgKGxpRGF0YS5zZWxlY3RlZCkgcHJldmlvdXNTZWxlY3RlZCsrO1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHN0YXR1cztcbiAgICAgICAgICBsaURhdGEuc2VsZWN0ZWQgPSBzdGF0dXM7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHJ1ZSkgY3VycmVudFNlbGVjdGVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdicy1zZWxlY3QtaGlkZGVuJyk7XG5cbiAgICAgIGlmIChwcmV2aW91c1NlbGVjdGVkID09PSBjdXJyZW50U2VsZWN0ZWQpIHJldHVybjtcblxuICAgICAgdGhpcy5zZXRPcHRpb25TdGF0dXMoKTtcblxuICAgICAgY2hhbmdlZEFyZ3VtZW50cyA9IFtudWxsLCBudWxsLCBwcmV2VmFsdWVdO1xuXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC50cmlnZ2VyTmF0aXZlKCdjaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFuZ2VBbGwodHJ1ZSk7XG4gICAgfSxcblxuICAgIGRlc2VsZWN0QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFuZ2VBbGwoZmFsc2UpO1xuICAgIH0sXG5cbiAgICB0b2dnbGU6IGZ1bmN0aW9uIChlLCBzdGF0ZSkge1xuICAgICAgdmFyIGlzQWN0aXZlLFxuICAgICAgICAgIHRyaWdnZXJDbGljayA9IHN0YXRlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgaWYgKGUpIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmICh0cmlnZ2VyQ2xpY2sgPT09IGZhbHNlKSB7XG4gICAgICAgIGlzQWN0aXZlID0gdGhpcy4kbmV3RWxlbWVudFswXS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lcy5TSE9XKTtcbiAgICAgICAgdHJpZ2dlckNsaWNrID0gc3RhdGUgPT09IHRydWUgJiYgaXNBY3RpdmUgPT09IGZhbHNlIHx8IHN0YXRlID09PSBmYWxzZSAmJiBpc0FjdGl2ZSA9PT0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyaWdnZXJDbGljaykgdGhpcy4kYnV0dG9uLnRyaWdnZXIoJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJyk7XG4gICAgfSxcblxuICAgIG9wZW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnRvZ2dsZShlLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgY2xvc2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnRvZ2dsZShlLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIGtleWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgIGlzVG9nZ2xlID0gJHRoaXMuaGFzQ2xhc3MoJ2Ryb3Bkb3duLXRvZ2dsZScpLFxuICAgICAgICAgICRwYXJlbnQgPSBpc1RvZ2dsZSA/ICR0aGlzLmNsb3Nlc3QoJy5kcm9wZG93bicpIDogJHRoaXMuY2xvc2VzdChTZWxlY3Rvci5NRU5VKSxcbiAgICAgICAgICB0aGF0ID0gJHBhcmVudC5kYXRhKCd0aGlzJyksXG4gICAgICAgICAgJGl0ZW1zID0gdGhhdC5maW5kTGlzKCksXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgaXNBY3RpdmUsXG4gICAgICAgICAgbGlBY3RpdmUsXG4gICAgICAgICAgYWN0aXZlTGksXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIHVwZGF0ZVNjcm9sbCA9IGZhbHNlLFxuICAgICAgICAgIGRvd25PblRhYiA9IGUud2hpY2ggPT09IGtleUNvZGVzLlRBQiAmJiAhaXNUb2dnbGUgJiYgIXRoYXQub3B0aW9ucy5zZWxlY3RPblRhYixcbiAgICAgICAgICBpc0Fycm93S2V5ID0gUkVHRVhQX0FSUk9XLnRlc3QoZS53aGljaCkgfHwgZG93bk9uVGFiLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AsXG4gICAgICAgICAgaXNWaXJ0dWFsID0gdGhhdC5pc1ZpcnR1YWwoKSxcbiAgICAgICAgICBwb3NpdGlvbjAgPSBpc1ZpcnR1YWwgPT09IHRydWUgPyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCA6IDA7XG5cbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgYSBmdW5jdGlvbiBrZXkgaXMgcHJlc3NlZFxuICAgICAgaWYgKGUud2hpY2ggPj0gMTEyICYmIGUud2hpY2ggPD0gMTIzKSByZXR1cm47XG5cbiAgICAgIGlzQWN0aXZlID0gdGhhdC4kbWVudS5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpO1xuXG4gICAgICBpZiAoXG4gICAgICAgICFpc0FjdGl2ZSAmJlxuICAgICAgICAoXG4gICAgICAgICAgaXNBcnJvd0tleSB8fFxuICAgICAgICAgIChlLndoaWNoID49IDQ4ICYmIGUud2hpY2ggPD0gNTcpIHx8XG4gICAgICAgICAgKGUud2hpY2ggPj0gOTYgJiYgZS53aGljaCA8PSAxMDUpIHx8XG4gICAgICAgICAgKGUud2hpY2ggPj0gNjUgJiYgZS53aGljaCA8PSA5MClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScpO1xuXG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZS53aGljaCA9PT0ga2V5Q29kZXMuRVNDQVBFICYmIGlzQWN0aXZlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJykudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyb3dLZXkpIHsgLy8gaWYgdXAgb3IgZG93blxuICAgICAgICBpZiAoISRpdGVtcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICBsaUFjdGl2ZSA9IHRoYXQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgaW5kZXggPSBsaUFjdGl2ZSA/IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobGlBY3RpdmUucGFyZW50RWxlbWVudC5jaGlsZHJlbiwgbGlBY3RpdmUpIDogLTE7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRoYXQuZGVmb2N1c0l0ZW0obGlBY3RpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkFSUk9XX1VQKSB7IC8vIHVwXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgaW5kZXgtLTtcbiAgICAgICAgICBpZiAoaW5kZXggKyBwb3NpdGlvbjAgPCAwKSBpbmRleCArPSAkaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKCF0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodFtpbmRleCArIHBvc2l0aW9uMF0pIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHQuc2xpY2UoMCwgaW5kZXggKyBwb3NpdGlvbjApLmxhc3RJbmRleE9mKHRydWUpIC0gcG9zaXRpb24wO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgaW5kZXggPSAkaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0ga2V5Q29kZXMuQVJST1dfRE9XTiB8fCBkb3duT25UYWIpIHsgLy8gZG93blxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgaWYgKGluZGV4ICsgcG9zaXRpb24wID49IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0Lmxlbmd0aCkgaW5kZXggPSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmZpcnN0SGlnaGxpZ2h0SW5kZXg7XG5cbiAgICAgICAgICBpZiAoIXRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0W2luZGV4ICsgcG9zaXRpb24wXSkge1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDEgKyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5zbGljZShpbmRleCArIHBvc2l0aW9uMCArIDEpLmluZGV4T2YodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBsaUFjdGl2ZUluZGV4ID0gcG9zaXRpb24wICsgaW5kZXg7XG5cbiAgICAgICAgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkFSUk9XX1VQKSB7IC8vIHVwXG4gICAgICAgICAgLy8gc2Nyb2xsIHRvIGJvdHRvbSBhbmQgaGlnaGxpZ2h0IGxhc3Qgb3B0aW9uXG4gICAgICAgICAgaWYgKHBvc2l0aW9uMCA9PT0gMCAmJiBpbmRleCA9PT0gJGl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSB0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsSGVpZ2h0O1xuXG4gICAgICAgICAgICBsaUFjdGl2ZUluZGV4ID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVMaSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtsaUFjdGl2ZUluZGV4XTtcblxuICAgICAgICAgICAgLy8gY291bGQgYmUgdW5kZWZpbmVkIGlmIG5vIHJlc3VsdHMgZXhpc3RcbiAgICAgICAgICAgIGlmIChhY3RpdmVMaSkge1xuICAgICAgICAgICAgICBvZmZzZXQgPSBhY3RpdmVMaS5wb3NpdGlvbiAtIGFjdGl2ZUxpLmhlaWdodDtcblxuICAgICAgICAgICAgICB1cGRhdGVTY3JvbGwgPSBvZmZzZXQgPCBzY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkFSUk9XX0RPV04gfHwgZG93bk9uVGFiKSB7IC8vIGRvd25cbiAgICAgICAgICAvLyBzY3JvbGwgdG8gdG9wIGFuZCBoaWdobGlnaHQgZmlyc3Qgb3B0aW9uXG4gICAgICAgICAgaWYgKGluZGV4ID09PSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmZpcnN0SGlnaGxpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSAwO1xuXG4gICAgICAgICAgICBsaUFjdGl2ZUluZGV4ID0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVMaSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtsaUFjdGl2ZUluZGV4XTtcblxuICAgICAgICAgICAgLy8gY291bGQgYmUgdW5kZWZpbmVkIGlmIG5vIHJlc3VsdHMgZXhpc3RcbiAgICAgICAgICAgIGlmIChhY3RpdmVMaSkge1xuICAgICAgICAgICAgICBvZmZzZXQgPSBhY3RpdmVMaS5wb3NpdGlvbiAtIHRoYXQuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgICAgIHVwZGF0ZVNjcm9sbCA9IG9mZnNldCA+IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaUFjdGl2ZSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHNbbGlBY3RpdmVJbmRleF07XG5cbiAgICAgICAgdGhhdC5hY3RpdmVFbGVtZW50ID0gKHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtsaUFjdGl2ZUluZGV4XSB8fCB7fSkuZWxlbWVudDtcblxuICAgICAgICB0aGF0LmZvY3VzSXRlbShsaUFjdGl2ZSk7XG5cbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jdXJyZW50QWN0aXZlID0gbGlBY3RpdmU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVNjcm9sbCkgdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCA9IG9mZnNldDtcblxuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcbiAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAoISR0aGlzLmlzKCdpbnB1dCcpICYmICFSRUdFWFBfVEFCX09SX0VTQ0FQRS50ZXN0KGUud2hpY2gpKSB8fFxuICAgICAgICAoZS53aGljaCA9PT0ga2V5Q29kZXMuU1BBQ0UgJiYgdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5rZXlIaXN0b3J5KVxuICAgICAgKSB7XG4gICAgICAgIHZhciBzZWFyY2hNYXRjaCxcbiAgICAgICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgICAgIGtleUhpc3Rvcnk7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ua2V5SGlzdG9yeSArPSBrZXlDb2RlTWFwW2Uud2hpY2hdO1xuXG4gICAgICAgIGlmICh0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLnJlc2V0S2V5SGlzdG9yeS5jYW5jZWwpIGNsZWFyVGltZW91dCh0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLnJlc2V0S2V5SGlzdG9yeS5jYW5jZWwpO1xuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLnJlc2V0S2V5SGlzdG9yeS5jYW5jZWwgPSB0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLnJlc2V0S2V5SGlzdG9yeS5zdGFydCgpO1xuXG4gICAgICAgIGtleUhpc3RvcnkgPSB0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLmtleUhpc3Rvcnk7XG5cbiAgICAgICAgLy8gaWYgYWxsIGxldHRlcnMgYXJlIHRoZSBzYW1lLCBzZXQga2V5SGlzdG9yeSB0byBqdXN0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgd2hlbiBzZWFyY2hpbmdcbiAgICAgICAgaWYgKC9eKC4pXFwxKyQvLnRlc3Qoa2V5SGlzdG9yeSkpIHtcbiAgICAgICAgICBrZXlIaXN0b3J5ID0ga2V5SGlzdG9yeS5jaGFyQXQoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIG1hdGNoZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGkgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbaV0sXG4gICAgICAgICAgICAgIGhhc01hdGNoO1xuXG4gICAgICAgICAgaGFzTWF0Y2ggPSBzdHJpbmdTZWFyY2gobGksIGtleUhpc3RvcnksICdzdGFydHNXaXRoJywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoaGFzTWF0Y2ggJiYgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHRbaV0pIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChsaS5lbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hJbmRleCA9IDA7XG5cbiAgICAgICAgICAkaXRlbXMucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpLmZpbmQoJ2EnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cbiAgICAgICAgICAvLyBlaXRoZXIgb25seSBvbmUga2V5IGhhcyBiZWVuIHByZXNzZWQgb3IgdGhleSBhcmUgYWxsIHRoZSBzYW1lIGtleVxuICAgICAgICAgIGlmIChrZXlIaXN0b3J5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbWF0Y2hJbmRleCA9IG1hdGNoZXMuaW5kZXhPZih0aGF0LmFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hJbmRleCA9PT0gLTEgfHwgbWF0Y2hJbmRleCA9PT0gbWF0Y2hlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIG1hdGNoSW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0Y2hJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlYXJjaE1hdGNoID0gbWF0Y2hlc1ttYXRjaEluZGV4XTtcblxuICAgICAgICAgIGFjdGl2ZUxpID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW3NlYXJjaE1hdGNoXTtcblxuICAgICAgICAgIGlmIChzY3JvbGxUb3AgLSBhY3RpdmVMaS5wb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGFjdGl2ZUxpLnBvc2l0aW9uIC0gYWN0aXZlTGkuaGVpZ2h0O1xuICAgICAgICAgICAgdXBkYXRlU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gYWN0aXZlTGkucG9zaXRpb24gLSB0aGF0LnNpemVJbmZvLm1lbnVJbm5lckhlaWdodDtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBvcHRpb24gaXMgYWxyZWFkeSB2aXNpYmxlIGF0IHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiwganVzdCBrZWVwIGl0IHRoZSBzYW1lXG4gICAgICAgICAgICB1cGRhdGVTY3JvbGwgPSBhY3RpdmVMaS5wb3NpdGlvbiA+IHNjcm9sbFRvcCArIHRoYXQuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpQWN0aXZlID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50c1tzZWFyY2hNYXRjaF07XG5cbiAgICAgICAgICB0aGF0LmFjdGl2ZUVsZW1lbnQgPSBsaUFjdGl2ZTtcblxuICAgICAgICAgIHRoYXQuZm9jdXNJdGVtKGxpQWN0aXZlKTtcblxuICAgICAgICAgIGlmIChsaUFjdGl2ZSkgbGlBY3RpdmUuZmlyc3RDaGlsZC5mb2N1cygpO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVNjcm9sbCkgdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCA9IG9mZnNldDtcblxuICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IGZvY3VzZWQgb3B0aW9uIGlmIFwiRW50ZXJcIiwgXCJTcGFjZWJhclwiIG9yIFwiVGFiXCIgKHdoZW4gc2VsZWN0T25UYWIgaXMgdHJ1ZSkgYXJlIHByZXNzZWQgaW5zaWRlIHRoZSBtZW51LlxuICAgICAgaWYgKFxuICAgICAgICBpc0FjdGl2ZSAmJlxuICAgICAgICAoXG4gICAgICAgICAgKGUud2hpY2ggPT09IGtleUNvZGVzLlNQQUNFICYmICF0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLmtleUhpc3RvcnkpIHx8XG4gICAgICAgICAgZS53aGljaCA9PT0ga2V5Q29kZXMuRU5URVIgfHxcbiAgICAgICAgICAoZS53aGljaCA9PT0ga2V5Q29kZXMuVEFCICYmIHRoYXQub3B0aW9ucy5zZWxlY3RPblRhYilcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChlLndoaWNoICE9PSBrZXlDb2Rlcy5TUEFDRSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghdGhhdC5vcHRpb25zLmxpdmVTZWFyY2ggfHwgZS53aGljaCAhPT0ga2V5Q29kZXMuU1BBQ0UpIHtcbiAgICAgICAgICB0aGF0LiRtZW51SW5uZXIuZmluZCgnLmFjdGl2ZSBhJykudHJpZ2dlcignY2xpY2snLCB0cnVlKTsgLy8gcmV0YWluIGFjdGl2ZSBjbGFzc1xuICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cbiAgICAgICAgICBpZiAoIXRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHNjcmVlbiBmcm9tIHNjcm9sbGluZyBpZiB0aGUgdXNlciBoaXRzIHRoZSBzcGFjZWJhclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gRml4ZXMgc3BhY2ViYXIgc2VsZWN0aW9uIG9mIGRyb3Bkb3duIGl0ZW1zIGluIEZGICYgSUVcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLmRhdGEoJ3NwYWNlU2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1vYmlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZW5zdXJlIG1vYmlsZSBpcyBzZXQgdG8gdHJ1ZSBpZiBtb2JpbGUgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGluaXRcbiAgICAgIHRoaXMub3B0aW9ucy5tb2JpbGUgPSB0cnVlO1xuICAgICAgdGhpcy4kZWxlbWVudFswXS5jbGFzc0xpc3QuYWRkKCdtb2JpbGUtZGV2aWNlJyk7XG4gICAgfSxcblxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIC8vIHVwZGF0ZSBvcHRpb25zIGlmIGRhdGEgYXR0cmlidXRlcyBoYXZlIGJlZW4gY2hhbmdlZFxuICAgICAgdmFyIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIGdldEF0dHJpYnV0ZXNPYmplY3QodGhpcy4kZWxlbWVudCksIHRoaXMuJGVsZW1lbnQuZGF0YSgpKTsgLy8gaW4gdGhpcyBvcmRlciBvbiByZWZyZXNoLCBhcyB1c2VyIG1heSBjaGFuZ2UgYXR0cmlidXRlcyBvbiBzZWxlY3QsIGFuZCBvcHRpb25zIG9iamVjdCBpcyBub3QgcGFzc2VkIG9uIHJlZnJlc2hcbiAgICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZztcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2UuZGF0YSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLmJ1aWxkTGlzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mZXRjaERhdGEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQucmVuZGVyKCk7XG4gICAgICAgICAgdGhhdC5idWlsZExpc3QoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hlY2tEaXNhYmxlZCgpO1xuICAgICAgdGhpcy5zZXRTdHlsZSgpO1xuICAgICAgdGhpcy5zZXRXaWR0aCgpO1xuXG4gICAgICB0aGlzLnNldFNpemUodHJ1ZSk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncmVmcmVzaGVkJyArIEVWRU5UX0tFWSk7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJG5ld0VsZW1lbnQuaGlkZSgpO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRuZXdFbGVtZW50LnNob3coKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRuZXdFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kbmV3RWxlbWVudC5iZWZvcmUodGhpcy4kZWxlbWVudCkucmVtb3ZlKCk7XG5cbiAgICAgIGlmICh0aGlzLiRic0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLiRic0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJG1lbnUucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uICYmIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24ucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9mZihFVkVOVF9LRVkpXG4gICAgICAgIC5yZW1vdmVEYXRhKCdzZWxlY3RwaWNrZXInKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2JzLXNlbGVjdC1oaWRkZW4gc2VsZWN0cGlja2VyIG1vYmlsZS1kZXZpY2UnKTtcblxuICAgICAgJCh3aW5kb3cpLm9mZihFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU0VMRUNUUElDS0VSIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBQbHVnaW4gKG9wdGlvbikge1xuICAgIC8vIGdldCB0aGUgYXJncyBvZiB0aGUgb3V0ZXIgZnVuY3Rpb24uLlxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIC8vIFRoZSBhcmd1bWVudHMgb2YgdGhlIGZ1bmN0aW9uIGFyZSBleHBsaWNpdGx5IHJlLWRlZmluZWQgZnJvbSB0aGUgYXJndW1lbnQgbGlzdCwgYmVjYXVzZSB0aGUgc2hpZnQgY2F1c2VzIHRoZW1cbiAgICAvLyB0byBnZXQgbG9zdC9jb3JydXB0ZWQgaW4gYW5kcm9pZCAyLjMgYW5kIElFOSAjNzE1ICM3NzVcbiAgICB2YXIgX29wdGlvbiA9IG9wdGlvbjtcblxuICAgIFtdLnNoaWZ0LmFwcGx5KGFyZ3MpO1xuXG4gICAgLy8gaWYgdGhlIHZlcnNpb24gd2FzIG5vdCBzZXQgc3VjY2Vzc2Z1bGx5XG4gICAgaWYgKCF2ZXJzaW9uLnN1Y2Nlc3MpIHtcbiAgICAgIC8vIHRyeSB0byByZXRyZWl2ZSBpdCBhZ2FpblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbi5mdWxsID0gKGdldFZlcnNpb24oKSB8fCAnJykuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGZhbGwgYmFjayB0byB1c2UgQm9vdHN0cmFwVmVyc2lvbiBpZiBzZXRcbiAgICAgICAgaWYgKFNlbGVjdHBpY2tlci5Cb290c3RyYXBWZXJzaW9uKSB7XG4gICAgICAgICAgdmVyc2lvbi5mdWxsID0gU2VsZWN0cGlja2VyLkJvb3RzdHJhcFZlcnNpb24uc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnNpb24uZnVsbCA9IFt2ZXJzaW9uLm1ham9yLCAnMCcsICcwJ107XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnVGhlcmUgd2FzIGFuIGlzc3VlIHJldHJpZXZpbmcgQm9vdHN0cmFwXFwncyB2ZXJzaW9uLiAnICtcbiAgICAgICAgICAgICdFbnN1cmUgQm9vdHN0cmFwIGlzIGJlaW5nIGxvYWRlZCBiZWZvcmUgYm9vdHN0cmFwLXNlbGVjdCBhbmQgdGhlcmUgaXMgbm8gbmFtZXNwYWNlIGNvbGxpc2lvbi4gJyArXG4gICAgICAgICAgICAnSWYgbG9hZGluZyBCb290c3RyYXAgYXN5bmNocm9ub3VzbHksIHRoZSB2ZXJzaW9uIG1heSBuZWVkIHRvIGJlIG1hbnVhbGx5IHNwZWNpZmllZCB2aWEgJC5mbi5zZWxlY3RwaWNrZXIuQ29uc3RydWN0b3IuQm9vdHN0cmFwVmVyc2lvbi4nLFxuICAgICAgICAgICAgZXJyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2ZXJzaW9uLm1ham9yID0gdmVyc2lvbi5mdWxsWzBdO1xuICAgICAgdmVyc2lvbi5zdWNjZXNzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5tYWpvciA+PSAnNCcpIHtcbiAgICAgIC8vIHNvbWUgZGVmYXVsdHMgbmVlZCB0byBiZSBjaGFuZ2VkIGlmIHVzaW5nIEJvb3RzdHJhcCA0XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhleSBoYXZlIGFscmVhZHkgYmVlbiBtYW51YWxseSBjaGFuZ2VkIGJlZm9yZSBmb3JjaW5nIHRoZW0gdG8gdXBkYXRlXG4gICAgICB2YXIgdG9VcGRhdGUgPSBbXTtcblxuICAgICAgaWYgKFNlbGVjdHBpY2tlci5ERUZBVUxUUy5zdHlsZSA9PT0gY2xhc3NOYW1lcy5CVVRUT05DTEFTUykgdG9VcGRhdGUucHVzaCh7IG5hbWU6ICdzdHlsZScsIGNsYXNzTmFtZTogJ0JVVFRPTkNMQVNTJyB9KTtcbiAgICAgIGlmIChTZWxlY3RwaWNrZXIuREVGQVVMVFMuaWNvbkJhc2UgPT09IGNsYXNzTmFtZXMuSUNPTkJBU0UpIHRvVXBkYXRlLnB1c2goeyBuYW1lOiAnaWNvbkJhc2UnLCBjbGFzc05hbWU6ICdJQ09OQkFTRScgfSk7XG4gICAgICBpZiAoU2VsZWN0cGlja2VyLkRFRkFVTFRTLnRpY2tJY29uID09PSBjbGFzc05hbWVzLlRJQ0tJQ09OKSB0b1VwZGF0ZS5wdXNoKHsgbmFtZTogJ3RpY2tJY29uJywgY2xhc3NOYW1lOiAnVElDS0lDT04nIH0pO1xuXG4gICAgICBjbGFzc05hbWVzLkRJVklERVIgPSAnZHJvcGRvd24tZGl2aWRlcic7XG4gICAgICBjbGFzc05hbWVzLlNIT1cgPSAnc2hvdyc7XG4gICAgICBjbGFzc05hbWVzLkJVVFRPTkNMQVNTID0gJ2J0bi1saWdodCc7XG4gICAgICBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIgPSAncG9wb3Zlci1oZWFkZXInO1xuICAgICAgY2xhc3NOYW1lcy5JQ09OQkFTRSA9ICcnO1xuICAgICAgY2xhc3NOYW1lcy5USUNLSUNPTiA9ICdicy1vay1kZWZhdWx0JztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3B0aW9uID0gdG9VcGRhdGVbaV07XG4gICAgICAgIFNlbGVjdHBpY2tlci5ERUZBVUxUU1tvcHRpb24ubmFtZV0gPSBjbGFzc05hbWVzW29wdGlvbi5jbGFzc05hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLm1ham9yID4gJzQnKSB7XG4gICAgICBTZWxlY3Rvci5EQVRBX1RPR0dMRSA9ICdkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCInO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgY2hhaW4gPSB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgIGlmICgkdGhpcy5pcygnc2VsZWN0JykpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkdGhpcy5kYXRhKCdzZWxlY3RwaWNrZXInKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2YgX29wdGlvbiA9PSAnb2JqZWN0JyAmJiBfb3B0aW9uO1xuXG4gICAgICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAvLyAodXNpbmcgdGl0bGUgYXMgcGxhY2Vob2xkZXIgaXMgZGVwcmVjYXRlZCAtIHJlbW92ZSBpbiB2Mi4wLjApXG4gICAgICAgIGlmIChvcHRpb25zLnRpdGxlKSBvcHRpb25zLnBsYWNlaG9sZGVyID0gb3B0aW9ucy50aXRsZTtcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICB2YXIgZGF0YUF0dHJpYnV0ZXMgPSAkdGhpcy5kYXRhKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBkYXRhQXR0ciBpbiBkYXRhQXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhQXR0cmlidXRlcywgZGF0YUF0dHIpICYmICQuaW5BcnJheShkYXRhQXR0ciwgRElTQUxMT1dFRF9BVFRSSUJVVEVTKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29uZmlnID0gJC5leHRlbmQoe30sIFNlbGVjdHBpY2tlci5ERUZBVUxUUywgJC5mbi5zZWxlY3RwaWNrZXIuZGVmYXVsdHMgfHwge30sIGdldEF0dHJpYnV0ZXNPYmplY3QoJHRoaXMpLCBkYXRhQXR0cmlidXRlcywgb3B0aW9ucyk7IC8vIHRoaXMgaXMgY29ycmVjdCBvcmRlciBvbiBpbml0aWFsIHJlbmRlclxuICAgICAgICAgIGNvbmZpZy50ZW1wbGF0ZSA9ICQuZXh0ZW5kKHt9LCBTZWxlY3RwaWNrZXIuREVGQVVMVFMudGVtcGxhdGUsICgkLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cyA/ICQuZm4uc2VsZWN0cGlja2VyLmRlZmF1bHRzLnRlbXBsYXRlIDoge30pLCBkYXRhQXR0cmlidXRlcy50ZW1wbGF0ZSwgb3B0aW9ucy50ZW1wbGF0ZSk7XG4gICAgICAgICAgY29uZmlnLnNvdXJjZSA9ICQuZXh0ZW5kKHt9LCBTZWxlY3RwaWNrZXIuREVGQVVMVFMuc291cmNlLCAoJC5mbi5zZWxlY3RwaWNrZXIuZGVmYXVsdHMgPyAkLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cy5zb3VyY2UgOiB7fSksIG9wdGlvbnMuc291cmNlKTtcbiAgICAgICAgICAkdGhpcy5kYXRhKCdzZWxlY3RwaWNrZXInLCAoZGF0YSA9IG5ldyBTZWxlY3RwaWNrZXIodGhpcywgY29uZmlnKSkpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgaSkpIHtcbiAgICAgICAgICAgICAgZGF0YS5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIF9vcHRpb24gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtfb3B0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGFbX29wdGlvbl0uYXBwbHkoZGF0YSwgYXJncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YS5vcHRpb25zW19vcHRpb25dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEFzc2lnbm1lbnRcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnNlbGVjdHBpY2tlcjtcbiAgJC5mbi5zZWxlY3RwaWNrZXIgPSBQbHVnaW47XG4gICQuZm4uc2VsZWN0cGlja2VyLkNvbnN0cnVjdG9yID0gU2VsZWN0cGlja2VyO1xuXG4gIC8vIFNFTEVDVFBJQ0tFUiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgJC5mbi5zZWxlY3RwaWNrZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnNlbGVjdHBpY2tlciA9IG9sZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBnZXQgQm9vdHN0cmFwJ3Mga2V5ZG93biBldmVudCBoYW5kbGVyIGZvciBlaXRoZXIgQm9vdHN0cmFwIDQgb3IgQm9vdHN0cmFwIDNcbiAgZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIgKCkge1xuICAgIGlmICh2ZXJzaW9uLm1ham9yIDwgNSkge1xuICAgICAgaWYgKCQuZm4uZHJvcGRvd24pIHtcbiAgICAgICAgLy8gd2FpdCB0byBkZWZpbmUgdW50aWwgZnVuY3Rpb24gaXMgY2FsbGVkIGluIGNhc2UgQm9vdHN0cmFwIGlzbid0IGxvYWRlZCB5ZXRcbiAgICAgICAgdmFyIGJvb3RzdHJhcEtleWRvd24gPSAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIgfHwgJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3Rvci5wcm90b3R5cGUua2V5ZG93bjtcbiAgICAgICAgcmV0dXJuIGJvb3RzdHJhcEtleWRvd24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcjtcbiAgICB9XG4gIH1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vZmYoJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsICc6bm90KC5ib290c3RyYXAtc2VsZWN0KSA+IFsnICsgU2VsZWN0b3IuREFUQV9UT0dHTEUgKyAnXScsIGtleWRvd25IYW5kbGVyKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsICc6bm90KC5ib290c3RyYXAtc2VsZWN0KSA+IC5kcm9wZG93bi1tZW51Jywga2V5ZG93bkhhbmRsZXIpXG4gICAgLm9uKCdrZXlkb3duJyArIEVWRU5UX0tFWSwgJy5ib290c3RyYXAtc2VsZWN0IFsnICsgU2VsZWN0b3IuREFUQV9UT0dHTEUgKyAnXSwgLmJvb3RzdHJhcC1zZWxlY3QgW3JvbGU9XCJsaXN0Ym94XCJdLCAuYm9vdHN0cmFwLXNlbGVjdCAuYnMtc2VhcmNoYm94IGlucHV0JywgU2VsZWN0cGlja2VyLnByb3RvdHlwZS5rZXlkb3duKVxuICAgIC5vbignZm9jdXNpbi5tb2RhbCcsICcuYm9vdHN0cmFwLXNlbGVjdCBbJyArIFNlbGVjdG9yLkRBVEFfVE9HR0xFICsgJ10sIC5ib290c3RyYXAtc2VsZWN0IFtyb2xlPVwibGlzdGJveFwiXSwgLmJvb3RzdHJhcC1zZWxlY3QgLmJzLXNlYXJjaGJveCBpbnB1dCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuXG4gIC8vIFNFTEVDVFBJQ0tFUiBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT1cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCcuc2VsZWN0cGlja2VyJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHNlbGVjdHBpY2tlciA9ICQodGhpcyk7XG4gICAgICBQbHVnaW4uY2FsbCgkc2VsZWN0cGlja2VyLCAkc2VsZWN0cGlja2VyLmRhdGEoKSk7XG4gICAgfSk7XG4gIH0pO1xufSkoalF1ZXJ5KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bootstrap-select/js/bootstrap-select.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/bootstrap-select/bootstrap-select.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});